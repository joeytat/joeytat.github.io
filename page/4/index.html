<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.152.2"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Joeytat's Dev Log</title><meta name=keywords content="Blog,iOS"><meta name=description content><meta name=author content><link rel=canonical href=https://joeytat.github.io/><meta name=google-site-verification content="G-83QEEKFELL"><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://joeytat.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://joeytat.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://joeytat.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://joeytat.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://joeytat.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://joeytat.github.io/index.xml><link rel=alternate hreflang=en href=https://joeytat.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-83QEEKFELL"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-83QEEKFELL")}</script><meta property="og:url" content="https://joeytat.github.io/"><meta property="og:site_name" content="Joeytat's Dev Log"><meta property="og:title" content="Joeytat's Dev Log"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Joeytat's Dev Log"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"Joeytat's Dev Log","url":"https://joeytat.github.io/","description":"","logo":"https://joeytat.github.io/%3Clink%20/%20abs%20url%3E","sameAs":[]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://joeytat.github.io/ accesskey=h title="Dev Log (Alt + H)"><img src=https://joeytat.github.io/apple-touch-icon.png alt aria-label=logo height=35>Dev Log</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://joeytat.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=https://joeytat.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>SwiftUI 状态管理 —— Composible Binding</h2></header><div class=entry-content><p>在 SwiftUI 中，需要通过数据来驱动 UI 的变化。数据结构抽象描述的质量也影响着我们对 SwiftUI 界面的维护。
通常数据中可能存在很多状态，如果使用很多的 boolean 值来描述这些状态，那么 App 的可维护性可能会大大降低。
管理独立状态的问题 假设我们有一个 App，用户可以在登录与非登录状态下进行操作。所以我们的界面需要兼容这两种状态，其描述可能是这样的：
class AppState: ObservableObject { @Published var user: User? = nil @Published var error: Error? = nil var authenticated: Bool { user != nil } var hasError: Bool { error != nil } } 基于这样的状态描述，如果我们想创建一个仅展示用户名的组件大概会是这样：
var body: some View { Group { if state.hasError { Text("Oops, sth went wrong: \(state.error!.localizedDescription)") } if state.authenticated { Text("Hello \(state.user?.name ?? "Unknown")!") } else { Text("Hello, stranger") } } } 粗看没有什么问题，实际上在维护这样的数据结构时就需要格外小心了。比如第一次我们登录失败，为了展示错误信息给 error 设置了值之后。必须在登录成功之后要及时地去清空 error，否则即使 state.authenticated 等于 true，用户依然无法看到正确的信息。
这还仅仅是有两个状态的情况下，像这样独立状态属性会带来很大的维护成本，开发者需要牢记各个属性之间的依赖关系，甚至编写界面的时候，还需要注意代码执行顺序。
引入状态机 把状态抽象成带有 associated values 的 enum 是个更好的选择，比如:
class AppState: ObservableObject { enum AccountState { case authenticated(User) case unauthenticated case error(Error) } @Published var accountState: AccountState = .unauthenticated } // 界面中的使用 var body: some View { VStack { switch state.accountState { case .authenticated(let user): Text("Hello \(user.name)!") case .unauthenticated: Text("unregister") case .error(let error): Text("Oops, sth went wrong: \(error.localizedDescription)") } } 这样被状态机驱动的界面看起来要直观多了。并且在每个状态中对数据的操作，也由 enum 赋予了隔离能力。
...</p></div><footer class=entry-footer><span title='2022-01-03 00:00:00 +0000 UTC'>January 3, 2022</span></footer><a class=entry-link aria-label="post link to SwiftUI 状态管理 —— Composible Binding" href=https://joeytat.github.io/posts/composible_binding/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>JavaScript 既然是单线程语言，为什么 setTimeout 不会阻塞线程？</h2></header><div class=entry-content><p>先看下面的代码
function printHello() { console.log("Hello"); } function printWorld() { console.log("World"); } printHello(); // 输出 Hello printWorld(); // 输出 World 在 JavaScript 中，存在一个全局调用栈(Global Call Stack)。当我们调用 printHello 时，会将该方法加入到栈中，由于 JavaScript 是单线程执行机制（同一时间只执行一个命令），所以会在执行完成了 printHello 之后再执行 printWorld。
那么现在就引入标题中的问题，JavaScript 既然是单线程语言，为什么 setTimeout 不会阻塞线程？
function printHello() { console.log("Hello"); } function printWorld() { console.log("World"); } setTimeout(printHello, 1000); printWorld(); 表面上来看 setTimeout 也是一个方法，他的定义可能是这样：
function setTimeout(callbackFunc, interval) { // .... } 那么按照 JS 单线程理论来说，应该是先将 setTimeout 方法压入全局调用栈，并且执行该方法，等待 1 秒钟，然后再执行 printWorld 才对。但实际上我们都知道，打印的结果会是 “World” 然后 “Hello”，这是为什么？
Web Browser API & Callback Queue 事实上 setTimeout 并不是完全是 JS 代码，而是属于 Web Browser API 中的方法。就像名字中所指的那样， JS 调用了 setTimeout 之后，浏览器（Web Browser）会去创建一个 timer，同时将我们传入 setTimeout 的方法 - printHello 加入到 Callback Queue（回调队列） 中。
...</p></div><footer class=entry-footer><span title='2019-08-19 00:00:00 +0000 UTC'>August 19, 2019</span></footer><a class=entry-link aria-label="post link to JavaScript 既然是单线程语言，为什么 setTimeout 不会阻塞线程？" href=https://joeytat.github.io/posts/asynchronous-javascript/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>React 进阶模式之复合组件（Compound Component）</h2></header><div class=entry-content><p>复合组件是什么 编写页面时，经常存在多个子组件的展示，是依赖于同一个数据源的情况。 比如单选框：
&lt;Switcher> &lt;Switch on={this.props.selecting == 'React'}>React&lt;/Switch> &lt;Switch on={this.props.selecting == 'Vue'}>Vue&lt;/Switch> &lt;/Switcher> 我们可以看到，所有的 Switch 的数据都需要对 selecting 的值进行判断，并且代码中其实只有 this.props.selecting == 后面的部分不同，如果能改写成这样：
static Switcher.React = ({selecting}) => ( &lt;Switch on={selecting === 'React'}>React&lt;/Switch> ) static Switcher.Vue = ({selecting}) => ( &lt;Switch on={selecting === 'Vue'}>Vue&lt;/Switch> ) &lt;Switcher selecting={this.props.selecting}> &lt;Switcher.React/> &lt;Switcher.Vue/> &lt;/Switcher> 隐式地将父组件的数据传递给子组件，其显示逻辑交由给子组件自行处理，代码的组织结构将会清晰很多。后续即使需求变动，数据的传递改变也并不需要我们操心（不需要一个子组件一个子组件地添加传递），只需要修改 Switcher 子控件内部处理逻辑即可。
那么要怎么实现这个隐式数据传递呢？ 可以通过 React.Children.map 和 React.cloneElement 这两个 API 来实现。
React.Children.map 与 React.cloneElement 在 render 中我们可以使用 React.Children.map 来获取到 Switcher 中的子组件，然后通过 React.cloneElement 对组件进行克隆及数据传递：
render() { return React.Children.map(this.props.children, child => React.cloneElement(child, { on: this.state.on, toggle: this.toggle, }), ) } 这样，即使我们在使用 Switcher.React 和 Switcher.Vue 时，没有显式地传递参数，子组件也能获取数据。
这里 React.Children.map 与 this.props.children.map 并不等价，后者在只有一个子组件的时候，返回的不是数组，而是唯一的那个组件。
React.Children.map 的局限性 上面代码有个问题是，如果出现了更多层级的子组件，那么参数传递只会到第一层。
&lt;Switcher selecting={this.props.selecting}> &lt;Switcher.React/> &lt;div> &lt;Switcher.Vue/> &lt;/div> &lt;/Switcher> 这样写会提示传递了错误的参数给 div，因为我们 React.Children.map 只能获取到第一层子组件（[Switcher.React, div]）。
...</p></div><footer class=entry-footer><span title='2019-08-12 00:00:00 +0000 UTC'>August 12, 2019</span></footer><a class=entry-link aria-label="post link to React 进阶模式之复合组件（Compound Component）" href=https://joeytat.github.io/posts/compound-component/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>翻译 - 图像优化</h2></header><div class=entry-content><p>翻译自 Optimizing Images by Jordan Morgan
有句话说：最好的照相机就是在你身边的那台。 如果这句俗语是对的，那么毫无疑问地— iPhone 是这个星球上最重要的相机， 并且我们的业界也证明了这一点。
在度假中? 如果没有在你的 Instagram Story 中留下几张照片，那就不算发生过。
爆炸新闻? 立刻打开 Twitter 来查看哪些媒体在通过照片实时报道事件。
等等。
由于图像在各个平台无处不在的出现，在低性能且内存紧张的情况下展示它们，会很容易地造成失控。 如果我们知道 UIKit 底层到底发生了什么，为什么以及如何处理图像，那么我们可以节省大量的资源开销，并且逃脱无情的系统清除制裁。
理论上来说 突击测验 - 这张我女儿的 266 KB 字节大小（并且还蛮时尚的）的照片，在一个 iOS App 中会展示需要用到多少内存?
剧透一下 - 不是 266 KB，也不是 2.66 MB，而是大概 14 MB。
为什么?
本质上来说 iOS 申请内存是根据图像的尺寸 - 而图像的文件大小反而影响不大。 这张图片的尺寸是 1718 x 2048 像素。 假设每个像素会占用 4 个字节:
1718 * 2048 * 4 / 1024 / 1024 = 13.42 MB 大约
...</p></div><footer class=entry-footer><span title='2019-06-19 00:00:00 +0000 UTC'>June 19, 2019</span></footer><a class=entry-link aria-label="post link to 翻译 - 图像优化" href=https://joeytat.github.io/posts/optimizing_images/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Platforms State of the Union(WWDC 2019)</h2></header><div class=entry-content><p>SwiftUI 在 View 层级提供了四种特性:
Declarative 通过声明式的语句来描述 UI 布局, 样式, 动画等.
Automatic 可交互形动画, 动态字号, 夜间模式都可以通过配置来轻松实现.
Compositional 组合性. 各种控件都能极其方便地组合在一起, 远比 UIStackView 方便.
VStack(alignment: .leading) { Text(item.title) Text(item.subtitle) } Consistent 自带 Reactive 特性. 将 Model 对象继承自 BindableObject, 并且声明属性为 @State 即可获得当属性改变时, UI 控件自动更新的效果.
真的如果如此美好, 超级吃性能的 xib 和 storyboard 是不是可以退出舞台了.
Xcode 11 Live Development 直接在 Xcode Preview 中拖动控件即可生成对应的 SwiftUI 代码. 对应的修改 SwiftUI 代码也能实时在 Preview 中响应.
Preview 还能通过提供一个 PreviewProvider 来为其提供数据填充展示, 样式更改甚至循环语句来生成多个 Preview 同时查看控件在夜间模式和白日模式下不同的效果.
Preview 部署在设备上也能热加载.
Package Management Swift 终于有自己的 Package manage 了. 并且和 Xcode 进行了深度整合.
...</p></div><footer class=entry-footer><span title='2019-06-05 00:00:00 +0000 UTC'>June 5, 2019</span></footer><a class=entry-link aria-label="post link to Platforms State of the Union(WWDC 2019)" href=https://joeytat.github.io/posts/wwdc2019_platforms_state_of_the_union/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>如何实现 JavaScript 函数参数必填的支持?</h2></header><div class=entry-content><p>JS 在 ES6 的中新增了函数参数指定默认值的支持:
const Greeting = (name="Joeytat") => { console.log(`Hello ${name}`) } Greeting() // Hello Joeytat 那我们就可以利用这一特性, 将一个会抛出异常的方法作为默认参数传递.
const Greeting = (name=EmptyPropertyException("name")) => { console.log(`Hello ${name}`) } const EmptyPropertyException = (propertyName) => { throw Error(`${propertyName} 为必填参数`) } Greeting() // 抛出异常: "Error: name 为必填参数" 这样如果没有传递参数就会抛出异常, 并且带有友好的提示了.</p></div><footer class=entry-footer><span title='2019-06-03 00:00:00 +0000 UTC'>June 3, 2019</span></footer><a class=entry-link aria-label="post link to 如何实现 JavaScript 函数参数必填的支持?" href=https://joeytat.github.io/posts/js_required_property/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>2018</h2></header><div class=entry-content><p>刚毕业那阵儿还每年都写好长的总结, 然后这两年变懒了. 今年又想再记录一下了嘿 | ᐕ)⁾⁾
年度 App: 多邻国
零基础学语言的感觉很不错.
年度电影: 《三块广告牌》
年度漫画: 《只有我不存在的城市》
忘了在哪被人推荐的了, 被安利到的话大概是这么说的「非常庆幸在没有被剧透的情况下一口气看完了」. 看完了之后感觉果然如此. 而且漫画真是存在着动画无法表现出的节奏感啊.
年度游戏: 《神界原罪 2》
接触的第一款 CRPG, 有趣到什么程度呢? 从游戏体验时发出「wow, 居然还能这样?」的频率来看, 和《塞尔达: 旷野之息》差不多吧.
年度虚构类图书: 《剑来》
不知道为啥现在提起网络文学, 多数时候对方都还是觉得「格」不够. 可现在的网络小说与《明报》连载的武侠小说, 有多大的区别?
年度非虚构类图书: 《邻人之妻》
我姓王和我看这本书没有任何联系(认真脸), 真的是好奇性美国解放运动到底是怎么产生的而看的.
年度电器: Sony 9000E 电视
大屏幕 4k HDR 的全新体验让我想把之前在显示器上玩的好游戏看的好电影都重新来一次.
年度音乐: 《生きていたんだよな(她曾活过啊)》
歌词很棒? 看到年度音乐四个字, 脑子里第一首出现的歌.
年度视频: 井越的 vlog——《别再问我什么是 2017》
看了几十个 Casey Neistat 的 vlog 也没能让自己行动起来用视频记录生活. 但看完这个视频的第二天, 就开始尝试着在大街上对着手机镜头说话啦.
年度电子产品: iPhoneX
用来拍了不少视频, 照片. 人像模式拍出的照片, 会让我这个摄影门外汉产生一种「自己拍的还不错嘛」的错觉, 从而达到了要经常掏出手机记录生活的目标.
希望明年也能多创造一些东西, 能够在 19 年的年终总结中, 选出自己满意的年度 XXX 吧</p></div><footer class=entry-footer><span title='2018-12-28 00:00:00 +0000 UTC'>December 28, 2018</span></footer><a class=entry-link aria-label="post link to 2018" href=https://joeytat.github.io/posts/2018_overview/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>为什么 Cocoapods 1.5 支持编译静态库之后大家这么高兴?</h2></header><div class=entry-content><p>昨天在 Twitter 上看到 TualatriX 说把私有库都通过 Cocoapods 编译成静态库之后很爽, 就有点好奇到底是爽在哪里.
于是去搜了一下, 原来是前段时间(大半年前吧…), Cocoapods 发布了 1.5 的 release note, 宣布支持 Swift 静态库编译. 并且文中提到了对于担心动态二进制文件影响应用启动速度的人来说, 这是个了不起的更新. jh 那又是为什么 App 使用静态库会比动态库有更快的启动速度呢? 又跑去搜了一下官方文档. 打开 Dynamic Library Programming Topics 开头就看到:
This article introduces dynamic libraries and shows how using dynamic libraries instead of static libraries reduces both the file size and initial memory footprint of the apps that use them.
这篇文章主要介绍了动态库, 并且展示了通过使用动态库而不是静态库, 是如何缩减了应用的大小和初始内存空间的.
┻━┻ (ヽ(`Д ́)ノ( ┻━┻ 这和说好的不一样啊?
带着疑问我又跑去看了一下苹果的 WWDC 2016 - Optimizing App Startup Time 的视频, 这次问题终于得到了解决.
...</p></div><footer class=entry-footer><span title='2018-12-27 00:00:00 +0000 UTC'>December 27, 2018</span></footer><a class=entry-link aria-label="post link to 为什么 Cocoapods 1.5 支持编译静态库之后大家这么高兴?" href=https://joeytat.github.io/posts/cocoapods-1.5-static-library/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://joeytat.github.io/page/3/>«&nbsp;Prev&nbsp;</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://joeytat.github.io/>Joeytat's Dev Log</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>