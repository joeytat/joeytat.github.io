<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>SwiftUI on Dev Log</title>
    
    
    
    <link>http://localhost:1313/tags/swiftui/</link>
    <description>Recent content in SwiftUI on Dev Log</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 02 Jun 2023 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="http://localhost:1313/tags/swiftui/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>构建易维护的 Design System: 为什么 SwiftUI 会是更好的选择</title>
      <link>http://localhost:1313/posts/why-swiftui-is-better-at-building-a-design-system/</link>
      <pubDate>Fri, 02 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/posts/why-swiftui-is-better-at-building-a-design-system/</guid>
      <description>
        
          
          
          
        
        
        &lt;p&gt;&lt;code&gt;SwiftUI&lt;/code&gt; 自 iOS 13 发布以来，虽然已经面向公众近 4 年，但由于在实现复杂布局时的性能不佳，以及因其内置组件的底层实现变更（iOS 16 上 &lt;code&gt;List&lt;/code&gt; 的底层实现从 &lt;code&gt;UITableView&lt;/code&gt; 改成了 &lt;code&gt;UICollectionView&lt;/code&gt; ），导致开发者们原本良好运行代码随系统升级被破坏了。iOS 14 之前 SwiftUI 的开发者体验也让人一言难尽。尽管有很多的槽点，但我们还是能发现社区整体上还是比较接纳 SwiftUI。所以如果你对 SwiftUI 还有所犹豫，不清楚为何要使用它，这篇文章或许能够带来一些新的想法。&lt;/p&gt;
&lt;p&gt;本篇文章主要是想要通过 Design System 为切入点，同大家讨论相比起 UIKit，为什么更推荐使用 SwiftUI 来实现大多数业务场景下的 UI 组件。&lt;/p&gt;
&lt;p&gt;首先简单概括一下 Design System 是什么，Design System 是一个包含了设计原则、组件库和代码资源等系统化的指导，旨在促进团队间的协作和提高项目的一致性。它可以帮助团队更快速、高效地构建应用程序，同时确保应用程序的外观和交互保持一致。&lt;/p&gt;
&lt;p&gt;接下来就进入正题，从以下几点来探讨一下通过 SwiftUI 构建 Design System 有哪些优势。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;声明式语法会更具有可读性和易于实现&lt;/li&gt;
&lt;li&gt;内建的一致性和统一性表达&lt;/li&gt;
&lt;li&gt;单向数据流带来的可预测性&lt;/li&gt;
&lt;li&gt;与 Design System 有更相似的哲学思想&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;声明式语法会更具有可读性和易于实现&#34;&gt;
  声明式语法会更具有可读性和易于实现
  &lt;a href=&#34;#%e5%a3%b0%e6%98%8e%e5%bc%8f%e8%af%ad%e6%b3%95%e4%bc%9a%e6%9b%b4%e5%85%b7%e6%9c%89%e5%8f%af%e8%af%bb%e6%80%a7%e5%92%8c%e6%98%93%e4%ba%8e%e5%ae%9e%e7%8e%b0&#34; class=&#34;h-anchor&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;首先从实现和维护成本上来说，SwiftUI 与 Apple 现有的 UIKit 和 AppKit 不同，SwiftUI 采用了声明式语法构建 UI。由于声明式语法更关注于描述 UI 的最终效果，而不是具体实现方式。这使得通过声明式语法编写的 UI 组件更具可读性，有助于团队更好地协作实现 Design System。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-swift&#34; data-lang=&#34;swift&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// SwiftUI&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;VStack(spacing: &lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Text(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Hello&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        .font(.largeTitle)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Text(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;World&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        .font(.largeTitle)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.foregroundColor(.blue)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// UIKit&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; stackView = UIStackView()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;stackView.axis = .vertical
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;stackView.spacing = &lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; helloLabel = UILabel()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;helloLabel.text = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Hello&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;helloLabel.font = UIFont.systemFont(ofSize: &lt;span style=&#34;color:#ae81ff&#34;&gt;34&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;stackView.addArrangedSubview(helloLabel)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; worldLabel = UILabel()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;worldLabel.text = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;World&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;worldLabel.font = UIFont.systemFont(ofSize: &lt;span style=&#34;color:#ae81ff&#34;&gt;34&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;stackView.addArrangedSubview(worldLabel)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;stackView.backgroundColor = .blue
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;除了代码数量上的差距，我们还可以在 SwiftUI 示例中通过代码结构就直观地感受到 UI 组件是如何被排列的。&lt;/p&gt;
&lt;h2 id=&#34;内建的一致性和统一性表达&#34;&gt;
  内建的一致性和统一性表达
  &lt;a href=&#34;#%e5%86%85%e5%bb%ba%e7%9a%84%e4%b8%80%e8%87%b4%e6%80%a7%e5%92%8c%e7%bb%9f%e4%b8%80%e6%80%a7%e8%a1%a8%e8%be%be&#34; class=&#34;h-anchor&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;在 SwiftUI 中，我们可以通过 &lt;code&gt;View Modifier&lt;/code&gt; 来实现对 UI 组件的统一性表达。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-swift&#34; data-lang=&#34;swift&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// SwiftUI&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Button(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Primary&amp;#34;&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// action&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.buttonStyle(PrimaryButtonStyle())
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Button(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Secondary&amp;#34;&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// action&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.buttonStyle(SecondaryButtonStyle()) &lt;span style=&#34;color:#75715e&#34;&gt;// 当 Primary， 或 Secondary style 发生变化时，所有使用了这两个 style 的按钮都会被自动更新&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// UIKit&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; primaryButton = UIButton()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;primaryButton.setTitle(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Primary&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;: .normal)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;primaryButton.titleLabel?.font = UIFont.systemFont(ofSize: &lt;span style=&#34;color:#ae81ff&#34;&gt;16&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;primaryButton.backgroundColor = UIColor.blue
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;primaryButton.layer.cornerRadius = &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; secondaryButton = UIButton()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;secondaryButton.setTitle(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Secondary&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;: .normal)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;secondaryButton.titleLabel?.font = UIFont.systemFont(ofSize: &lt;span style=&#34;color:#ae81ff&#34;&gt;16&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;secondaryButton.backgroundColor = UIColor.gray
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;secondaryButton.layer.cornerRadius = &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;通过代码我们可以看到 SwiftUI 预定义的设计规范，使开发者更易于表达和保证 Design System 的统一性。&lt;/p&gt;
&lt;p&gt;虽然开发者也可以对 UIKit 的 UI 组件进行封装，实现类似 SwiftUI View Modifier 的效果。但是 SwiftUI 的 View Modifier 是内在耦合的，会天然具有更好的一致性。而对 UIKit 进行二次封装，仍需依赖于开发者自觉遵循设计规范，难免会产生疏忽的情况，影响最终 UI 的一致性。&lt;/p&gt;
&lt;h2 id=&#34;单向数据流带来的可预测性&#34;&gt;
  单向数据流带来的可预测性
  &lt;a href=&#34;#%e5%8d%95%e5%90%91%e6%95%b0%e6%8d%ae%e6%b5%81%e5%b8%a6%e6%9d%a5%e7%9a%84%e5%8f%af%e9%a2%84%e6%b5%8b%e6%80%a7&#34; class=&#34;h-anchor&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;SwiftUI 所编写的 UI 组件更具有可预测性。体现在其遵循单向数据流原则，这样可以减少因为状态管理复杂性导致的 UI 错误。同时 UI 组件的样式是通过高阶函数或组合来创建的，而不是通过副作用或隐式规则创建，这使得开发者更容易识别组件会具备哪些样式及其来源。&lt;/p&gt;
&lt;p&gt;相比之下 UIKit 作为命令式 UI 框架，其 UI 渲染过程则相对复杂和难以预测。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;状态变化会导致难以跟踪的副作用，这使 UI 更易出错且难以调试。&lt;/li&gt;
&lt;li&gt;样式规则由开发者自行定义并应用，存在较大随意性，阅读和理解起来也更加困难。&lt;/li&gt;
&lt;li&gt;样式的来源和应用不像 SwiftUI 那样清晰，需要开发者自行理清各个样式规则之间的关系，以确保 UI 的正确性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;更相似的哲学思想&#34;&gt;
  更相似的哲学思想
  &lt;a href=&#34;#%e6%9b%b4%e7%9b%b8%e4%bc%bc%e7%9a%84%e5%93%b2%e5%ad%a6%e6%80%9d%e6%83%b3&#34; class=&#34;h-anchor&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;SwiftUI 中组合和函数式的思想与 Design System 中原子组件和组合的原则相吻合。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;两者都倾向于构建出小的、自洽的单位，然后通过组合来创建更为复杂的结构，SwiftUI 中的视图和 Modifier 就是这种单位和组合的体现。&lt;/li&gt;
&lt;li&gt;组件和函数都是可以是通用的或定制的，同时可以将其重复使用或组合。在 SwiftUI 中，我们可以构建出通用的 Modifier 和视图，也可以为某一具体视图定制特有的 Modifier。&lt;/li&gt;
&lt;li&gt;当改变基础单位(如字号，间距等基础单位)会以可控方式影响所有组合。如果我们改变一个 Modifier 的行为或属性，所有应用该 Modifier 的视图将会相应改变。这使得在设计系统中调整细节时，更易预测和控制其影响范围。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而相比之下，UIKit 作为命令式框架，其 UI 构建方式则相对零散和随意:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;构建 UI 时，开发者自行决定组装哪些控件和设置何种属性，难以遵循统一的组合规则。&lt;/li&gt;
&lt;li&gt;没有类似 Modifier 的机制，每个视图的样式都需要单独设置，无法在多处重复使用。这使得调整样式时，需要逐个修改每个视图，难以高效地应用设计变化。&lt;/li&gt;
&lt;li&gt;属性的变化并不一定会影响所有相关视图，需要开发者自己再逐个对应用的视图做出修改。这加大了设计系统维护的难度。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;最后&#34;&gt;
  最后
  &lt;a href=&#34;#%e6%9c%80%e5%90%8e&#34; class=&#34;h-anchor&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;还需要说明的是，本文只是想探讨在实现移动平台的 Design System 时相比起 UIKit，SwiftUI 所具有的一定优势。&lt;/p&gt;
&lt;p&gt;在某些复杂的场景下，UIKit 这样命令式的 UI 框架的灵活性和性能可能会更强。所以需要注意的是，SwiftUI 的组件状态和行为都是由数据驱动，这可能会导致性能问题，如大量的数据绑定和更新可能会引起 UI 界面的卡顿和延迟。相比之下，UIKit 接近底层渲染机制，性能表现可能更佳。但 SwiftUI 也有实现跨平台需求的优势。&lt;/p&gt;
&lt;p&gt;在选择具体哪个框架实现 Design System 时，开发者还是得根据具体需求，权衡两者之间的优缺点。在追求性能或需要高度定制化的场景下，UIKit 的灵活性和性能表现可能更占优。但在大多数情况下，SwiftUI 的声明式语法和组合特性，使其天然更适合构建统一且易维护的 Design System。&lt;/p&gt;

        
        </description>
    </item>
    
    <item>
      <title>参加 Apple 开发者线上活动是什么样的体验？</title>
      <link>http://localhost:1313/posts/apple_swiftui_workshop/</link>
      <pubDate>Mon, 28 Mar 2022 00:00:35 +0000</pubDate>
      
      <guid>http://localhost:1313/posts/apple_swiftui_workshop/</guid>
      <description>
        
          
          
          
        
        
        &lt;p&gt;从朋友圈看到思琦发了一个《使用 SwiftUI 打造卓越体验》的 Apple 开发者线上活动的报名链接，刚好最近参与的项目也在大规模使用 SwiftUI 就报名了，即使时间很不凑巧是工作日（另一报名要求是必须要有中国区的开发者账号）。&lt;/p&gt;
&lt;p&gt;活动分两天第一天主要是一些 SwiftUI 的介绍，SwiftUI 对数据的处理和布局的一些要点。第二天是社区开发者交流。&lt;/p&gt;
&lt;p&gt;技术细节后面可以分好几篇博客来描述，但总的来说技术相关的收获其实和自己去看 WWDC 差不多。并且由于长期以 2x 速度观看这类视频，刚开始还出现了一些不适应。但想着这是来自苹果的开发者的分享，还是管住了想拿起手机的手，毕竟机会难得。&lt;/p&gt;
&lt;p&gt;事实证明确实认真观看还是有收获，主要是以下几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;知道了一些 SwiftUI 相关的 Xcode 快捷操作，比如 Preview 和代码其实是可以相互影响的。Library 中可以搜索 &lt;code&gt;ViewModifier&lt;/code&gt; 等等。&lt;/li&gt;
&lt;li&gt;来自苹果的工程师对 SwiftUI 这样响应式 UI 编写方式的数据流思考的建议。&lt;/li&gt;
&lt;li&gt;一些编写 SwiftUI 代码时能够让渲染引擎更高效的建议。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除了上面开发者分享的内容之外，最重要的是可以提出一些自己在使用 SwiftUI 时遇到的问题，感觉只要描述得够清楚并且和本次活动主题相关，那么都能够得到苹果开发者的解答，虽然受形式或时间限制，答案并不一定完整，但当一个 SwiftUI 的疑问是由苹果的工程师解答时，即使只是关键字的指引也能起到画龙点睛的作用（比如 &lt;code&gt;StateObject&lt;/code&gt; 与 &lt;code&gt;ObservedObject&lt;/code&gt; 的差异）。&lt;/p&gt;
&lt;p&gt;第二天更多的是听社区开发者的一些交流，收获到了不少之前并不知道的资料。一并列在下方。&lt;/p&gt;
&lt;p&gt;ps：感觉参加这次活动对自己来说还有一个副作用就是，由于资料的推荐者有足够的可信度，并且提供了一个可靠的学习路线，所以会用格外的认真来对待它们。&lt;/p&gt;
&lt;p&gt;Swift UI 的入门指引&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.apple.com/videos/play/wwdc2020/10119/&#34;&gt;WWDC - Introduction to SwiftUI&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.apple.com/videos/play/wwdc2019/216/&#34;&gt;WWDC - SwiftUI Essentials&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.apple.com/tutorials/sample-apps&#34;&gt;十个很有代表性的 Playground&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.apple.com/tutorials/swiftui&#34;&gt;交互式的 SwiftUI 入门教程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.apple.com/tutorials/app-dev-training&#34;&gt;使用 SwiftUI 构建完整 App 的交互式教程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;SwiftUI 数据处理要素&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.apple.com/videos/play/wwdc2020/10040/&#34;&gt;WWDC - Data Essentials in SwiftUI&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.apple.com/videos/play/wwdc2021/10022&#34;&gt;WWDC - Demystify SwiftUI&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.apple.com/documentation/SwiftUI/State-and-Data-Flow&#34;&gt;状态与数据流&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.apple.com/documentation/swiftui/managing-model-data-in-your-app&#34;&gt;如何管理 App 中的模型数据&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.apple.com/documentation/swiftui/managing-user-interface-state&#34;&gt;如何管理 UI 状态&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;SwiftUI 布局和渲染&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.apple.com/videos/play/wwdc2021/10018/&#34;&gt;WWDC - What&amp;rsquo;s new in SwiftUI&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.apple.com/videos/play/wwdc2020/10031/&#34;&gt;WWDC - Stacks, Grids, and Outlines in SwiftUI&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.apple.com/videos/play/wwdc2021/10021/&#34;&gt;WWDC - Add rich graphics to your SwiftUI app&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.apple.com/videos/play/wwdc2019/237/&#34;&gt;WWDC - Building Custom Views with SwiftUI&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.apple.com/documentation/swiftui/layout-containers&#34;&gt;布局容器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.apple.com/documentation/swiftui/collection-containers&#34;&gt;集合布局容器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.apple.com/documentation/swiftui/drawing-and-graphics&#34;&gt;图像与绘制&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用 SwiftUI 打造 watchOS app&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.apple.com/videos/play/wwdc2019/219/&#34;&gt;WWDC - SwiftUI on watchOS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.apple.com/videos/play/wwdc2020/10048/&#34;&gt;WWDC - Build complications in SwiftUI&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.apple.com/documentation/example-articles/building_a_watchos_app&#34;&gt;打造 watchOS App&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.apple.com/documentation/watchosapps/developing_a_user_interface_with_swiftui&#34;&gt;如何利用 SwiftUI 以及手表特定功能打造复杂 app 的代码示例&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;社区开发者提及&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.apple.com/documentation/docc#Overview&#34;&gt;文档生成工具 - DocC&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://swiftui-lab.com/random-lessons/&#34;&gt;WWDC Digital Lounges 中的开发者问答整理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://swiftui-lab.com/companion/&#34;&gt;SwiftUI Companion - 交互式 SwiftUI API 文档工具&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

        
        </description>
    </item>
    
    <item>
      <title>SwiftUI 状态管理 —— Composible Binding</title>
      <link>http://localhost:1313/posts/composible_binding/</link>
      <pubDate>Mon, 03 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/posts/composible_binding/</guid>
      <description>
        
          
          
          
        
        
        &lt;p&gt;在 SwiftUI 中，需要通过数据来驱动 UI 的变化。数据结构抽象描述的质量也影响着我们对 SwiftUI 界面的维护。&lt;/p&gt;
&lt;p&gt;通常数据中可能存在很多状态，如果使用很多的 boolean 值来描述这些状态，那么 App 的可维护性可能会大大降低。&lt;/p&gt;
&lt;h2 id=&#34;管理独立状态的问题&#34;&gt;
  管理独立状态的问题
  &lt;a href=&#34;#%e7%ae%a1%e7%90%86%e7%8b%ac%e7%ab%8b%e7%8a%b6%e6%80%81%e7%9a%84%e9%97%ae%e9%a2%98&#34; class=&#34;h-anchor&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;假设我们有一个 App，用户可以在登录与非登录状态下进行操作。所以我们的界面需要兼容这两种状态，其描述可能是这样的：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-swift&#34; data-lang=&#34;swift&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;AppState&lt;/span&gt;: ObservableObject {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  @Published &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; user: User? = &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  @Published &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; error: Error? = &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; authenticated: Bool { user &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; hasError: Bool { error &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;基于这样的状态描述，如果我们想创建一个仅展示用户名的组件大概会是这样：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-swift&#34; data-lang=&#34;swift&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; body: some View {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Group {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; state.hasError {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Text(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Oops, sth went wrong: &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;\(&lt;/span&gt;state.error!.localizedDescription&lt;span style=&#34;color:#e6db74&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; state.authenticated {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Text(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Hello &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;\(&lt;/span&gt;state.user?.name ?? &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Unknown&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;!&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Text(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Hello, stranger&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;粗看没有什么问题，实际上在维护这样的数据结构时就需要格外小心了。比如第一次我们登录失败，为了展示错误信息给 &lt;code&gt;error&lt;/code&gt; 设置了值之后。必须在登录成功之后要及时地去清空 error，否则即使 &lt;code&gt;state.authenticated&lt;/code&gt; 等于 &lt;code&gt;true&lt;/code&gt;，用户依然无法看到正确的信息。&lt;/p&gt;
&lt;p&gt;这还仅仅是有两个状态的情况下，像这样独立状态属性会带来很大的维护成本，开发者需要牢记各个属性之间的依赖关系，甚至编写界面的时候，还需要注意代码执行顺序。&lt;/p&gt;
&lt;h2 id=&#34;引入状态机&#34;&gt;
  引入状态机
  &lt;a href=&#34;#%e5%bc%95%e5%85%a5%e7%8a%b6%e6%80%81%e6%9c%ba&#34; class=&#34;h-anchor&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;把状态抽象成带有 associated values 的 enum 是个更好的选择，比如:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-swift&#34; data-lang=&#34;swift&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;AppState&lt;/span&gt;: ObservableObject  {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;enum&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;AccountState&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;case&lt;/span&gt; authenticated(User)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;case&lt;/span&gt; unauthenticated
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;case&lt;/span&gt; error(Error)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  @Published &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; accountState: AccountState = .unauthenticated
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 界面中的使用&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; body: some View {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  VStack {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;switch&lt;/span&gt; state.accountState {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;case&lt;/span&gt; .authenticated(&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; user):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      Text(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Hello &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;\(&lt;/span&gt;user.name&lt;span style=&#34;color:#e6db74&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;!&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;case&lt;/span&gt; .unauthenticated:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      Text(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;unregister&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;case&lt;/span&gt; .error(&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; error):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      Text(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Oops, sth went wrong: &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;\(&lt;/span&gt;error.localizedDescription&lt;span style=&#34;color:#e6db74&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样被状态机驱动的界面看起来要直观多了。并且在每个状态中对数据的操作，也由 enum 赋予了隔离能力。&lt;/p&gt;
&lt;h2 id=&#34;双向绑定怎么办&#34;&gt;
  双向绑定怎么办？
  &lt;a href=&#34;#%e5%8f%8c%e5%90%91%e7%bb%91%e5%ae%9a%e6%80%8e%e4%b9%88%e5%8a%9e&#34; class=&#34;h-anchor&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;但这样做又来带个新的问题，现在没办法直接通过 &lt;code&gt;$&lt;/code&gt; 来获取 Binding wrapper 来修改状态：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-swift&#34; data-lang=&#34;swift&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;switch&lt;/span&gt; state.accountState {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;case&lt;/span&gt; .authenticated(&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; user):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      Text(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Hello &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;\(&lt;/span&gt;user.name&lt;span style=&#34;color:#e6db74&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;!&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	  TextField(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Change username&amp;#34;&lt;/span&gt;, text: &amp;lt;Binding&amp;lt;String&amp;gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;) 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#75715e&#34;&gt;// 不支持填入 self.$state.accountState.name 👆&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;Xcode 会提示: dynamic member &amp;rsquo;name&amp;rsquo; using key path from root type &amp;lsquo;AppState.AccountState&amp;rsquo;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为什么当操作对象是 class 时，是可以做到通过
&lt;code&gt;self.$state.user.name&lt;/code&gt; 来获取到 name 属性的 Binding 封装的？&lt;/p&gt;
&lt;h2 id=&#34;实现动态成员查找dynamic-member-lookup&#34;&gt;
  实现动态成员查找(dynamic member lookup)
  &lt;a href=&#34;#%e5%ae%9e%e7%8e%b0%e5%8a%a8%e6%80%81%e6%88%90%e5%91%98%e6%9f%a5%e6%89%bedynamic-member-lookup&#34; class=&#34;h-anchor&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;因为 Enum 还不支持动态成员查找特性。什么是动态成员查找？简而言之就是通过  &lt;code&gt;\&lt;/code&gt; 来获取到成员属性的 &lt;code&gt;KeyPath&lt;/code&gt; 封装（&lt;a href=&#34;https://www.swiftbysundell.com/articles/the-power-of-key-paths-in-swift/&#34;&gt;什么又是 KeyPath&lt;/a&gt;？），然后将其转化为对应的 Binding 封装。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-swift&#34; data-lang=&#34;swift&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;extension&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Binding&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;transform&lt;/span&gt;&amp;lt;LocalValue&amp;gt;(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;_&lt;/span&gt; keyPath: WritableKeyPath&amp;lt;Value, LocalValue&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ) -&amp;gt; Binding&amp;lt;LocalValue&amp;gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Binding&amp;lt;LocalValue&amp;gt;(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#66d9ef&#34;&gt;get&lt;/span&gt;: { 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;self&lt;/span&gt;.wrappedValue[keyPath: keyPath]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      },
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#66d9ef&#34;&gt;set&lt;/span&gt;: { localValue &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;self&lt;/span&gt;.wrappedValue[keyPath: keyPath] = localValue 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    )
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;self&lt;/span&gt;.&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;$&lt;/span&gt;state.accountState.username
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 等价于 &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;self&lt;/span&gt;.&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;$&lt;/span&gt;state.transform(&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;\&lt;/span&gt;accountState).transform(&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;\&lt;/span&gt;username)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;所以接下来只需要为 enum 添加动态成员查找的支持就可以了&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-swift&#34; data-lang=&#34;swift&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;extension&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Binding&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;unwrap&lt;/span&gt;&amp;lt;Wrapped&amp;gt;() -&amp;gt; Binding&amp;lt;Wrapped&amp;gt;? &lt;span style=&#34;color:#66d9ef&#34;&gt;where&lt;/span&gt; Value == Wrapped? {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;guard&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; value = &lt;span style=&#34;color:#66d9ef&#34;&gt;self&lt;/span&gt;.wrappedValue &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; { &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; Binding&amp;lt;Wrapped&amp;gt;(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#66d9ef&#34;&gt;get&lt;/span&gt;: { value },
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#66d9ef&#34;&gt;set&lt;/span&gt;: { &lt;span style=&#34;color:#66d9ef&#34;&gt;self&lt;/span&gt;.wrappedValue = $0 }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    )
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后再到 enum 里添加一个计算属性方便我们获取&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-swift&#34; data-lang=&#34;swift&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;enum&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;AccountState&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;case&lt;/span&gt; loggedIn(User)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;case&lt;/span&gt; unregister
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;//&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; username: String? {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;get&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#66d9ef&#34;&gt;guard&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;case&lt;/span&gt; .loggedIn(&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; user) = &lt;span style=&#34;color:#66d9ef&#34;&gt;self&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; user.username
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;set&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#66d9ef&#34;&gt;guard&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;case&lt;/span&gt; .loggedIn(&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; user) = &lt;span style=&#34;color:#66d9ef&#34;&gt;self&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; newValue = newValue &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; { &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      user.username = newValue
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#66d9ef&#34;&gt;self&lt;/span&gt; = .loggedIn(user)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;现在就可以在 SwiftUI 中对 enum 使用绑定了&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-swift&#34; data-lang=&#34;swift&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; username = &lt;span style=&#34;color:#66d9ef&#34;&gt;self&lt;/span&gt;.&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;$&lt;/span&gt;state.accountState.username.unwrap() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  TextField(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Change username&amp;#34;&lt;/span&gt;, text: username)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;看起来还是有些麻烦，对于每个要使用 Binding 的属性都需要去写一个计算属性来包装一层。这样显然这并不如 &lt;code&gt;KeyPath&lt;/code&gt; 那样，直接通过 &lt;code&gt;self.$state.accountState[\.authenticated]&lt;/code&gt; 来获取到 enum 中 associated value 的 Binding 包装来得方便。&lt;/p&gt;
&lt;p&gt;虽然 Swift 目前不支持，但我们还是可以通过引入 &lt;a href=&#34;https://github.com/pointfreeco/swift-case-paths&#34;&gt;CasePaths&lt;/a&gt; 这个第三方依赖来实现。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-swift&#34; data-lang=&#34;swift&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;CasePaths&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;enum&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;AccountState&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;case&lt;/span&gt; authenticated(User)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;case&lt;/span&gt; unauthenticated
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;case&lt;/span&gt; error(Error)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 计算属性可以删除掉了&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//    var username: String? {&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//      get {&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//        guard case .authenticated(let user) = self else {&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//          return nil&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//        }&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//        return user.name&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//      }&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//      set {&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//        guard case .authenticated(let user) = self,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//              let newValue = newValue else { return }&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//        user.name = newValue&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//        self = .authenticated(user)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//      }&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//    }&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 界面中直接使用 CasePath&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; user = &lt;span style=&#34;color:#66d9ef&#34;&gt;self&lt;/span&gt;.&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;$&lt;/span&gt;state.accountState.matching(&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;.authenticated) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  TextField(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Change username&amp;#34;&lt;/span&gt;, text: user.name)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;由此为 Enum 也增加了与 Struct、Class 等效的 KeyPath 支持，从而使得文章开头用 Enum 作为 SwiftUI 的状态机管理工具更便捷了一些。&lt;/p&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;
  参考资料
  &lt;a href=&#34;#%e5%8f%82%e8%80%83%e8%b5%84%e6%96%99&#34; class=&#34;h-anchor&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://kentcdodds.com/blog/stop-using-isloading-booleans&#34;&gt;Stop using isLoading booleans&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.swiftbysundell.com/articles/the-power-of-key-paths-in-swift/&#34;&gt;The power of key paths in Swift&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.pointfree.co/collections/swiftui/composable-bindings/ep107-composable-swiftui-bindings-the-problem&#34;&gt;Composable SwiftUI Bindings: The Problem&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

        
        </description>
    </item>
    
  </channel>
</rss>