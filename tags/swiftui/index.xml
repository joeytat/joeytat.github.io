<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>SwiftUI on Dev Log</title><link>https://joeytat.github.io/tags/swiftui/</link><description>Recent content in SwiftUI on Dev Log</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 02 Jun 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://joeytat.github.io/tags/swiftui/index.xml" rel="self" type="application/rss+xml"/><item><title>构建易维护的 Design System: 为什么 SwiftUI 会是更好的选择</title><link>https://joeytat.github.io/posts/why-swiftui-is-better-at-building-a-design-system/</link><pubDate>Fri, 02 Jun 2023 00:00:00 +0000</pubDate><guid>https://joeytat.github.io/posts/why-swiftui-is-better-at-building-a-design-system/</guid><description>
&lt;p>&lt;code>SwiftUI&lt;/code> 自 iOS 13 发布以来，虽然已经面向公众近 4 年，但由于在实现复杂布局时的性能不佳，以及因其内置组件的底层实现变更（iOS 16 上 &lt;code>List&lt;/code> 的底层实现从 &lt;code>UITableView&lt;/code> 改成了 &lt;code>UICollectionView&lt;/code> ），导致开发者们原本良好运行代码随系统升级被破坏了。iOS 14 之前 SwiftUI 的开发者体验也让人一言难尽。尽管有很多的槽点，但我们还是能发现社区整体上还是比较接纳 SwiftUI。所以如果你对 SwiftUI 还有所犹豫，不清楚为何要使用它，这篇文章或许能够带来一些新的想法。&lt;/p>
&lt;p>本篇文章主要是想要通过 Design System 为切入点，同大家讨论相比起 UIKit，为什么更推荐使用 SwiftUI 来实现大多数业务场景下的 UI 组件。&lt;/p>
&lt;p>首先简单概括一下 Design System 是什么，Design System 是一个包含了设计原则、组件库和代码资源等系统化的指导，旨在促进团队间的协作和提高项目的一致性。它可以帮助团队更快速、高效地构建应用程序，同时确保应用程序的外观和交互保持一致。&lt;/p>
&lt;p>接下来就进入正题，从以下几点来探讨一下通过 SwiftUI 构建 Design System 有哪些优势。&lt;/p>
&lt;ul>
&lt;li>声明式语法会更具有可读性和易于实现&lt;/li>
&lt;li>内建的一致性和统一性表达&lt;/li>
&lt;li>单向数据流带来的可预测性&lt;/li>
&lt;li>与 Design System 有更相似的哲学思想&lt;/li>
&lt;/ul>
&lt;h2 id="声明式语法会更具有可读性和易于实现">
声明式语法会更具有可读性和易于实现
&lt;a href="#%e5%a3%b0%e6%98%8e%e5%bc%8f%e8%af%ad%e6%b3%95%e4%bc%9a%e6%9b%b4%e5%85%b7%e6%9c%89%e5%8f%af%e8%af%bb%e6%80%a7%e5%92%8c%e6%98%93%e4%ba%8e%e5%ae%9e%e7%8e%b0" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h2>
&lt;p>首先从实现和维护成本上来说，SwiftUI 与 Apple 现有的 UIKit 和 AppKit 不同，SwiftUI 采用了声明式语法构建 UI。由于声明式语法更关注于描述 UI 的最终效果，而不是具体实现方式。这使得通过声明式语法编写的 UI 组件更具可读性，有助于团队更好地协作实现 Design System。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// SwiftUI&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>VStack(spacing: &lt;span style="color:#ae81ff">20&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Text(&lt;span style="color:#e6db74">&amp;#34;Hello&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .font(.largeTitle)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Text(&lt;span style="color:#e6db74">&amp;#34;World&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .font(.largeTitle)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>.foregroundColor(.blue)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// UIKit&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> stackView = UIStackView()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>stackView.axis = .vertical
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>stackView.spacing = &lt;span style="color:#ae81ff">20&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> helloLabel = UILabel()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>helloLabel.text = &lt;span style="color:#e6db74">&amp;#34;Hello&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>helloLabel.font = UIFont.systemFont(ofSize: &lt;span style="color:#ae81ff">34&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>stackView.addArrangedSubview(helloLabel)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> worldLabel = UILabel()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>worldLabel.text = &lt;span style="color:#e6db74">&amp;#34;World&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>worldLabel.font = UIFont.systemFont(ofSize: &lt;span style="color:#ae81ff">34&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>stackView.addArrangedSubview(worldLabel)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>stackView.backgroundColor = .blue
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>除了代码数量上的差距，我们还可以在 SwiftUI 示例中通过代码结构就直观地感受到 UI 组件是如何被排列的。&lt;/p>
&lt;h2 id="内建的一致性和统一性表达">
内建的一致性和统一性表达
&lt;a href="#%e5%86%85%e5%bb%ba%e7%9a%84%e4%b8%80%e8%87%b4%e6%80%a7%e5%92%8c%e7%bb%9f%e4%b8%80%e6%80%a7%e8%a1%a8%e8%be%be" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h2>
&lt;p>在 SwiftUI 中，我们可以通过 &lt;code>View Modifier&lt;/code> 来实现对 UI 组件的统一性表达。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// SwiftUI&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Button(&lt;span style="color:#e6db74">&amp;#34;Primary&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// action&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>.buttonStyle(PrimaryButtonStyle())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Button(&lt;span style="color:#e6db74">&amp;#34;Secondary&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// action&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>.buttonStyle(SecondaryButtonStyle()) &lt;span style="color:#75715e">// 当 Primary， 或 Secondary style 发生变化时，所有使用了这两个 style 的按钮都会被自动更新&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// UIKit&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> primaryButton = UIButton()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>primaryButton.setTitle(&lt;span style="color:#e6db74">&amp;#34;Primary&amp;#34;&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">，&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span>: .normal)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>primaryButton.titleLabel?.font = UIFont.systemFont(ofSize: &lt;span style="color:#ae81ff">16&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>primaryButton.backgroundColor = UIColor.blue
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>primaryButton.layer.cornerRadius = &lt;span style="color:#ae81ff">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> secondaryButton = UIButton()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>secondaryButton.setTitle(&lt;span style="color:#e6db74">&amp;#34;Secondary&amp;#34;&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">，&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span>: .normal)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>secondaryButton.titleLabel?.font = UIFont.systemFont(ofSize: &lt;span style="color:#ae81ff">16&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>secondaryButton.backgroundColor = UIColor.gray
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>secondaryButton.layer.cornerRadius = &lt;span style="color:#ae81ff">5&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>通过代码我们可以看到 SwiftUI 预定义的设计规范，使开发者更易于表达和保证 Design System 的统一性。&lt;/p>
&lt;p>虽然开发者也可以对 UIKit 的 UI 组件进行封装，实现类似 SwiftUI View Modifier 的效果。但是 SwiftUI 的 View Modifier 是内在耦合的，会天然具有更好的一致性。而对 UIKit 进行二次封装，仍需依赖于开发者自觉遵循设计规范，难免会产生疏忽的情况，影响最终 UI 的一致性。&lt;/p>
&lt;h2 id="单向数据流带来的可预测性">
单向数据流带来的可预测性
&lt;a href="#%e5%8d%95%e5%90%91%e6%95%b0%e6%8d%ae%e6%b5%81%e5%b8%a6%e6%9d%a5%e7%9a%84%e5%8f%af%e9%a2%84%e6%b5%8b%e6%80%a7" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h2>
&lt;p>SwiftUI 所编写的 UI 组件更具有可预测性。体现在其遵循单向数据流原则，这样可以减少因为状态管理复杂性导致的 UI 错误。同时 UI 组件的样式是通过高阶函数或组合来创建的，而不是通过副作用或隐式规则创建，这使得开发者更容易识别组件会具备哪些样式及其来源。&lt;/p>
&lt;p>相比之下 UIKit 作为命令式 UI 框架，其 UI 渲染过程则相对复杂和难以预测。&lt;/p>
&lt;ul>
&lt;li>状态变化会导致难以跟踪的副作用，这使 UI 更易出错且难以调试。&lt;/li>
&lt;li>样式规则由开发者自行定义并应用，存在较大随意性，阅读和理解起来也更加困难。&lt;/li>
&lt;li>样式的来源和应用不像 SwiftUI 那样清晰，需要开发者自行理清各个样式规则之间的关系，以确保 UI 的正确性。&lt;/li>
&lt;/ul>
&lt;h2 id="更相似的哲学思想">
更相似的哲学思想
&lt;a href="#%e6%9b%b4%e7%9b%b8%e4%bc%bc%e7%9a%84%e5%93%b2%e5%ad%a6%e6%80%9d%e6%83%b3" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h2>
&lt;p>SwiftUI 中组合和函数式的思想与 Design System 中原子组件和组合的原则相吻合。&lt;/p>
&lt;ul>
&lt;li>两者都倾向于构建出小的、自洽的单位，然后通过组合来创建更为复杂的结构，SwiftUI 中的视图和 Modifier 就是这种单位和组合的体现。&lt;/li>
&lt;li>组件和函数都是可以是通用的或定制的，同时可以将其重复使用或组合。在 SwiftUI 中，我们可以构建出通用的 Modifier 和视图，也可以为某一具体视图定制特有的 Modifier。&lt;/li>
&lt;li>当改变基础单位(如字号，间距等基础单位)会以可控方式影响所有组合。如果我们改变一个 Modifier 的行为或属性，所有应用该 Modifier 的视图将会相应改变。这使得在设计系统中调整细节时，更易预测和控制其影响范围。&lt;/li>
&lt;/ul>
&lt;p>而相比之下，UIKit 作为命令式框架，其 UI 构建方式则相对零散和随意:&lt;/p>
&lt;ul>
&lt;li>构建 UI 时，开发者自行决定组装哪些控件和设置何种属性，难以遵循统一的组合规则。&lt;/li>
&lt;li>没有类似 Modifier 的机制，每个视图的样式都需要单独设置，无法在多处重复使用。这使得调整样式时，需要逐个修改每个视图，难以高效地应用设计变化。&lt;/li>
&lt;li>属性的变化并不一定会影响所有相关视图，需要开发者自己再逐个对应用的视图做出修改。这加大了设计系统维护的难度。&lt;/li>
&lt;/ul>
&lt;h2 id="最后">
最后
&lt;a href="#%e6%9c%80%e5%90%8e" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h2>
&lt;p>还需要说明的是，本文只是想探讨在实现移动平台的 Design System 时相比起 UIKit，SwiftUI 所具有的一定优势。&lt;/p>
&lt;p>在某些复杂的场景下，UIKit 这样命令式的 UI 框架的灵活性和性能可能会更强。所以需要注意的是，SwiftUI 的组件状态和行为都是由数据驱动，这可能会导致性能问题，如大量的数据绑定和更新可能会引起 UI 界面的卡顿和延迟。相比之下，UIKit 接近底层渲染机制，性能表现可能更佳。但 SwiftUI 也有实现跨平台需求的优势。&lt;/p>
&lt;p>在选择具体哪个框架实现 Design System 时，开发者还是得根据具体需求，权衡两者之间的优缺点。在追求性能或需要高度定制化的场景下，UIKit 的灵活性和性能表现可能更占优。但在大多数情况下，SwiftUI 的声明式语法和组合特性，使其天然更适合构建统一且易维护的 Design System。&lt;/p></description></item><item><title>参加 Apple 开发者线上活动是什么样的体验？</title><link>https://joeytat.github.io/posts/apple_swiftui_workshop/</link><pubDate>Mon, 28 Mar 2022 00:00:35 +0000</pubDate><guid>https://joeytat.github.io/posts/apple_swiftui_workshop/</guid><description>
&lt;p>从朋友圈看到思琦发了一个《使用 SwiftUI 打造卓越体验》的 Apple 开发者线上活动的报名链接，刚好最近参与的项目也在大规模使用 SwiftUI 就报名了，即使时间很不凑巧是工作日（另一报名要求是必须要有中国区的开发者账号）。&lt;/p>
&lt;p>活动分两天第一天主要是一些 SwiftUI 的介绍，SwiftUI 对数据的处理和布局的一些要点。第二天是社区开发者交流。&lt;/p>
&lt;p>技术细节后面可以分好几篇博客来描述，但总的来说技术相关的收获其实和自己去看 WWDC 差不多。并且由于长期以 2x 速度观看这类视频，刚开始还出现了一些不适应。但想着这是来自苹果的开发者的分享，还是管住了想拿起手机的手，毕竟机会难得。&lt;/p>
&lt;p>事实证明确实认真观看还是有收获，主要是以下几点：&lt;/p>
&lt;ul>
&lt;li>知道了一些 SwiftUI 相关的 Xcode 快捷操作，比如 Preview 和代码其实是可以相互影响的。Library 中可以搜索 &lt;code>ViewModifier&lt;/code> 等等。&lt;/li>
&lt;li>来自苹果的工程师对 SwiftUI 这样响应式 UI 编写方式的数据流思考的建议。&lt;/li>
&lt;li>一些编写 SwiftUI 代码时能够让渲染引擎更高效的建议。&lt;/li>
&lt;/ul>
&lt;p>除了上面开发者分享的内容之外，最重要的是可以提出一些自己在使用 SwiftUI 时遇到的问题，感觉只要描述得够清楚并且和本次活动主题相关，那么都能够得到苹果开发者的解答，虽然受形式或时间限制，答案并不一定完整，但当一个 SwiftUI 的疑问是由苹果的工程师解答时，即使只是关键字的指引也能起到画龙点睛的作用（比如 &lt;code>StateObject&lt;/code> 与 &lt;code>ObservedObject&lt;/code> 的差异）。&lt;/p>
&lt;p>第二天更多的是听社区开发者的一些交流，收获到了不少之前并不知道的资料。一并列在下方。&lt;/p>
&lt;p>ps：感觉参加这次活动对自己来说还有一个副作用就是，由于资料的推荐者有足够的可信度，并且提供了一个可靠的学习路线，所以会用格外的认真来对待它们。&lt;/p>
&lt;p>Swift UI 的入门指引&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://developer.apple.com/videos/play/wwdc2020/10119/">WWDC - Introduction to SwiftUI&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developer.apple.com/videos/play/wwdc2019/216/">WWDC - SwiftUI Essentials&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developer.apple.com/tutorials/sample-apps">十个很有代表性的 Playground&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developer.apple.com/tutorials/swiftui">交互式的 SwiftUI 入门教程&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developer.apple.com/tutorials/app-dev-training">使用 SwiftUI 构建完整 App 的交互式教程&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>SwiftUI 数据处理要素&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://developer.apple.com/videos/play/wwdc2020/10040/">WWDC - Data Essentials in SwiftUI&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developer.apple.com/videos/play/wwdc2021/10022">WWDC - Demystify SwiftUI&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developer.apple.com/documentation/SwiftUI/State-and-Data-Flow">状态与数据流&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developer.apple.com/documentation/swiftui/managing-model-data-in-your-app">如何管理 App 中的模型数据&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developer.apple.com/documentation/swiftui/managing-user-interface-state">如何管理 UI 状态&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>SwiftUI 布局和渲染&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://developer.apple.com/videos/play/wwdc2021/10018/">WWDC - What&amp;rsquo;s new in SwiftUI&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developer.apple.com/videos/play/wwdc2020/10031/">WWDC - Stacks, Grids, and Outlines in SwiftUI&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developer.apple.com/videos/play/wwdc2021/10021/">WWDC - Add rich graphics to your SwiftUI app&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developer.apple.com/videos/play/wwdc2019/237/">WWDC - Building Custom Views with SwiftUI&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developer.apple.com/documentation/swiftui/layout-containers">布局容器&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developer.apple.com/documentation/swiftui/collection-containers">集合布局容器&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developer.apple.com/documentation/swiftui/drawing-and-graphics">图像与绘制&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>用 SwiftUI 打造 watchOS app&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://developer.apple.com/videos/play/wwdc2019/219/">WWDC - SwiftUI on watchOS&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developer.apple.com/videos/play/wwdc2020/10048/">WWDC - Build complications in SwiftUI&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developer.apple.com/documentation/example-articles/building_a_watchos_app">打造 watchOS App&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developer.apple.com/documentation/watchosapps/developing_a_user_interface_with_swiftui">如何利用 SwiftUI 以及手表特定功能打造复杂 app 的代码示例&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>社区开发者提及&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://developer.apple.com/documentation/docc#Overview">文档生成工具 - DocC&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://swiftui-lab.com/random-lessons/">WWDC Digital Lounges 中的开发者问答整理&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://swiftui-lab.com/companion/">SwiftUI Companion - 交互式 SwiftUI API 文档工具&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>SwiftUI 状态管理 —— Composible Binding</title><link>https://joeytat.github.io/posts/composible_binding/</link><pubDate>Mon, 03 Jan 2022 00:00:00 +0000</pubDate><guid>https://joeytat.github.io/posts/composible_binding/</guid><description>
&lt;p>在 SwiftUI 中，需要通过数据来驱动 UI 的变化。数据结构抽象描述的质量也影响着我们对 SwiftUI 界面的维护。&lt;/p>
&lt;p>通常数据中可能存在很多状态，如果使用很多的 boolean 值来描述这些状态，那么 App 的可维护性可能会大大降低。&lt;/p>
&lt;h2 id="管理独立状态的问题">
管理独立状态的问题
&lt;a href="#%e7%ae%a1%e7%90%86%e7%8b%ac%e7%ab%8b%e7%8a%b6%e6%80%81%e7%9a%84%e9%97%ae%e9%a2%98" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h2>
&lt;p>假设我们有一个 App，用户可以在登录与非登录状态下进行操作。所以我们的界面需要兼容这两种状态，其描述可能是这样的：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">AppState&lt;/span>: ObservableObject {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @Published &lt;span style="color:#66d9ef">var&lt;/span> user: User? = &lt;span style="color:#66d9ef">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @Published &lt;span style="color:#66d9ef">var&lt;/span> error: Error? = &lt;span style="color:#66d9ef">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> authenticated: Bool { user &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> hasError: Bool { error &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>基于这样的状态描述，如果我们想创建一个仅展示用户名的组件大概会是这样：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> body: some View {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Group {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> state.hasError {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Text(&lt;span style="color:#e6db74">&amp;#34;Oops, sth went wrong: &lt;/span>&lt;span style="color:#e6db74">\(&lt;/span>state.error!.localizedDescription&lt;span style="color:#e6db74">)&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> state.authenticated {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Text(&lt;span style="color:#e6db74">&amp;#34;Hello &lt;/span>&lt;span style="color:#e6db74">\(&lt;/span>state.user?.name ?? &lt;span style="color:#e6db74">&amp;#34;Unknown&amp;#34;&lt;/span>&lt;span style="color:#e6db74">)&lt;/span>&lt;span style="color:#e6db74">!&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Text(&lt;span style="color:#e6db74">&amp;#34;Hello, stranger&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>粗看没有什么问题，实际上在维护这样的数据结构时就需要格外小心了。比如第一次我们登录失败，为了展示错误信息给 &lt;code>error&lt;/code> 设置了值之后。必须在登录成功之后要及时地去清空 error，否则即使 &lt;code>state.authenticated&lt;/code> 等于 &lt;code>true&lt;/code>，用户依然无法看到正确的信息。&lt;/p>
&lt;p>这还仅仅是有两个状态的情况下，像这样独立状态属性会带来很大的维护成本，开发者需要牢记各个属性之间的依赖关系，甚至编写界面的时候，还需要注意代码执行顺序。&lt;/p>
&lt;h2 id="引入状态机">
引入状态机
&lt;a href="#%e5%bc%95%e5%85%a5%e7%8a%b6%e6%80%81%e6%9c%ba" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h2>
&lt;p>把状态抽象成带有 associated values 的 enum 是个更好的选择，比如:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">AppState&lt;/span>: ObservableObject {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">enum&lt;/span> &lt;span style="color:#a6e22e">AccountState&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> authenticated(User)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> unauthenticated
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> error(Error)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @Published &lt;span style="color:#66d9ef">var&lt;/span> accountState: AccountState = .unauthenticated
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 界面中的使用&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> body: some View {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> VStack {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">switch&lt;/span> state.accountState {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> .authenticated(&lt;span style="color:#66d9ef">let&lt;/span> user):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Text(&lt;span style="color:#e6db74">&amp;#34;Hello &lt;/span>&lt;span style="color:#e6db74">\(&lt;/span>user.name&lt;span style="color:#e6db74">)&lt;/span>&lt;span style="color:#e6db74">!&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> .unauthenticated:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Text(&lt;span style="color:#e6db74">&amp;#34;unregister&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> .error(&lt;span style="color:#66d9ef">let&lt;/span> error):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Text(&lt;span style="color:#e6db74">&amp;#34;Oops, sth went wrong: &lt;/span>&lt;span style="color:#e6db74">\(&lt;/span>error.localizedDescription&lt;span style="color:#e6db74">)&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样被状态机驱动的界面看起来要直观多了。并且在每个状态中对数据的操作，也由 enum 赋予了隔离能力。&lt;/p>
&lt;h2 id="双向绑定怎么办">
双向绑定怎么办？
&lt;a href="#%e5%8f%8c%e5%90%91%e7%bb%91%e5%ae%9a%e6%80%8e%e4%b9%88%e5%8a%9e" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h2>
&lt;p>但这样做又来带个新的问题，现在没办法直接通过 &lt;code>$&lt;/code> 来获取 Binding wrapper 来修改状态：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">switch&lt;/span> state.accountState {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> .authenticated(&lt;span style="color:#66d9ef">let&lt;/span> user):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Text(&lt;span style="color:#e6db74">&amp;#34;Hello &lt;/span>&lt;span style="color:#e6db74">\(&lt;/span>user.name&lt;span style="color:#e6db74">)&lt;/span>&lt;span style="color:#e6db74">!&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TextField(&lt;span style="color:#e6db74">&amp;#34;Change username&amp;#34;&lt;/span>, text: &amp;lt;Binding&amp;lt;String&amp;gt;&lt;span style="color:#f92672">&amp;gt;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 不支持填入 self.$state.accountState.name 👆&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>Xcode 会提示: dynamic member &amp;rsquo;name&amp;rsquo; using key path from root type &amp;lsquo;AppState.AccountState&amp;rsquo;&lt;/p>
&lt;/blockquote>
&lt;p>为什么当操作对象是 class 时，是可以做到通过
&lt;code>self.$state.user.name&lt;/code> 来获取到 name 属性的 Binding 封装的？&lt;/p>
&lt;h2 id="实现动态成员查找dynamic-member-lookup">
实现动态成员查找(dynamic member lookup)
&lt;a href="#%e5%ae%9e%e7%8e%b0%e5%8a%a8%e6%80%81%e6%88%90%e5%91%98%e6%9f%a5%e6%89%bedynamic-member-lookup" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h2>
&lt;p>因为 Enum 还不支持动态成员查找特性。什么是动态成员查找？简而言之就是通过 &lt;code>\&lt;/code> 来获取到成员属性的 &lt;code>KeyPath&lt;/code> 封装（&lt;a href="https://www.swiftbysundell.com/articles/the-power-of-key-paths-in-swift/">什么又是 KeyPath&lt;/a>？），然后将其转化为对应的 Binding 封装。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">extension&lt;/span> &lt;span style="color:#a6e22e">Binding&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">transform&lt;/span>&amp;lt;LocalValue&amp;gt;(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">_&lt;/span> keyPath: WritableKeyPath&amp;lt;Value, LocalValue&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ) -&amp;gt; Binding&amp;lt;LocalValue&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Binding&amp;lt;LocalValue&amp;gt;(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">get&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">self&lt;/span>.wrappedValue[keyPath: keyPath]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">set&lt;/span>: { localValue &lt;span style="color:#66d9ef">in&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">self&lt;/span>.wrappedValue[keyPath: keyPath] = localValue
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">self&lt;/span>.&lt;span style="color:#960050;background-color:#1e0010">$&lt;/span>state.accountState.username
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 等价于 &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">self&lt;/span>.&lt;span style="color:#960050;background-color:#1e0010">$&lt;/span>state.transform(&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>accountState).transform(&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>username)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>所以接下来只需要为 enum 添加动态成员查找的支持就可以了&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">extension&lt;/span> &lt;span style="color:#a6e22e">Binding&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">unwrap&lt;/span>&amp;lt;Wrapped&amp;gt;() -&amp;gt; Binding&amp;lt;Wrapped&amp;gt;? &lt;span style="color:#66d9ef">where&lt;/span> Value == Wrapped? {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">guard&lt;/span> &lt;span style="color:#66d9ef">let&lt;/span> value = &lt;span style="color:#66d9ef">self&lt;/span>.wrappedValue &lt;span style="color:#66d9ef">else&lt;/span> { &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Binding&amp;lt;Wrapped&amp;gt;(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">get&lt;/span>: { value },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">set&lt;/span>: { &lt;span style="color:#66d9ef">self&lt;/span>.wrappedValue = $0 }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后再到 enum 里添加一个计算属性方便我们获取&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">enum&lt;/span> &lt;span style="color:#a6e22e">AccountState&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> loggedIn(User)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> unregister
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> username: String? {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">get&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">guard&lt;/span> &lt;span style="color:#66d9ef">case&lt;/span> .loggedIn(&lt;span style="color:#66d9ef">let&lt;/span> user) = &lt;span style="color:#66d9ef">self&lt;/span> &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> user.username
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">set&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">guard&lt;/span> &lt;span style="color:#66d9ef">case&lt;/span> .loggedIn(&lt;span style="color:#66d9ef">let&lt;/span> user) = &lt;span style="color:#66d9ef">self&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> newValue = newValue &lt;span style="color:#66d9ef">else&lt;/span> { &lt;span style="color:#66d9ef">return&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> user.username = newValue
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">self&lt;/span> = .loggedIn(user)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>现在就可以在 SwiftUI 中对 enum 使用绑定了&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#66d9ef">let&lt;/span> username = &lt;span style="color:#66d9ef">self&lt;/span>.&lt;span style="color:#960050;background-color:#1e0010">$&lt;/span>state.accountState.username.unwrap() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TextField(&lt;span style="color:#e6db74">&amp;#34;Change username&amp;#34;&lt;/span>, text: username)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>看起来还是有些麻烦，对于每个要使用 Binding 的属性都需要去写一个计算属性来包装一层。这样显然这并不如 &lt;code>KeyPath&lt;/code> 那样，直接通过 &lt;code>self.$state.accountState[\.authenticated]&lt;/code> 来获取到 enum 中 associated value 的 Binding 包装来得方便。&lt;/p>
&lt;p>虽然 Swift 目前不支持，但我们还是可以通过引入 &lt;a href="https://github.com/pointfreeco/swift-case-paths">CasePaths&lt;/a> 这个第三方依赖来实现。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">import&lt;/span> &lt;span style="color:#a6e22e">CasePaths&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">enum&lt;/span> &lt;span style="color:#a6e22e">AccountState&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> authenticated(User)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> unauthenticated
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> error(Error)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 计算属性可以删除掉了&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// var username: String? {&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// get {&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// guard case .authenticated(let user) = self else {&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// return nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// }&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// return user.name&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// }&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// set {&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// guard case .authenticated(let user) = self,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// let newValue = newValue else { return }&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// user.name = newValue&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// self = .authenticated(user)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// }&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// }&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 界面中直接使用 CasePath&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#66d9ef">let&lt;/span> user = &lt;span style="color:#66d9ef">self&lt;/span>.&lt;span style="color:#960050;background-color:#1e0010">$&lt;/span>state.accountState.matching(&lt;span style="color:#f92672">/&lt;/span>.authenticated) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TextField(&lt;span style="color:#e6db74">&amp;#34;Change username&amp;#34;&lt;/span>, text: user.name)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>由此为 Enum 也增加了与 Struct、Class 等效的 KeyPath 支持，从而使得文章开头用 Enum 作为 SwiftUI 的状态机管理工具更便捷了一些。&lt;/p>
&lt;h2 id="参考资料">
参考资料
&lt;a href="#%e5%8f%82%e8%80%83%e8%b5%84%e6%96%99" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://kentcdodds.com/blog/stop-using-isloading-booleans">Stop using isLoading booleans&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.swiftbysundell.com/articles/the-power-of-key-paths-in-swift/">The power of key paths in Swift&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.pointfree.co/collections/swiftui/composable-bindings/ep107-composable-swiftui-bindings-the-problem">Composable SwiftUI Bindings: The Problem&lt;/a>&lt;/li>
&lt;/ul></description></item></channel></rss>