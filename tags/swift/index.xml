<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Swift on Dev Log</title><link>https://joeytat.github.io/tags/swift/</link><description>Recent content in Swift on Dev Log</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Fri, 02 Jun 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://joeytat.github.io/tags/swift/index.xml" rel="self" type="application/rss+xml"/><item><title>构建易维护的 Design System: 为什么 SwiftUI 会是更好的选择</title><link>https://joeytat.github.io/posts/why-swiftui-is-better-at-building-a-design-system/</link><pubDate>Fri, 02 Jun 2023 00:00:00 +0000</pubDate><guid>https://joeytat.github.io/posts/why-swiftui-is-better-at-building-a-design-system/</guid><description>
&lt;p>&lt;code>SwiftUI&lt;/code> 自 iOS 13 发布以来，虽然已经面向公众近 4 年，但由于在实现复杂布局时的性能不佳，以及因其内置组件的底层实现变更（iOS 16 上 &lt;code>List&lt;/code> 的底层实现从 &lt;code>UITableView&lt;/code> 改成了 &lt;code>UICollectionView&lt;/code> ），导致开发者们原本良好运行代码随系统升级被破坏了。iOS 14 之前 SwiftUI 的开发者体验也让人一言难尽。尽管有很多的槽点，但我们还是能发现社区整体上还是比较接纳 SwiftUI。所以如果你对 SwiftUI 还有所犹豫，不清楚为何要使用它，这篇文章或许能够带来一些新的想法。&lt;/p>
&lt;p>本篇文章主要是想要通过 Design System 为切入点，同大家讨论相比起 UIKit，为什么更推荐使用 SwiftUI 来实现大多数业务场景下的 UI 组件。&lt;/p>
&lt;p>首先简单概括一下 Design System 是什么，Design System 是一个包含了设计原则、组件库和代码资源等系统化的指导，旨在促进团队间的协作和提高项目的一致性。它可以帮助团队更快速、高效地构建应用程序，同时确保应用程序的外观和交互保持一致。&lt;/p>
&lt;p>接下来就进入正题，从以下几点来探讨一下通过 SwiftUI 构建 Design System 有哪些优势。&lt;/p>
&lt;ul>
&lt;li>声明式语法会更具有可读性和易于实现&lt;/li>
&lt;li>内建的一致性和统一性表达&lt;/li>
&lt;li>单向数据流带来的可预测性&lt;/li>
&lt;li>与 Design System 有更相似的哲学思想&lt;/li>
&lt;/ul>
&lt;h2 id="声明式语法会更具有可读性和易于实现">
声明式语法会更具有可读性和易于实现
&lt;a href="#%e5%a3%b0%e6%98%8e%e5%bc%8f%e8%af%ad%e6%b3%95%e4%bc%9a%e6%9b%b4%e5%85%b7%e6%9c%89%e5%8f%af%e8%af%bb%e6%80%a7%e5%92%8c%e6%98%93%e4%ba%8e%e5%ae%9e%e7%8e%b0" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h2>
&lt;p>首先从实现和维护成本上来说，SwiftUI 与 Apple 现有的 UIKit 和 AppKit 不同，SwiftUI 采用了声明式语法构建 UI。由于声明式语法更关注于描述 UI 的最终效果，而不是具体实现方式。这使得通过声明式语法编写的 UI 组件更具可读性，有助于团队更好地协作实现 Design System。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// SwiftUI&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>VStack(spacing: &lt;span style="color:#ae81ff">20&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Text(&lt;span style="color:#e6db74">&amp;#34;Hello&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .font(.largeTitle)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Text(&lt;span style="color:#e6db74">&amp;#34;World&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .font(.largeTitle)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>.foregroundColor(.blue)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// UIKit&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> stackView = UIStackView()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>stackView.axis = .vertical
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>stackView.spacing = &lt;span style="color:#ae81ff">20&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> helloLabel = UILabel()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>helloLabel.text = &lt;span style="color:#e6db74">&amp;#34;Hello&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>helloLabel.font = UIFont.systemFont(ofSize: &lt;span style="color:#ae81ff">34&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>stackView.addArrangedSubview(helloLabel)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> worldLabel = UILabel()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>worldLabel.text = &lt;span style="color:#e6db74">&amp;#34;World&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>worldLabel.font = UIFont.systemFont(ofSize: &lt;span style="color:#ae81ff">34&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>stackView.addArrangedSubview(worldLabel)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>stackView.backgroundColor = .blue
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>除了代码数量上的差距，我们还可以在 SwiftUI 示例中通过代码结构就直观地感受到 UI 组件是如何被排列的。&lt;/p>
&lt;h2 id="内建的一致性和统一性表达">
内建的一致性和统一性表达
&lt;a href="#%e5%86%85%e5%bb%ba%e7%9a%84%e4%b8%80%e8%87%b4%e6%80%a7%e5%92%8c%e7%bb%9f%e4%b8%80%e6%80%a7%e8%a1%a8%e8%be%be" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h2>
&lt;p>在 SwiftUI 中，我们可以通过 &lt;code>View Modifier&lt;/code> 来实现对 UI 组件的统一性表达。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// SwiftUI&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Button(&lt;span style="color:#e6db74">&amp;#34;Primary&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// action&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>.buttonStyle(PrimaryButtonStyle())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Button(&lt;span style="color:#e6db74">&amp;#34;Secondary&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// action&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>.buttonStyle(SecondaryButtonStyle()) &lt;span style="color:#75715e">// 当 Primary， 或 Secondary style 发生变化时，所有使用了这两个 style 的按钮都会被自动更新&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// UIKit&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> primaryButton = UIButton()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>primaryButton.setTitle(&lt;span style="color:#e6db74">&amp;#34;Primary&amp;#34;&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">，&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span>: .normal)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>primaryButton.titleLabel?.font = UIFont.systemFont(ofSize: &lt;span style="color:#ae81ff">16&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>primaryButton.backgroundColor = UIColor.blue
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>primaryButton.layer.cornerRadius = &lt;span style="color:#ae81ff">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> secondaryButton = UIButton()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>secondaryButton.setTitle(&lt;span style="color:#e6db74">&amp;#34;Secondary&amp;#34;&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">，&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span>: .normal)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>secondaryButton.titleLabel?.font = UIFont.systemFont(ofSize: &lt;span style="color:#ae81ff">16&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>secondaryButton.backgroundColor = UIColor.gray
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>secondaryButton.layer.cornerRadius = &lt;span style="color:#ae81ff">5&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>通过代码我们可以看到 SwiftUI 预定义的设计规范，使开发者更易于表达和保证 Design System 的统一性。&lt;/p>
&lt;p>虽然开发者也可以对 UIKit 的 UI 组件进行封装，实现类似 SwiftUI View Modifier 的效果。但是 SwiftUI 的 View Modifier 是内在耦合的，会天然具有更好的一致性。而对 UIKit 进行二次封装，仍需依赖于开发者自觉遵循设计规范，难免会产生疏忽的情况，影响最终 UI 的一致性。&lt;/p>
&lt;h2 id="单向数据流带来的可预测性">
单向数据流带来的可预测性
&lt;a href="#%e5%8d%95%e5%90%91%e6%95%b0%e6%8d%ae%e6%b5%81%e5%b8%a6%e6%9d%a5%e7%9a%84%e5%8f%af%e9%a2%84%e6%b5%8b%e6%80%a7" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h2>
&lt;p>SwiftUI 所编写的 UI 组件更具有可预测性。体现在其遵循单向数据流原则，这样可以减少因为状态管理复杂性导致的 UI 错误。同时 UI 组件的样式是通过高阶函数或组合来创建的，而不是通过副作用或隐式规则创建，这使得开发者更容易识别组件会具备哪些样式及其来源。&lt;/p>
&lt;p>相比之下 UIKit 作为命令式 UI 框架，其 UI 渲染过程则相对复杂和难以预测。&lt;/p>
&lt;ul>
&lt;li>状态变化会导致难以跟踪的副作用，这使 UI 更易出错且难以调试。&lt;/li>
&lt;li>样式规则由开发者自行定义并应用，存在较大随意性，阅读和理解起来也更加困难。&lt;/li>
&lt;li>样式的来源和应用不像 SwiftUI 那样清晰，需要开发者自行理清各个样式规则之间的关系，以确保 UI 的正确性。&lt;/li>
&lt;/ul>
&lt;h2 id="更相似的哲学思想">
更相似的哲学思想
&lt;a href="#%e6%9b%b4%e7%9b%b8%e4%bc%bc%e7%9a%84%e5%93%b2%e5%ad%a6%e6%80%9d%e6%83%b3" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h2>
&lt;p>SwiftUI 中组合和函数式的思想与 Design System 中原子组件和组合的原则相吻合。&lt;/p>
&lt;ul>
&lt;li>两者都倾向于构建出小的、自洽的单位，然后通过组合来创建更为复杂的结构，SwiftUI 中的视图和 Modifier 就是这种单位和组合的体现。&lt;/li>
&lt;li>组件和函数都是可以是通用的或定制的，同时可以将其重复使用或组合。在 SwiftUI 中，我们可以构建出通用的 Modifier 和视图，也可以为某一具体视图定制特有的 Modifier。&lt;/li>
&lt;li>当改变基础单位(如字号，间距等基础单位)会以可控方式影响所有组合。如果我们改变一个 Modifier 的行为或属性，所有应用该 Modifier 的视图将会相应改变。这使得在设计系统中调整细节时，更易预测和控制其影响范围。&lt;/li>
&lt;/ul>
&lt;p>而相比之下，UIKit 作为命令式框架，其 UI 构建方式则相对零散和随意:&lt;/p>
&lt;ul>
&lt;li>构建 UI 时，开发者自行决定组装哪些控件和设置何种属性，难以遵循统一的组合规则。&lt;/li>
&lt;li>没有类似 Modifier 的机制，每个视图的样式都需要单独设置，无法在多处重复使用。这使得调整样式时，需要逐个修改每个视图，难以高效地应用设计变化。&lt;/li>
&lt;li>属性的变化并不一定会影响所有相关视图，需要开发者自己再逐个对应用的视图做出修改。这加大了设计系统维护的难度。&lt;/li>
&lt;/ul>
&lt;h2 id="最后">
最后
&lt;a href="#%e6%9c%80%e5%90%8e" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h2>
&lt;p>还需要说明的是，本文只是想探讨在实现移动平台的 Design System 时相比起 UIKit，SwiftUI 所具有的一定优势。&lt;/p>
&lt;p>在某些复杂的场景下，UIKit 这样命令式的 UI 框架的灵活性和性能可能会更强。所以需要注意的是，SwiftUI 的组件状态和行为都是由数据驱动，这可能会导致性能问题，如大量的数据绑定和更新可能会引起 UI 界面的卡顿和延迟。相比之下，UIKit 接近底层渲染机制，性能表现可能更佳。但 SwiftUI 也有实现跨平台需求的优势。&lt;/p>
&lt;p>在选择具体哪个框架实现 Design System 时，开发者还是得根据具体需求，权衡两者之间的优缺点。在追求性能或需要高度定制化的场景下，UIKit 的灵活性和性能表现可能更占优。但在大多数情况下，SwiftUI 的声明式语法和组合特性，使其天然更适合构建统一且易维护的 Design System。&lt;/p></description></item><item><title>iOS 架构之另一种依赖注入的思路</title><link>https://joeytat.github.io/posts/swift_dependency_injection/</link><pubDate>Tue, 15 Mar 2022 00:00:00 +0000</pubDate><guid>https://joeytat.github.io/posts/swift_dependency_injection/</guid><description>
&lt;p>在 iOS 业务开发过程经常面对网络请求，数据持久化这样带有副作用的操作。为了能够在测试中 mock 这些操作，通常的做法就是抽象一层 protocol 出来，然后编写不同的实现。&lt;/p>
&lt;p>比如需要处理一个简陋的注册业务（示例省略了一点细节），需要用户输入信息后发送网络请求，成功后返回对应用户对象。&lt;/p>
&lt;p>首先为网络请求定义一个 protocol：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">protocol&lt;/span> &lt;span style="color:#a6e22e">SignUpRepositoryProtocol&lt;/span>: RepositoryProtocol {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">handleSignUp&lt;/span>(name: String, email: String, pwd: String) -&amp;gt; AnyPublisher&amp;lt;User, Error&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>对其进行实现：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">SignUpRepository&lt;/span>: SignUpRepositoryProtocol {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">handleSignUp&lt;/span>(name: String, email: String, pwd: String) -&amp;gt; AnyPublisher&amp;lt;User, Error&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> client(.signUp(name, email, pwd))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .map
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .decode
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .eraseToAnyPublisher()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>将其注入到 &lt;code>ViewModel&lt;/code> 或是 &lt;code>Interactor&lt;/code> 中（取决于你采取的架构是什么 :p ），并且调用对应方法：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">SignUpViewModel&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">enum&lt;/span> &lt;span style="color:#a6e22e">State&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> loading
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> success
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> failed
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> repository: SignUpRepositoryPortocol
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> state: State = .loading
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">init&lt;/span>(repository: SignUpRepositoryPortocol) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">self&lt;/span>.repository = repository
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">onSubmit&lt;/span>(name: String, email: String, pwd: String) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> repository.hanldeSignUp(name: name, email: email, pwd: pwd)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .sink {[&lt;span style="color:#66d9ef">weak&lt;/span> &lt;span style="color:#66d9ef">self&lt;/span>] completion &lt;span style="color:#66d9ef">in&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">switch&lt;/span> completion {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> .failure:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">self&lt;/span>.?state = .failed
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> .finished: &lt;span style="color:#66d9ef">break&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } receiveValue: {[&lt;span style="color:#66d9ef">weak&lt;/span> &lt;span style="color:#66d9ef">self&lt;/span>] result &lt;span style="color:#66d9ef">in&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">self&lt;/span>?.state = .success
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }.store(&lt;span style="color:#66d9ef">in&lt;/span>: &amp;amp;bag)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>由此如果需要测试对应的方法，只需要再创建一份 &lt;code>MockSignUpRepository&lt;/code> 的实现即可，比如想要测试注册成功或失败场景下的处理：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">MockSignUpRepository&lt;/span>: SignUpRepositoryPortocol {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> shouldSignUpSuccess: Bool
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">handleSignUp&lt;/span>(name: String, email: String, pwd: String) -&amp;gt; AnyPublisher&amp;lt;User, Error&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> shouldSignUpSuccess {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Just(User.mock)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .mapError{ &lt;span style="color:#66d9ef">_&lt;/span> &lt;span style="color:#66d9ef">in&lt;/span> SignUpError.someError }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .eraseToAnyPublisher()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Fail(error: SignUpError.someError)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .eraseToAnyPublisher()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在编写测试的时候，传入 &lt;code>SignUpViewModel&lt;/code> 的依赖替换成我们想要测试的 Mock 实现：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">shouldSignUpSuccessWhenXXX&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Given&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> sut = SignUpViewModel(repository: MockSignUpSuccessRepository(shouldSignUpSuccess: &lt;span style="color:#66d9ef">true&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// When&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sut.onSubmit(...) &lt;span style="color:#75715e">// 合法输入&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Then&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> XCTAssertEqual(sut.state, .success)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">shouldSignUpFailWhenXXX&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Given&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> sut = SignUpViewModel(repository: MockSignUpSuccessRepository(shouldSignUpSuccess: &lt;span style="color:#66d9ef">false&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// When&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sut.onSubmit(...) &lt;span style="color:#75715e">// 非法输入&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Then&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> XCTAssertEqual(sut.state, .failed)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这时候似乎一切都很美好，但现在再补充一些业务需求，如果需要返回不同的错误类型怎么办？比如用户名错误，那就需要额外的布尔值来表示；再比如邮箱错误，那又需要增加新的布尔值。而这还仅仅只是一个方法的几个分支逻辑处理。当出现较多的逻辑分支之后，如果我们实际的业务再发生变动需要重构，那还得去对 Mock 类也进行重构，同时还需要确保这些控制逻辑分支的布尔值也得到了正确的更新。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> sut = SignUpViewModel(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> repository: MockSignUpSuccessRepository(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> shouldSignUpSuccess: &lt;span style="color:#66d9ef">false&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> shouldShowUsernameError: &lt;span style="color:#66d9ef">true&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> shouldShowEmailError: &lt;span style="color:#66d9ef">true&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> shouldUsernamePassValidation: &lt;span style="color:#66d9ef">true&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> shouldEmailPassValidation: &lt;span style="color:#66d9ef">true&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...😱&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这时候就可以介绍另一种依赖注入方式了。首先定义一个 &lt;code>Repository&lt;/code> 对象，这个对象就像之前的 &lt;code>Repository&lt;/code> 一样，区别是网络请求通过一个属性来持有，同时会提供一个标记为 private 的默认实现：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Repository&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> handleSignUp = handleSignUp(name:, email:, pwd:)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">handleSignUp&lt;/span>(name: String, email: String, pwd: String) -&amp;gt; AnyPublisher&amp;lt;User, Error&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> client(.signUp(name, email, pwd))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .map
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .decode
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .eraseToAnyPublisher()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后将这个 &lt;code>Repository&lt;/code> 实例放到一个 &lt;code>Environment&lt;/code> 对象中：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Environment&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> repo = Repository()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>同时替换 ViewModel 中之前对 &lt;code>Repository&lt;/code> 的引用：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">SignUpViewModel&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">enum&lt;/span> &lt;span style="color:#a6e22e">State&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> loading
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> success
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> failed
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// let repository: SignUpRepositoryPortocol&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> current: Environment &lt;span style="color:#75715e">// 👈&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> state: State = .loading
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">init&lt;/span>(current: Environment) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">self&lt;/span>.current = current &lt;span style="color:#75715e">// 👈&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">onSubmit&lt;/span>(name: String, email: String, pwd: String) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> current.repo.hanldeSignUp(name, email, pwd) &lt;span style="color:#75715e">// 👈&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .sink { completion &lt;span style="color:#66d9ef">in&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">switch&lt;/span> completion {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> .failure:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">self&lt;/span>.state = .failed
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> .finished: &lt;span style="color:#66d9ef">break&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } receiveValue: {[&lt;span style="color:#66d9ef">weak&lt;/span> &lt;span style="color:#66d9ef">self&lt;/span>] result &lt;span style="color:#66d9ef">in&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">self&lt;/span>?.state = .success
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }.store(&lt;span style="color:#66d9ef">in&lt;/span>: &amp;amp;bag)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>代码几乎和之前相同，但保持了更高的可替换性，怎么体现的呢？需要 mock 网络请求 时，可以给 Repository 创建一个 extension：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">extension&lt;/span> &lt;span style="color:#a6e22e">Repository&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">let&lt;/span> mock = Repository(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> handleSignUp: Just(User.mock)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .mapError{ &lt;span style="color:#66d9ef">_&lt;/span> &lt;span style="color:#66d9ef">in&lt;/span> SignUpError.someError }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .eraseToAnyPublisher()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后在测试代码构建 ViewModel 的时候就可以将 Mock 传递进去：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">shouldSignUpSuccessWhenXXX&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Given&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> sut = SignUpViewModel(current: Environment(repo: Repository.mock))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// When&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sut.onSubmit(...) &lt;span style="color:#75715e">// 合法输入&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Then&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> XCTAssertEqual(sut.state, .success)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>对于方法多分支的逻辑，则可以独立实现一份，而不是重新创建整个 &lt;code>MockRepository&lt;/code> 类或者是用一些变量来控制分支逻辑：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">shouldSignUpFailWhenXXX&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Given&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> sut = SignUpViewModel(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> current: Environment(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> repo: Repository(handleSignUp:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Fail(error: SignUpError.someError).eraseToAnyPublisher()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// When&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sut.onSubmit(...) &lt;span style="color:#75715e">// 非法输入&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Then&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> XCTAssertEqual(sut.state, .failed)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这种方式来注入依赖的优势在于：&lt;/p>
&lt;ul>
&lt;li>不需要像 protocol 那样写太多模版代码&lt;/li>
&lt;li>mock 的逻辑分支很容易可以实现相互独立的版本&lt;/li>
&lt;li>依赖的副作用会更容易 mock，特别是系统类&lt;/li>
&lt;/ul></description></item><item><title>Swift 状态管理 —— 如何拆分庞大的 reducer</title><link>https://joeytat.github.io/posts/combining_reducers/</link><pubDate>Sun, 16 Jan 2022 00:00:00 +0000</pubDate><guid>https://joeytat.github.io/posts/combining_reducers/</guid><description>
&lt;p>因为项目需要使用 SwiftUI，想起来之前买过喵神的 &lt;a href="https://objccn.io/products/swift-ui">《SwiftUI 与 Combine 编程》&lt;/a> 。书中介绍了 &lt;a href="https://redux.js.org">Redux&lt;/a> 这一在 Web 前端领域广泛被验证过的数据管理模式是如何通过 Swift 来实现的，非常推荐 SwiftUI 初见者阅读。&lt;/p>
&lt;p>在学习过程中还产生了一个疑问，如果 reducer 越来越大，有什么更 “swift” 的办法能解决这一问题呢？（在 Redux.js 中的原生解决方案是 &lt;a href="https://redux.js.org/usage/structuring-reducers/beyond-combinereducers">&lt;code>combineReducers&lt;/code>&lt;/a>）&lt;/p>
&lt;h2 id="拆分-reducer">
拆分 Reducer
&lt;a href="#%e6%8b%86%e5%88%86-reducer" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h2>
&lt;p>首先看看问题在代码中的表现是什么样的，假设我们有这样一个 reducer：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">appReducer&lt;/span>(appState: &lt;span style="color:#66d9ef">inout&lt;/span> AppState, action: AppAction) -&amp;gt; Void {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">switch&lt;/span> action {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> .emailValid(&lt;span style="color:#66d9ef">let&lt;/span> isValid):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> appState.settings.isEmailValid = isValid
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> .register(&lt;span style="color:#66d9ef">let&lt;/span> email, &lt;span style="color:#66d9ef">let&lt;/span> password):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> appState.settings.loginUser = User(email, password)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> .login(&lt;span style="color:#66d9ef">let&lt;/span> email, &lt;span style="color:#66d9ef">let&lt;/span> password):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> appState.settings.loginUser = User(email, password)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> .logout:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> appState.settings.loginUser = &lt;span style="color:#66d9ef">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> .loadPokemon(&lt;span style="color:#66d9ef">let&lt;/span> result):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> appState.pokemonList.pokemons = result
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> .favoratePokemon(&lt;span style="color:#66d9ef">let&lt;/span> pokemon):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> appState.favoritePokemons.append(pokemon)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> .removeFavoritePokemon(&lt;span style="color:#66d9ef">let&lt;/span> pokemon):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> index = appState.favoritePokemons.indexOf(pokemon)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> appState.favoritePokemons.remove(at: index)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>应用的 action 主要包含三个模块：&lt;/p>
&lt;ul>
&lt;li>账号登录注册注销&lt;/li>
&lt;li>对神奇宝贝数据进行加载&lt;/li>
&lt;li>处理对神奇宝贝数据的收藏和取消收藏&lt;/li>
&lt;/ul>
&lt;p>从这段代码我们很快就能发现，即使只是非常简单的示例也已经包含了不短的代码了。这里还省略掉了处理状态时可能还需要的异步 action 的处理（数据加载等）。这还仅仅只有两个非常简单的界面状态，当面对真实的 app 所需要处理的数十个页面状态会更恐怖。&lt;/p>
&lt;p>将 reducer 拆分成如下三个独立 reducer：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">accountReducer&lt;/span>(appState: &lt;span style="color:#66d9ef">inout&lt;/span> AppState, action: AppAction) -&amp;gt; Void {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">switch&lt;/span> action {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> .emailValid(&lt;span style="color:#66d9ef">let&lt;/span> isValid):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> appState.settings.isEmailValid = isValid
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> .register(&lt;span style="color:#66d9ef">let&lt;/span> email, &lt;span style="color:#66d9ef">let&lt;/span> password):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> appState.settings.loginUser = User(email, password)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> .login(&lt;span style="color:#66d9ef">let&lt;/span> email, &lt;span style="color:#66d9ef">let&lt;/span> password):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> appState.settings.loginUser = User(email, password)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> .logout:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> appState.settings.loginUser = &lt;span style="color:#66d9ef">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">default&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">pokemonListReducer&lt;/span>(appState: &lt;span style="color:#66d9ef">inout&lt;/span> AppState, action: AppAction) -&amp;gt; Void {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">switch&lt;/span> action {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> .loadPokemon(&lt;span style="color:#66d9ef">let&lt;/span> result):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> appState.pokemonList.pokemons = result
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">default&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">favoritePokemonReducer&lt;/span>(appState: &lt;span style="color:#66d9ef">inout&lt;/span> AppState, action: AppAction) -&amp;gt; Void {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">switch&lt;/span> action {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> .favoratePokemon(&lt;span style="color:#66d9ef">let&lt;/span> pokemon):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> appState.favoritePokemons.append(pokemon)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> .removeFavoritePokemon(&lt;span style="color:#66d9ef">let&lt;/span> pokemon):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> index = appState.favoritePokemons.indexOf(pokemon)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> appState.favoritePokemons.remove(at: index)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">default&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>因为对 reducer 的数量并不确定，所以这里使用可变参数来构建 &lt;code>combine&lt;/code> 方法，对传入的 reducer 进行遍历调用处理 appState。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">combine&lt;/span>&amp;lt;Value, Action&amp;gt;(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">_&lt;/span> reducers: (&lt;span style="color:#66d9ef">inout&lt;/span> Value, Action) -&amp;gt; Void...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>) -&amp;gt; (&lt;span style="color:#66d9ef">inout&lt;/span> Value, Action) -&amp;gt; Void {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> { value, action &lt;span style="color:#66d9ef">in&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> reducer &lt;span style="color:#66d9ef">in&lt;/span> reducers {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> reducer(&amp;amp;value, action)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> appReducer = combine(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> accountReducer,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pokemonListReducer,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> favoritePokemonReducer
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>完成，我们的巨大 reducer 被拆分成了独立的 reducer，再通过自己实现的 combine 方法完成了组装。&lt;/p>
&lt;h2 id="隔离-reducer-数据">
隔离 reducer 数据
&lt;a href="#%e9%9a%94%e7%a6%bb-reducer-%e6%95%b0%e6%8d%ae" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h2>
&lt;p>但仔细观看代码还会发现一个问题，每个 reducer 都只需要处理 &lt;code>appState&lt;/code> 上的部分数据，比如 &lt;code>pokemonListReducer&lt;/code> 明明只操作了 &lt;code>appState.pokemonList&lt;/code>，我们却把整个 state 都丢给了它：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">pokemonListReducer&lt;/span>(appState: &lt;span style="color:#66d9ef">inout&lt;/span> AppState, action: AppAction) -&amp;gt; Void {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">switch&lt;/span> action {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> .loadPokemon(&lt;span style="color:#66d9ef">let&lt;/span> result):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> appState.pokemonList.pokemons = result
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">default&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这会增加代码维护上的困难，不熟悉代码的人在不浏览整个 reducer 之前，很难知道这个 reducer 到底操作了哪些数据。更理想的 reducer 可能长这样：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">pokemonListReducer&lt;/span>(value: &lt;span style="color:#66d9ef">inout&lt;/span> PokemonList, action: AppAction) -&amp;gt; Void {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">switch&lt;/span> action {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> .loadPokemon(&lt;span style="color:#66d9ef">let&lt;/span> result):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> value.pokemons = result &lt;span style="color:#75715e">// 👈 只能操作 pokemonList&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">default&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>只是这样改动之后，之前定义的 combine 就无法编译通过，pokemonListReducer 的签名已经不符合 combine 的要求了。&lt;/p>
&lt;blockquote>
&lt;p>Cannot convert value of type ‘(inout PokemonList, AppAction) -&amp;gt; ()’ to expected argument&lt;/p>
&lt;/blockquote>
&lt;h3 id="拉回">
拉回
&lt;a href="#%e6%8b%89%e5%9b%9e" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h3>
&lt;p>解决这个问题可以引入一个数学中的概念 —— 拉回。&lt;/p>
&lt;blockquote>
&lt;p>引用 wikipedia 上的解释：“简单地说，设 &lt;em>f&lt;/em> 是一个变量 &lt;em>y&lt;/em> 的函数，这里 &lt;em>y&lt;/em> 自身又是另一个变量 &lt;em>x&lt;/em> 的函数，那么 &lt;em>f&lt;/em> 可以写成 &lt;em>x&lt;/em> 的函数，这即 &lt;em>f&lt;/em> 被函数 &lt;em>y&lt;/em>(&lt;em>x&lt;/em>) 拉回。”&lt;/p>
&lt;/blockquote>
&lt;p>在 reducer 中的例子里，也可以套用相同的概念。只需要将持有了部分状态数据的 reducer，转化成一个拥有着全部状态数据的 reducer 签名即可：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">pullback&lt;/span>&amp;lt;LocalValue, GlobalValue, Action&amp;gt;(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">_&lt;/span> reducer: @escaping (&lt;span style="color:#66d9ef">inout&lt;/span> LocalValue, Action) -&amp;gt; Void,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">get&lt;/span>: @escaping (GlobalValue) -&amp;gt; LocalValue,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">set&lt;/span>: @escaping (&lt;span style="color:#66d9ef">inout&lt;/span> GlobalValue, LocalValue) -&amp;gt; Void
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>) -&amp;gt; (&lt;span style="color:#66d9ef">inout&lt;/span> GlobalValue, Action) -&amp;gt; Void {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> { globalValue, action &lt;span style="color:#66d9ef">in&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> localValue = &lt;span style="color:#66d9ef">get&lt;/span>(globalValue)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> reducer(&amp;amp;localValue, action)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">set&lt;/span>(&amp;amp;globalValue, localValue)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>该函数包含三个入参：&lt;/p>
&lt;ol>
&lt;li>用于处理局部状态的 reducer&lt;/li>
&lt;li>提供从全部状态中提取部分状态的函数&lt;/li>
&lt;li>提供将局部状态设置到全部状态中的函数&lt;/li>
&lt;/ol>
&lt;p>这样就得到了一个可以用来转化用于处理局部状态 reducer 到全部状态 reducer 的 pullback 函数：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>pullback(pokemonListReducer,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">get&lt;/span>: { $0.pokemonList },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">set&lt;/span>: { $0.pokemonList = $1 }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>再进一步还可以通过 keyPath 来优化 pullback 函数：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">pullback&lt;/span>&amp;lt;LocalValue, GlobalValue, Action&amp;gt;(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">_&lt;/span> reducer: @escaping (&lt;span style="color:#66d9ef">inout&lt;/span> LocalValue, Action) -&amp;gt; Void,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> value: WritableKeyPath&amp;lt;GlobalValue, LocalValue&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>) -&amp;gt; (&lt;span style="color:#66d9ef">inout&lt;/span> GlobalValue, Action) -&amp;gt; Void {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> { globalValue, action &lt;span style="color:#66d9ef">in&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> reducer(&amp;amp;globalValue[keyPath: value], action)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pullback(pokemonListReducer, value: &lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>AppState.pokemonList)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样就实现了 reducer 的拆分以及对处理状态的隔离&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> appReducer = combine(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pullback(accountReducer, value: &lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>.pokemonList),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pullback(pokemonListReducer, value: &lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>.settings),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pullback(favoritePokemonReducer, value: &lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>.favoritePokemons)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="参考资料">
参考资料
&lt;a href="#%e5%8f%82%e8%80%83%e8%b5%84%e6%96%99" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://objccn.io/products/swift-ui">ObjC 中国 - SwiftUI 与 Combine 编程&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.pointfree.co/collections/composable-architecture/reducers-and-stores/ep69-composable-state-management-state-pullbacks#downloads">Point Free - State Pullbacks&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.swiftbysundell.com/articles/the-power-of-key-paths-in-swift/">Swift by Sundell - The power of key paths in Swift&lt;/a>&lt;/li>
&lt;/ul></description></item></channel></rss>