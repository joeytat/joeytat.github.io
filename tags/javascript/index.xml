<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>JavaScript on Dev Log</title><link>https://joeytat.github.io/tags/javascript/</link><description>Recent content in JavaScript on Dev Log</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Mon, 19 Aug 2019 00:00:00 +0000</lastBuildDate><atom:link href="https://joeytat.github.io/tags/javascript/index.xml" rel="self" type="application/rss+xml"/><item><title>JavaScript 既然是单线程语言，为什么 setTimeout 不会阻塞线程？</title><link>https://joeytat.github.io/posts/asynchronous-javascript/</link><pubDate>Mon, 19 Aug 2019 00:00:00 +0000</pubDate><guid>https://joeytat.github.io/posts/asynchronous-javascript/</guid><description>
&lt;p>先看下面的代码&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">printHello&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Hello&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">printWorld&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;World&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">printHello&lt;/span>(); &lt;span style="color:#75715e">// 输出 Hello
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">printWorld&lt;/span>(); &lt;span style="color:#75715e">// 输出 World
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在 JavaScript 中，存在一个全局调用栈(Global Call Stack)。当我们调用 &lt;code>printHello&lt;/code> 时，会将该方法加入到栈中，由于 JavaScript 是单线程执行机制（同一时间只执行一个命令），所以会在执行完成了 &lt;code>printHello&lt;/code> 之后再执行 &lt;code>printWorld&lt;/code>。&lt;/p>
&lt;p>那么现在就引入标题中的问题，&lt;strong>JavaScript 既然是单线程语言，为什么 setTimeout 不会阻塞线程？&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">printHello&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Hello&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">printWorld&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;World&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">setTimeout&lt;/span>(&lt;span style="color:#a6e22e">printHello&lt;/span>, &lt;span style="color:#ae81ff">1000&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">printWorld&lt;/span>();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>表面上来看 &lt;code>setTimeout&lt;/code> 也是一个方法，他的定义可能是这样：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">setTimeout&lt;/span>(&lt;span style="color:#a6e22e">callbackFunc&lt;/span>, &lt;span style="color:#a6e22e">interval&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ....
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>那么按照 JS 单线程理论来说，应该是先将 &lt;code>setTimeout&lt;/code> 方法压入全局调用栈，并且执行该方法，等待 1 秒钟，然后再执行 &lt;code>printWorld&lt;/code> 才对。但实际上我们都知道，打印的结果会是 &amp;ldquo;World&amp;rdquo; 然后 &amp;ldquo;Hello&amp;rdquo;，这是为什么？&lt;/p>
&lt;h3 id="web-browser-api---callback-queue">
Web Browser API &amp;amp; Callback Queue
&lt;a href="#web-browser-api---callback-queue" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h3>
&lt;p>事实上 &lt;code>setTimeout&lt;/code> 并不是完全是 JS 代码，而是属于 &lt;strong>Web Browser API&lt;/strong> 中的方法。就像名字中所指的那样， JS 调用了 &lt;code>setTimeout&lt;/code> 之后，浏览器（Web Browser）会去创建一个 timer，同时将我们传入 &lt;code>setTimeout&lt;/code> 的方法 - &lt;code>printHello&lt;/code> 加入到 &lt;strong>Callback Queue（回调队列）&lt;/strong> 中。&lt;/p>
&lt;p>1000 毫秒过去后，浏览器会通知 JavaScript 引擎将回调队列中的 &lt;code>printHello&lt;/code> 加入到 JS 的全局调用栈中执行。&lt;/p>
&lt;p>所以在 JS 的全局调用栈看来，是先有一个 &lt;code>printWorld&lt;/code> 加入到了调用栈，过了 1000 毫秒之后，又加入了一个 &lt;code>printHello&lt;/code> 方法。&lt;/p>
&lt;p>那如果我们的 &lt;code>printWorld&lt;/code> 之后还有其他的方法执行时间超过了 1000 毫秒呢？&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/// 省略掉 printHello 和 printWorld 定义
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">heavyWork&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">1000000&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Heavy Work&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">setTimeout&lt;/span>(&lt;span style="color:#a6e22e">printHello&lt;/span>, &lt;span style="color:#ae81ff">1000&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">printWorld&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">heavyWork&lt;/span>(); &lt;span style="color:#75715e">// 假设会执行 2000ms
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>现在让我们假设 &lt;code>heavyWork&lt;/code> 方法会执行 2000ms，可是我们的 &lt;code>setTimeout&lt;/code> 只会执行 1000ms，那么按照上面的理论，1000ms 到了之后，&lt;code>printHello&lt;/code> 会被加入到 JS 的调用栈中执行，那现在的输出会是一堆“Heavy Work”之中夹带着一个“Hello”吗？&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">World&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">Heavy&lt;/span> &lt;span style="color:#a6e22e">Work&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">Hello&lt;/span> &lt;span style="color:#75715e">// 会输出一堆 Heavy Work 中夹带一个 Hello 吗？
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">Heavy&lt;/span> &lt;span style="color:#a6e22e">Work&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>当然不会啦，因为我们有 Event Loop（事件循环机制）。&lt;/p>
&lt;h3 id="event-loop">
Event Loop
&lt;a href="#event-loop" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h3>
&lt;p>Event Loop 其实理解起来非常简单，就是一个循环会不停地检查 JS 调用栈。只有在 JS 调用栈&lt;strong>没有任务&lt;/strong>的情况下，Callback Queue 中的任务，才会被添加到 JS 调用栈。&lt;/p>
&lt;p>所以上面的代码中，&lt;code>setTimeout&lt;/code> 虽然指定了 1000ms 之后就执行 &lt;code>printHello&lt;/code>，但实际上会被需要执行 2000ms 的 &lt;code>heavyWork&lt;/code>阻塞住， 输出的结果会是：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">World&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">Heavy&lt;/span> &lt;span style="color:#a6e22e">Work&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>.... &lt;span style="color:#75715e">// 长达 2000ms 的 Heavy Work
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">Heavy&lt;/span> &lt;span style="color:#a6e22e">Work&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">Hello&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="总结">
总结
&lt;a href="#%e6%80%bb%e7%bb%93" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>Web Browser API&lt;br>
提供给我们 JavaScript 所没有后台运行任务的能力，除了 &lt;code>setTimeout&lt;/code> 和 &lt;code>setInterval&lt;/code> 这样创建 timer 的 API 之外，还包括了 Ajax，用户交互，文件读写等操作。&lt;/li>
&lt;li>Callback Queue&lt;br>
用于持有提交到 Web Browser API 中等待回调的 callback。&lt;/li>
&lt;li>Event Loop&lt;br>
一个不停地检查 JavaScript 调用栈中是否还有任务的循环。&lt;/li>
&lt;/ul></description></item><item><title>如何实现 JavaScript 函数参数必填的支持?</title><link>https://joeytat.github.io/posts/js_required_property/</link><pubDate>Mon, 03 Jun 2019 00:00:00 +0000</pubDate><guid>https://joeytat.github.io/posts/js_required_property/</guid><description>
&lt;p>JS 在 ES6 的中新增了函数参数指定默认值的支持:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">Greeting&lt;/span> &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#a6e22e">name&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Joeytat&amp;#34;&lt;/span>) =&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">`Hello &lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#a6e22e">name&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">`&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">Greeting&lt;/span>() &lt;span style="color:#75715e">// Hello Joeytat
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>那我们就可以利用这一特性, 将一个会抛出异常的方法作为默认参数传递.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">Greeting&lt;/span> &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#a6e22e">name&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#a6e22e">EmptyPropertyException&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;name&amp;#34;&lt;/span>)) =&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">`Hello &lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#a6e22e">name&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">`&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">EmptyPropertyException&lt;/span> &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#a6e22e">propertyName&lt;/span>) =&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> Error(&lt;span style="color:#e6db74">`&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#a6e22e">propertyName&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74"> 为必填参数`&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">Greeting&lt;/span>() &lt;span style="color:#75715e">// 抛出异常: &amp;#34;Error: name 为必填参数&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样如果没有传递参数就会抛出异常, 并且带有友好的提示了.&lt;/p></description></item></channel></rss>