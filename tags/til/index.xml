<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>TIL on Dev Log</title><link>https://joeytat.github.io/tags/til/</link><description>Recent content in TIL on Dev Log</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 19 Aug 2019 00:00:00 +0000</lastBuildDate><atom:link href="https://joeytat.github.io/tags/til/index.xml" rel="self" type="application/rss+xml"/><item><title>TIL - JavaScript 既然是单线程语言，为什么 setTimeout 不会阻塞线程？</title><link>https://joeytat.github.io/posts/asynchronous-javascript/</link><pubDate>Mon, 19 Aug 2019 00:00:00 +0000</pubDate><guid>https://joeytat.github.io/posts/asynchronous-javascript/</guid><description>
&lt;p>先看下面的代码&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">printHello&lt;/span>() {
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Hello&amp;#34;&lt;/span>);
}
&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">printWorld&lt;/span>() {
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;World&amp;#34;&lt;/span>);
}
&lt;span style="color:#a6e22e">printHello&lt;/span>(); &lt;span style="color:#75715e">// 输出 Hello
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">printWorld&lt;/span>(); &lt;span style="color:#75715e">// 输出 World
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在 JavaScript 中，存在一个全局调用栈(Global Call Stack)。当我们调用 &lt;code>printHello&lt;/code> 时，会将该方法加入到栈中，由于 JavaScript 是单线程执行机制（同一时间只执行一个命令），所以会在执行完成了 &lt;code>printHello&lt;/code> 之后再执行 &lt;code>printWorld&lt;/code>。&lt;/p>
&lt;p>那么现在就引入标题中的问题，&lt;strong>JavaScript 既然是单线程语言，为什么 setTimeout 不会阻塞线程？&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">printHello&lt;/span>() {
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Hello&amp;#34;&lt;/span>);
}
&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">printWorld&lt;/span>() {
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;World&amp;#34;&lt;/span>);
}
&lt;span style="color:#a6e22e">setTimeout&lt;/span>(&lt;span style="color:#a6e22e">printHello&lt;/span>, &lt;span style="color:#ae81ff">1000&lt;/span>);
&lt;span style="color:#a6e22e">printWorld&lt;/span>();
&lt;/code>&lt;/pre>&lt;/div>&lt;p>表面上来看 &lt;code>setTimeout&lt;/code> 也是一个方法，他的定义可能是这样：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">setTimeout&lt;/span>(&lt;span style="color:#a6e22e">callbackFunc&lt;/span>, &lt;span style="color:#a6e22e">interval&lt;/span>) {
&lt;span style="color:#75715e">// ....
&lt;/span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>那么按照 JS 单线程理论来说，应该是先将 &lt;code>setTimeout&lt;/code> 方法压入全局调用栈，并且执行该方法，等待 1 秒钟，然后再执行 &lt;code>printWorld&lt;/code> 才对。但实际上我们都知道，打印的结果会是 &amp;ldquo;World&amp;rdquo; 然后 &amp;ldquo;Hello&amp;rdquo;，这是为什么？&lt;/p>
&lt;h3 id="web-browser-api---callback-queue">Web Browser API &amp;amp; Callback Queue&lt;/h3>
&lt;p>事实上 &lt;code>setTimeout&lt;/code> 并不是完全是 JS 代码，而是属于 &lt;strong>Web Browser API&lt;/strong> 中的方法。就像名字中所指的那样， JS 调用了 &lt;code>setTimeout&lt;/code> 之后，浏览器（Web Browser）会去创建一个 timer，同时将我们传入 &lt;code>setTimeout&lt;/code> 的方法 - &lt;code>printHello&lt;/code> 加入到 &lt;strong>Callback Queue（回调队列）&lt;/strong> 中。&lt;/p>
&lt;p>1000 毫秒过去后，浏览器会通知 JavaScript 引擎将回调队列中的 &lt;code>printHello&lt;/code> 加入到 JS 的全局调用栈中执行。&lt;/p>
&lt;p>所以在 JS 的全局调用栈看来，是先有一个 &lt;code>printWorld&lt;/code> 加入到了调用栈，过了 1000 毫秒之后，又加入了一个 &lt;code>printHello&lt;/code> 方法。&lt;/p>
&lt;p>那如果我们的 &lt;code>printWorld&lt;/code> 之后还有其他的方法执行时间超过了 1000 毫秒呢？&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#75715e">/// 省略掉 printHello 和 printWorld 定义
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">heavyWork&lt;/span>() {
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">1000000&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">++&lt;/span>) {
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Heavy Work&amp;#34;&lt;/span>);
}
}
&lt;span style="color:#a6e22e">setTimeout&lt;/span>(&lt;span style="color:#a6e22e">printHello&lt;/span>, &lt;span style="color:#ae81ff">1000&lt;/span>);
&lt;span style="color:#a6e22e">printWorld&lt;/span>();
&lt;span style="color:#a6e22e">heavyWork&lt;/span>(); &lt;span style="color:#75715e">// 假设会执行 2000ms
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>现在让我们假设 &lt;code>heavyWork&lt;/code> 方法会执行 2000ms，可是我们的 &lt;code>setTimeout&lt;/code> 只会执行 1000ms，那么按照上面的理论，1000ms 到了之后，&lt;code>printHello&lt;/code> 会被加入到 JS 的调用栈中执行，那现在的输出会是一堆“Heavy Work”之中夹带着一个“Hello”吗？&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#a6e22e">World&lt;/span>
&lt;span style="color:#a6e22e">Heavy&lt;/span> &lt;span style="color:#a6e22e">Work&lt;/span>
...
&lt;span style="color:#a6e22e">Hello&lt;/span> &lt;span style="color:#75715e">// 会输出一堆 Heavy Work 中夹带一个 Hello 吗？
&lt;/span>&lt;span style="color:#75715e">&lt;/span>...
&lt;span style="color:#a6e22e">Heavy&lt;/span> &lt;span style="color:#a6e22e">Work&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>当然不会啦，因为我们有 Event Loop（事件循环机制）。&lt;/p>
&lt;h3 id="event-loop">Event Loop&lt;/h3>
&lt;p>Event Loop 其实理解起来非常简单，就是一个循环会不停地检查 JS 调用栈。只有在 JS 调用栈&lt;strong>没有任务&lt;/strong>的情况下，Callback Queue 中的任务，才会被添加到 JS 调用栈。&lt;/p>
&lt;p>所以上面的代码中，&lt;code>setTimeout&lt;/code> 虽然指定了 1000ms 之后就执行 &lt;code>printHello&lt;/code>，但实际上会被需要执行 2000ms 的 &lt;code>heavyWork&lt;/code>阻塞住， 输出的结果会是：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#a6e22e">World&lt;/span>
&lt;span style="color:#a6e22e">Heavy&lt;/span> &lt;span style="color:#a6e22e">Work&lt;/span>
.... &lt;span style="color:#75715e">// 长达 2000ms 的 Heavy Work
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">Heavy&lt;/span> &lt;span style="color:#a6e22e">Work&lt;/span>
&lt;span style="color:#a6e22e">Hello&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="总结">总结&lt;/h3>
&lt;ul>
&lt;li>Web Browser API&lt;br>
提供给我们 JavaScript 所没有后台运行任务的能力，除了 &lt;code>setTimeout&lt;/code> 和 &lt;code>setInterval&lt;/code> 这样创建 timer 的 API 之外，还包括了 Ajax，用户交互，文件读写等操作。&lt;/li>
&lt;li>Callback Queue&lt;br>
用于持有提交到 Web Browser API 中等待回调的 callback。&lt;/li>
&lt;li>Event Loop&lt;br>
一个不停地检查 JavaScript 调用栈中是否还有任务的循环。&lt;/li>
&lt;/ul></description></item><item><title>TIL - React 进阶模式之复合组件（Compound Component）</title><link>https://joeytat.github.io/posts/compound-component/</link><pubDate>Mon, 12 Aug 2019 00:00:00 +0000</pubDate><guid>https://joeytat.github.io/posts/compound-component/</guid><description>
&lt;h3 id="复合组件是什么">复合组件是什么&lt;/h3>
&lt;p>编写页面时，经常存在多个子组件的展示，是依赖于同一个数据源的情况。
比如单选框：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-jsx" data-lang="jsx">&amp;lt;&lt;span style="color:#f92672">Switcher&lt;/span>&amp;gt;
&amp;lt;&lt;span style="color:#f92672">Switch&lt;/span> &lt;span style="color:#a6e22e">on&lt;/span>&lt;span style="color:#f92672">=&lt;/span>{&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">props&lt;/span>.&lt;span style="color:#a6e22e">selecting&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;React&amp;#39;&lt;/span>}&amp;gt;&lt;span style="color:#a6e22e">React&lt;/span>&amp;lt;/&lt;span style="color:#f92672">Switch&lt;/span>&amp;gt;
&amp;lt;&lt;span style="color:#f92672">Switch&lt;/span> &lt;span style="color:#a6e22e">on&lt;/span>&lt;span style="color:#f92672">=&lt;/span>{&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">props&lt;/span>.&lt;span style="color:#a6e22e">selecting&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;Vue&amp;#39;&lt;/span>}&amp;gt;&lt;span style="color:#a6e22e">Vue&lt;/span>&amp;lt;/&lt;span style="color:#f92672">Switch&lt;/span>&amp;gt;
&amp;lt;/&lt;span style="color:#f92672">Switcher&lt;/span>&amp;gt;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们可以看到，所有的 &lt;code>Switch&lt;/code> 的数据都需要对 &lt;code>selecting&lt;/code> 的值进行判断，并且代码中其实只有 &lt;code>this.props.selecting ==&lt;/code> 后面的部分不同，如果能改写成这样：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-jsx" data-lang="jsx">&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#a6e22e">Switcher&lt;/span>.&lt;span style="color:#a6e22e">React&lt;/span> &lt;span style="color:#f92672">=&lt;/span> ({&lt;span style="color:#a6e22e">selecting&lt;/span>}) =&amp;gt; (
&amp;lt;&lt;span style="color:#f92672">Switch&lt;/span> &lt;span style="color:#a6e22e">on&lt;/span>&lt;span style="color:#f92672">=&lt;/span>{&lt;span style="color:#a6e22e">selecting&lt;/span> &lt;span style="color:#f92672">===&lt;/span> &lt;span style="color:#e6db74">&amp;#39;React&amp;#39;&lt;/span>}&amp;gt;&lt;span style="color:#a6e22e">React&lt;/span>&amp;lt;/&lt;span style="color:#f92672">Switch&lt;/span>&amp;gt;
)
&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#a6e22e">Switcher&lt;/span>.&lt;span style="color:#a6e22e">Vue&lt;/span> &lt;span style="color:#f92672">=&lt;/span> ({&lt;span style="color:#a6e22e">selecting&lt;/span>}) =&amp;gt; (
&amp;lt;&lt;span style="color:#f92672">Switch&lt;/span> &lt;span style="color:#a6e22e">on&lt;/span>&lt;span style="color:#f92672">=&lt;/span>{&lt;span style="color:#a6e22e">selecting&lt;/span> &lt;span style="color:#f92672">===&lt;/span> &lt;span style="color:#e6db74">&amp;#39;Vue&amp;#39;&lt;/span>}&amp;gt;&lt;span style="color:#a6e22e">Vue&lt;/span>&amp;lt;/&lt;span style="color:#f92672">Switch&lt;/span>&amp;gt;
)
&amp;lt;&lt;span style="color:#f92672">Switcher&lt;/span> &lt;span style="color:#a6e22e">selecting&lt;/span>&lt;span style="color:#f92672">=&lt;/span>{&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">props&lt;/span>.&lt;span style="color:#a6e22e">selecting&lt;/span>}&amp;gt;
&amp;lt;&lt;span style="color:#f92672">Switcher.React&lt;/span>/&amp;gt;
&amp;lt;&lt;span style="color:#f92672">Switcher.Vue&lt;/span>/&amp;gt;
&amp;lt;/&lt;span style="color:#f92672">Switcher&lt;/span>&amp;gt;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>隐式地将父组件的数据传递给子组件，其显示逻辑交由给子组件自行处理，代码的组织结构将会清晰很多。后续即使需求变动，数据的传递改变也并不需要我们操心（不需要一个子组件一个子组件地添加传递），只需要修改 &lt;code>Switcher&lt;/code> 子控件内部处理逻辑即可。&lt;/p>
&lt;p>那么要怎么实现这个&lt;strong>隐式数据传递&lt;/strong>呢？ 可以通过 &lt;a href="https://reactjs.org/docs/react-api.html#reactchildren">&lt;code>React.Children.map&lt;/code>&lt;/a> 和 &lt;a href="https://reactjs.org/docs/react-api.html#cloneelement">&lt;code>React.cloneElement&lt;/code>&lt;/a> 这两个 API 来实现。&lt;/p>
&lt;h3 id="reactchildrenmap-与-reactcloneelement">React.Children.map 与 React.cloneElement&lt;/h3>
&lt;p>在 &lt;code>render&lt;/code> 中我们可以使用 &lt;code>React.Children.map&lt;/code> 来获取到 &lt;code>Switcher&lt;/code> 中的子组件，然后通过 &lt;code>React.cloneElement&lt;/code> 对组件进行克隆及数据传递：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-jsx" data-lang="jsx">&lt;span style="color:#a6e22e">render&lt;/span>() {
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">React&lt;/span>.&lt;span style="color:#a6e22e">Children&lt;/span>.&lt;span style="color:#a6e22e">map&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">props&lt;/span>.&lt;span style="color:#a6e22e">children&lt;/span>, &lt;span style="color:#a6e22e">child&lt;/span> =&amp;gt;
&lt;span style="color:#a6e22e">React&lt;/span>.&lt;span style="color:#a6e22e">cloneElement&lt;/span>(&lt;span style="color:#a6e22e">child&lt;/span>, {
&lt;span style="color:#a6e22e">on&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">state&lt;/span>.&lt;span style="color:#a6e22e">on&lt;/span>,
&lt;span style="color:#a6e22e">toggle&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">toggle&lt;/span>,
}),
)
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样，即使我们在使用 &lt;code>Switcher.React&lt;/code> 和 &lt;code>Switcher.Vue&lt;/code> 时，没有显式地传递参数，子组件也能获取数据。&lt;/p>
&lt;blockquote>
&lt;p>这里 &lt;code>React.Children.map&lt;/code> 与 &lt;code>this.props.children.map&lt;/code> 并不等价，后者在只有一个子组件的时候，返回的不是数组，而是唯一的那个组件。&lt;/p>
&lt;/blockquote>
&lt;h3 id="reactchildrenmap-的局限性">React.Children.map 的局限性&lt;/h3>
&lt;p>上面代码有个问题是，如果出现了更多层级的子组件，那么参数传递只会到第一层。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-jsx" data-lang="jsx">&amp;lt;&lt;span style="color:#f92672">Switcher&lt;/span> &lt;span style="color:#a6e22e">selecting&lt;/span>&lt;span style="color:#f92672">=&lt;/span>{&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">props&lt;/span>.&lt;span style="color:#a6e22e">selecting&lt;/span>}&amp;gt;
&amp;lt;&lt;span style="color:#f92672">Switcher.React&lt;/span>/&amp;gt;
&amp;lt;&lt;span style="color:#f92672">div&lt;/span>&amp;gt;
&amp;lt;&lt;span style="color:#f92672">Switcher.Vue&lt;/span>/&amp;gt;
&amp;lt;/&lt;span style="color:#f92672">div&lt;/span>&amp;gt;
&amp;lt;/&lt;span style="color:#f92672">Switcher&lt;/span>&amp;gt;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样写会提示传递了错误的参数给 &lt;code>div&lt;/code>，因为我们 &lt;code>React.Children.map&lt;/code> 只能获取到第一层子组件（&lt;code>[Switcher.React, div]&lt;/code>）。&lt;/p>
&lt;p>那怎么办，难道要用递归？React 16.x 提供了新的 &lt;a href="https://reactjs.org/docs/context.html#when-to-use-context">Context&lt;/a> 可以很好地解决这个问题。&lt;/p>
&lt;p>Context 的使用方法很简单，首先创建一个 Context：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-jsx" data-lang="jsx">&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">selecting&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">SwitcherContext&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">React&lt;/span>.&lt;span style="color:#a6e22e">createContext&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>接着是 &lt;code>render&lt;/code>，既然我们不确定会有多少层的子组件，那么就直接将 &lt;code>this.props.children&lt;/code> 包裹在 &lt;code>Context.Provider&lt;/code> 中：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-jsx" data-lang="jsx">&amp;lt;&lt;span style="color:#f92672">SwitcherContext.Provider&lt;/span> &lt;span style="color:#a6e22e">value&lt;/span>&lt;span style="color:#f92672">=&lt;/span>{&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">props&lt;/span>.&lt;span style="color:#a6e22e">selecting&lt;/span>}&amp;gt;
{&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">props&lt;/span>.&lt;span style="color:#a6e22e">children&lt;/span>}
&amp;lt;/&lt;span style="color:#f92672">SwitcherContext.Provider&lt;/span>&amp;gt;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后改写我们的子组件数据获取方式，之前是通过 &lt;code>React.cloneElement&lt;/code> 来将数据通过 &lt;code>props&lt;/code> 传递到组件中，现在可以直接从 &lt;code>Context.Consumer&lt;/code> 中获取：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-jsx" data-lang="jsx">&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#a6e22e">Switcher&lt;/span>.&lt;span style="color:#a6e22e">React&lt;/span> &lt;span style="color:#f92672">=&lt;/span>() =&amp;gt; (
&amp;lt;&lt;span style="color:#f92672">SwitcherContext.Consumer&lt;/span>&amp;gt;
{ &lt;span style="color:#a6e22e">selecting&lt;/span> =&amp;gt; (
&amp;lt;&lt;span style="color:#f92672">Switch&lt;/span> &lt;span style="color:#a6e22e">on&lt;/span>&lt;span style="color:#f92672">=&lt;/span>{&lt;span style="color:#a6e22e">selecting&lt;/span> &lt;span style="color:#f92672">===&lt;/span> &lt;span style="color:#e6db74">&amp;#39;React&amp;#39;&lt;/span>}&amp;gt;&lt;span style="color:#a6e22e">React&lt;/span>&amp;lt;/&lt;span style="color:#f92672">Switch&lt;/span>&amp;gt;)
}
&amp;lt;/&lt;span style="color:#f92672">SwitcherContext.Consumer&lt;/span>&amp;gt;
)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>如此一来就完成了我们的改造。外部使用到 &lt;code>Switcher&lt;/code> 的地方没有任何变动，依然是：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-jsx" data-lang="jsx">&amp;lt;&lt;span style="color:#f92672">Switcher&lt;/span> &lt;span style="color:#a6e22e">selecting&lt;/span>&lt;span style="color:#f92672">=&lt;/span>{&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">props&lt;/span>.&lt;span style="color:#a6e22e">selecting&lt;/span>}&amp;gt;
&amp;lt;&lt;span style="color:#f92672">Switcher.React&lt;/span>/&amp;gt;
&amp;lt;&lt;span style="color:#f92672">div&lt;/span>&amp;gt;
&amp;lt;&lt;span style="color:#f92672">Switcher.Vue&lt;/span>/&amp;gt;
&amp;lt;/&lt;span style="color:#f92672">div&lt;/span>&amp;gt;
&amp;lt;/&lt;span style="color:#f92672">Switcher&lt;/span>&amp;gt;
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="相关资料">相关资料&lt;/h4>
&lt;ul>
&lt;li>&lt;a href="https://frontendmasters.com/courses/advanced-react-patterns/">Frontend Masters - Advanced React Patterns&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://reactjs.org/docs/context.html#when-to-use-context">React Context&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>TIL - Platforms State of the Union(WWDC 2019)</title><link>https://joeytat.github.io/posts/wwdc2019_platforms_state_of_the_union/</link><pubDate>Wed, 05 Jun 2019 00:00:00 +0000</pubDate><guid>https://joeytat.github.io/posts/wwdc2019_platforms_state_of_the_union/</guid><description>
&lt;h2 id="swiftui">SwiftUI&lt;/h2>
&lt;p>在 View 层级提供了四种特性:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Declarative
通过声明式的语句来描述 UI 布局, 样式, 动画等.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Automatic
可交互形动画, 动态字号, 夜间模式都可以通过配置来轻松实现.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Compositional
组合性. 各种控件都能极其方便地组合在一起, 远比 &lt;code>UIStackView&lt;/code> 方便.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-swift" data-lang="swift">VStack(alignment: .leading) {
Text(item.title)
Text(item.subtitle)
}
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>Consistent
自带 Reactive 特性. 将 Model 对象继承自 &lt;code>BindableObject&lt;/code>, 并且声明属性为 &lt;code>@State&lt;/code> 即可获得当属性改变时, UI 控件自动更新的效果.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>真的如果如此美好, 超级吃性能的 xib 和 storyboard 是不是可以退出舞台了.&lt;/p>
&lt;h2 id="xcode-11">Xcode 11&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>Live Development
直接在 Xcode Preview 中拖动控件即可生成对应的 SwiftUI 代码. 对应的修改 SwiftUI 代码也能实时在 Preview 中响应.&lt;/p>
&lt;p>Preview 还能通过提供一个 &lt;code>PreviewProvider&lt;/code> 来为其提供数据填充展示, 样式更改甚至循环语句来生成多个 Preview 同时查看控件在夜间模式和白日模式下不同的效果.&lt;/p>
&lt;p>Preview 部署在设备上也能热加载.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Package Management
Swift 终于有自己的 Package manage 了. 并且和 Xcode 进行了深度整合.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Minimap
代码在右侧会呈现类似 ctrl+6 的缩略图.
如果代码中写了 &lt;code>// MARK: -&lt;/code> &lt;code>// TODO: -&lt;/code> 等标记, 会更清晰地显示出来. 按住 cmd 会显示所有的标记.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>版本管理
可以直接在修改代码的位置查看到原来的版本.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Test Plan
同时测试各种平台各种设备.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="跨平台方案">跨平台方案&lt;/h2>
&lt;p>SwiftUI 支持跨平台, 同时支持 iOS, macOS, iPadOS. 那如何在 iOS App 的基础上创建一个 macOS App 呢? 只需要三个步骤:&lt;/p>
&lt;ol>
&lt;li>勾选上 deployment 中的 ✅ mac&lt;/li>
&lt;li>同时勾选上 ✅ iPad, 一个好的 iPad app, 就是一个好的 macOS app&lt;/li>
&lt;li>针对 macOS 的菜单, 快捷键等具有平台特殊性质的操作进行一些单独适配.&lt;/li>
&lt;/ol>
&lt;p>还对 catalina 的一些系统修改进行了介绍, 比如各种资源权限的收紧, 并且文件资源权限分成了两部分, 系统文件对于三方 app 变成了只读.&lt;/p>
&lt;blockquote>
&lt;p>后面都是各平台系统或新功能的介绍, 还是不继续施工了.&lt;/p>
&lt;/blockquote></description></item><item><title>TIL: 如何实现 JavaScript 函数参数必填的支持?</title><link>https://joeytat.github.io/posts/js_required_property/</link><pubDate>Mon, 03 Jun 2019 00:00:00 +0000</pubDate><guid>https://joeytat.github.io/posts/js_required_property/</guid><description>
&lt;p>JS 在 ES6 的中新增了函数参数指定默认值的支持:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js">&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">Greeting&lt;/span> &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#a6e22e">name&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Joeytat&amp;#34;&lt;/span>) =&amp;gt; {
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">`Hello &lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#a6e22e">name&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">`&lt;/span>)
}
&lt;span style="color:#a6e22e">Greeting&lt;/span>() &lt;span style="color:#75715e">// Hello Joeytat
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>那我们就可以利用这一特性, 将一个会抛出异常的方法作为默认参数传递.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js">&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">Greeting&lt;/span> &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#a6e22e">name&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#a6e22e">EmptyPropertyException&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;name&amp;#34;&lt;/span>)) =&amp;gt; {
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">`Hello &lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#a6e22e">name&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">`&lt;/span>)
}
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">EmptyPropertyException&lt;/span> &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#a6e22e">propertyName&lt;/span>) =&amp;gt; {
&lt;span style="color:#66d9ef">throw&lt;/span> Error(&lt;span style="color:#e6db74">`&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#a6e22e">propertyName&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74"> 为必填参数`&lt;/span>)
}
&lt;span style="color:#a6e22e">Greeting&lt;/span>() &lt;span style="color:#75715e">// 抛出异常: &amp;#34;Error: name 为必填参数&amp;#34;
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样如果没有传递参数就会抛出异常, 并且带有友好的提示了.&lt;/p></description></item></channel></rss>