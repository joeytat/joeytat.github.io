<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>翻译 - 图像优化 | Joeytat's Dev Log</title><meta name=keywords content="iOS,翻译"><meta name=description content="(通过啦～✌️)  发现 SwiftGG 在招人, 需要试译一篇文章. 花了半个下午加上午的时间来翻译, 于是就有了这篇. 不知道能不能通过."><meta name=author content><link rel=canonical href=https://joeytat.github.io/posts/optimizing_images/><meta name=google-site-verification content="G-83QEEKFELL"><link crossorigin=anonymous href=/assets/css/stylesheet.93f625d739f1d6a5c6f20c146bc6a8d26b233492b34b2220c54b12fd46a04ded.css integrity="sha256-k/Yl1znx1qXG8gwUa8ao0msjNJKzSyIgxUsS/UagTe0=" rel="preload stylesheet" as=style><link rel=icon href=https://joeytat.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://joeytat.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://joeytat.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://joeytat.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://joeytat.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://joeytat.github.io/posts/optimizing_images/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-83QEEKFELL"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-83QEEKFELL")}</script><meta property="og:url" content="https://joeytat.github.io/posts/optimizing_images/"><meta property="og:site_name" content="Joeytat's Dev Log"><meta property="og:title" content="翻译 - 图像优化"><meta property="og:description" content="(通过啦～✌️)  发现 SwiftGG 在招人, 需要试译一篇文章. 花了半个下午加上午的时间来翻译, 于是就有了这篇. 不知道能不能通过."><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-06-19T00:00:00+00:00"><meta property="article:modified_time" content="2019-06-19T00:00:00+00:00"><meta property="article:tag" content="IOS"><meta property="article:tag" content="翻译"><meta name=twitter:card content="summary"><meta name=twitter:title content="翻译 - 图像优化"><meta name=twitter:description content="(通过啦～✌️)  发现 SwiftGG 在招人, 需要试译一篇文章. 花了半个下午加上午的时间来翻译, 于是就有了这篇. 不知道能不能通过."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://joeytat.github.io/posts/"},{"@type":"ListItem","position":2,"name":"翻译 - 图像优化","item":"https://joeytat.github.io/posts/optimizing_images/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"翻译 - 图像优化","name":"翻译 - 图像优化","description":"(通过啦～✌️)  发现 SwiftGG 在招人, 需要试译一篇文章. 花了半个下午加上午的时间来翻译, 于是就有了这篇. 不知道能不能通过.","keywords":["iOS","翻译"],"articleBody":"翻译自 Optimizing Images by Jordan Morgan\n有句话说：最好的照相机就是在你身边的那台。 如果这句俗语是对的，那么毫无疑问地— iPhone 是这个星球上最重要的相机， 并且我们的业界也证明了这一点。\n在度假中? 如果没有在你的 Instagram Story 中留下几张照片，那就不算发生过。\n爆炸新闻? 立刻打开 Twitter 来查看哪些媒体在通过照片实时报道事件。\n等等。\n由于图像在各个平台无处不在的出现，在低性能且内存紧张的情况下展示它们，会很容易地造成失控。 如果我们知道 UIKit 底层到底发生了什么，为什么以及如何处理图像，那么我们可以节省大量的资源开销，并且逃脱无情的系统清除制裁。\n理论上来说 突击测验 - 这张我女儿的 266 KB 字节大小（并且还蛮时尚的）的照片，在一个 iOS App 中会展示需要用到多少内存?\n剧透一下 - 不是 266 KB，也不是 2.66 MB，而是大概 14 MB。\n为什么?\n本质上来说 iOS 申请内存是根据图像的尺寸 - 而图像的文件大小反而影响不大。 这张图片的尺寸是 1718 x 2048 像素。 假设每个像素会占用 4 个字节:\n1718 * 2048 * 4 / 1024 / 1024 = 13.42 MB 大约\n想象一下，如果你需要展示一个列表的用户信息，其中每一行都显示一个常见的圆形头像在左侧。 如果你觉得每一张图片都通过 ImageOptim 或者其他方式处理过就没问题，那就错了。 保守估计每一张头像是 256 x 256 大小，那依然会耗费大量内存。\n渲染路径 这就是说 - 明白底层是怎么回事是很划算的。 当你加载一张图片的时候，会经由这三步处理:\n1） 加载 - iOS 会获取到尚未解压的图片，然后开辟（我们的图片举例） 266 kb 的内存，目前为止没什么好担心的。\n2） 解码 - 现在 iOS 会将图片转化为 GPU 可以读取并且处理的数据。 现在是解压，在这一步就会产生我们上面提到的 14 MB 的内存开销。\n3） 渲染 - 按照字面意思理解，现在图片数据准备好了以任何方式进行渲染。 即使是放在 60 x 60 point 的 image view 中。\n解码阶段是大头。 在这里 iOS 会创建一个缓冲区 - 准确的说是图片缓冲区。 这里会将图像放在内存中。 这也是为什么，其内存占用会和图片尺寸挂钩而不是图片文件大小。 这就清晰地解释了，当处理图片时，为什么尺寸对于内存消耗如此重要。\n针对 UIImage， 当我们把从网络请求或者其他途径获取的图片数据传递给它时，它会将缓冲区的数据解码成数据声称的格式（比如 PNG 或者 JPEG）。 然而它就会在这停顿了。 由于渲染并非只是一次性操作，UIImage 会保留这个数据缓冲，这样它只需要解码一次。\n我们来扩展一下这个概念 - 对于任何 iOS App 来说一个完整的缓冲区就是其帧缓冲区。 这就是当 app 展示在屏幕上时，负责持有输出渲染内容的东西。 任何 iOS 设备上的显示硬件，都会使用其中的像素信息来点亮对应的物理屏幕像素。\n此处时间很重要。 为了达到每秒 60 帧如黄油般顺滑的滚动效果，在 app 的 window 及其 subviews 改变的时候（比如分配了一个 image 给 image view），帧缓冲区需要 UIKit 来渲染。 如果渲染慢了，就会掉帧。\n觉得只有 1/60 秒处理时间太短了? 具备 Pro Motion 的设备只会给 1/120 秒的时间。\n大小真的很重要 我们其实可以很轻松地观察到这步处理以及内存时如何被消耗掉的。 我创建了一个实验 app，用 image view 来展示了我女儿的照片。\nlet filePath = Bundle.main.path(forResource:\"baylor\"，ofType: \"jpg\")! let url = NSURL(fileURLWithPath: filePath) let fileImage = UIImage(contentsOfFile: filePath) // Image view let imageView = UIImageView(image: fileImage) imageView.translatesAutoresizingMaskIntoConstraints = false imageView.contentMode = .scaleAspectFit imageView.widthAnchor.constraint(equalToConstant: 300).isActive = true imageView.heightAnchor.constraint(equalToConstant: 400).isActive = true view.addSubview(imageView) imageView.centerXAnchor.constraint(equalTo: view.centerXAnchor).isActive = true imageView.centerYAnchor.constraint(equalTo: view.centerYAnchor).isActive = true 这里我们只是为了演示场景，在生产环境中请谨慎使用强制解包。\n上面的代码运行起来时这样:\n虽然我们使用了一个小得多的 Image View 来展示图片，但通过 LLDB 我们可以查看到图片实际的尺寸。\n\u003cUIImage: 0x600003d41a40\u003e，{1718，2048} 记住，这是点表示。 所以如果我使用的是 3x 或者 2x 设备，这个数字需要更大一些。 我们可以使用 vmmap 来确定这张图片是否真的占用了 14 MB。\nvmmap --summary baylor.memgraph 有几个东西引起了注意（为了简洁只截出了部分输出）:\nPhysical footprint: 69.5M Physical footprint (peak): 69.7M 接近 70 MB 给了我们一个很好的参考来确定我们的重构是否有效。 如果我们通过 grep 命令来筛选 Image IO，我们也能够看到图片的开销。\nvmmap --summary baylor.memgraph | grep \"Image IO\" Image IO 13.4M 13.4M 13.4M 0K 0K 0K 0K 2 啊哈 - 这里就有接近 14 MB 的脏内存。 如同我们在餐巾纸背面写下的公式计算的那样。 背景补充一下，这是一个终端的屏幕截图，清楚地显示了每一列的含义。 （由于他们被 grep 命令给省略掉了）\n所以很明确了，此刻我们在 300 x 400 的 image view 中也依然付出了图像的完整开销。 图像的大小是很关键，但这并不是唯一重要的点。\n色域 你所请求的内存消耗有一部分源于另一个重要因素 - 色域。 在上面的例子中我们做了一个假设，而这个假设并不适用于大多数 iPhone - 也就是图像采用的是 sRGB 格式。 每个像素 4 个字节对应的是红，蓝，绿以及透明。\n如果你使用的是支持广色域格式的设备（iPhone 8+ 或 iPhone X）进行拍摄，那就可以肯定数字会加倍了。 当然了，反过来也一样，Metal 支持使用 Alpha 8 格式，就像其名字描述的那样只有单一通道。\n这里有非常多需要考虑的东西。 这也是为什么你应该使用 UIGraphicsImageRenderer 而不是 UIGraphicsBeginImageContextWithOptions。 后者会一直使用 sRGB，这也意味着你会丢失广色域格式，如果你 想要的话，或是错失节省开销的机会。 在 iOS 12 之后，UIGraphicsImageRenderer 会自动帮你选择正确的方案。\n最后别忘记了，很多图片并不是拍摄出来的，而是通过绘图绘制的。 这里并不是刻意重复我写过的东西，只是怕你之前错过了:\nlet circleSize = CGSize(width: 60，height: 60) UIGraphicsBeginImageContextWithOptions(circleSize，true，0) // Draw a circle let ctx = UIGraphicsGetCurrentContext()! UIColor.red.setFill() ctx.setFillColor(UIColor.red.cgColor) ctx.addEllipse(in: CGRect(x: 0，y: 0，width: circleSize.width，height: circleSize.height)) ctx.drawPath(using: .fill) let circleImage = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() 这个圆形图片使用的是每个像素 4 字节格式。 如果你使用 UIGraphicsImageRenderer 那么渲染器会自动选择合适的格式，为每个像素节省 75% 的内存消耗。\nlet circleSize = CGSize(width: 60，height: 60) let renderer = UIGraphicsImageRenderer(bounds: CGRect(x: 0，y: 0，width: circleSize.width，height: circleSize.height)) let circleImage = renderer.image{ ctx in UIColor.red.setFill() ctx.cgContext.setFillColor(UIColor.red.cgColor) ctx.cgContext.addEllipse(in: CGRect(x: 0，y: 0，width: circleSize.width，height: circleSize.height)) ctx.cgContext.drawPath(using: .fill) } 缩小分辨率 vs 缩小采样 让我们跳过简单绘图的场景 - 还有非常多与图像相关的内存问题，源自真实的摄影图片。 比如人像，风景照。\n对于一些工程师来说，他们有理由（逻辑上也说得过去）相信，通过 UIImage 简单地缩小图像尺寸就足够了。 但由于上面提及的原因，这通常来说不够，而且据 Apple 员工 Kyle Howarth 描述这也没有那么高效。\n如我们之前讨论渲染路径时提到的，UIImage 会产生内存问题的主要原因是它会将原始图像加载到内存中进行解压。 理想状态下，我们应该减少图像缓存区的大小。\n幸运的是，我们其实可以只以调整图像文件的大小为代价，来影响图像内存大小。 通常人们会假设这就是系统如何实现的，但其实不是。\n让我们用点底层 API 来缩小采样试试:\nlet imageSource = CGImageSourceCreateWithURL(url，nil)! let options: [NSString:Any] = [kCGImageSourceThumbnailMaxPixelSize:400， kCGImageSourceCreateThumbnailFromImageAlways:true] if let scaledImage = CGImageSourceCreateThumbnailAtIndex(imageSource，0，options as CFDictionary) { let imageView = UIImageView(image: UIImage(cgImage: scaledImage)) imageView.translatesAutoresizingMaskIntoConstraints = false imageView.contentMode = .scaleAspectFit imageView.widthAnchor.constraint(equalToConstant: 300).isActive = true imageView.heightAnchor.constraint(equalToConstant: 400).isActive = true view.addSubview(imageView) imageView.centerXAnchor.constraint(equalTo: view.centerXAnchor).isActive = true imageView.centerYAnchor.constraint(equalTo: view.centerYAnchor).isActive = true } 再次运行，我们得到的显示效果和之前一样。 但在这里，我们使用了 CGImageSourceCreateThumbnailAtIndex() 而不是直接将原始图像放在 image view 中。 真相大白的时刻到了，让我们通过 vmmap 来看看我们的优化是否奏效（再一次，为了简洁只截取了部分）:\nvmmap -summary baylorOptimized.memgraph Physical footprint: 56.3M Physical footprint (peak): 56.7M 节省的开销都统计在了一起。 如果我们将之前的 69.5M 和现在的 56.3M 进行对比，我们节约了 13.2M。 这是个很大的节省，几乎是整个图片的大小。\n再进一步，你可以根据你的需要通过各种选项来打磨。 在 WWDC 2018 Session 219 “Images and Graphics Best Practices” 中，Apple 工程师 Kyle Sluder 通过使用 kCGImageSourceShouldCacheImmediately 标记来展示了一个很有趣的技巧控制解码:\nfunc downsampleImage(at URL:NSURL，maxSize:Float) -\u003e UIImage { let sourceOptions = [kCGImageSourceShouldCache:false] as CFDictionary let source = CGImageSourceCreateWithURL(URL as CFURL，sourceOptions)! let downsampleOptions = [kCGImageSourceCreateThumbnailFromImageAlways:true， kCGImageSourceThumbnailMaxPixelSize:maxSize kCGImageSourceShouldCacheImmediately:true， kCGImageSourceCreateThumbnailWithTransform:true， ] as CFDictionary let downsampledImage = CGImageSourceCreateThumbnailAtIndex(source, 0, downsampleOptions)! return UIImage(cgImage: downsampledImage) } Core Graphics 并不会参与解码图片，直到你明确需要使用缩略图的时候。 并且需要注意传入 kCGImageSourceCreateThumbnailMaxPixelSize，就像我们做的上面两个例子那样。 如果你不传，那么你会得到一个和原始图像一样大小的缩略图。 据文档描述:\n“…如果没有指定最大像素大小，那么缩略图就会是完整的图片大小，这可能不是你想要的。” “…if a maximum pixel size isn’t specified, then the thumbnail will be the size of the full image, which probably isn’t what you want.”\n那么这里发生了什么? 简单来说，我们通过在缩略图上使用了缩小部分图片的等式，创建了一个小得多的解码图像缓冲区。 回忆一下之前提到的渲染路径，第一步（加载）现在我们没有创建一个原始图像大小的缓冲区，而是一个 image view 显示大小的缓冲区。\n想要一个这篇文章的太长不读版本? 找机会降低图像采样，而不是使用 UIImage 缩小图片。\n附加部分 我个人在 Tandem 中配合着 prefetch API （iOS 11） 使用了这种技术。 但要记住即使我们在真正使用 table view 或者 collection view 之前这样做，我们在解码图片的时候，内部依然会带来的一个 CPU 使用量的高峰。\n尽管 iOS 在面对持续性能消耗时有很高效的处理方案，但在我们的例子中，可能是时不时才会产生这样的高峰。 所以在处理这种问题的时候，最好把希望寄予你自己创建的队列。 另一个优势是，这样还能将解码移动到后台处理。\n快遮住眼睛，我业余项目中的 Objective-C 代码要出来了:\n// 用你自己的队列而不是 global 队列可以避免潜在的线程爆炸 - (void)tableView:(UITableView *)tableView prefetchRowsAtIndexPaths:(NSArray\u003cNSIndexPath *\u003e *)indexPaths { if (self.downsampledImage != nil || self.listItem.mediaAssetData == nil) return; NSIndexPath *mediaIndexPath = [NSIndexPath indexPathForRow:0 inSection:SECTION_MEDIA]; if ([indexPaths containsObject:mediaIndexPath]) { CGFloat scale = tableView.traitCollection.displayScale; CGFloat maxPixelSize = (tableView.width - SSSpacingJumboMargin) * scale; dispatch_async(self.downsampleQueue，^{ // 缩减采样 self.downsampledImage = [UIImage downsampledImageFromData:self.listItem.mediaAssetData scale:scale maxPixelSize:maxPixelSize]; dispatch_async(dispatch_get_main_queue()，^ { self.listItem.downsampledMediaImage = self.downsampledImage; }); }); } } 注意在你有大量的原始图像（raw image）资源时使用资源管理（asset catalogs）。 因为它会帮你管理缓存大小（还有其他很多的优势）\n想要了解更多关于图像和内存管理的信息，可以关注这些信息量巨大的 WWDC 18 session:\niOS Memory Deep Dive Images and Graphics Best Practices 总结一下 你无法察觉你不知道的东西。 就编程来说，你基本上相当于报名参加了一个需要持续跑每小时 10，000 米以跟上创新和变革的职业生涯。 这意味着…有大量的 API，框架，设计模式或者优化方案你并不知晓。\n在图像领域尤其是这样。 大多数时间，你可能只是初始化了一个 UIImageView 然后放进了一些好看的像素，就过了。 我知道啦，摩尔定理什么的。 现在这些电话运行速度很快，而且有数 G 的内存，并且我们把人类运送到了月球上，都只用了一台不到 100K 内存的电脑。\n但是和魔鬼共舞不会长久，他必然需要滋养他的角。 别让系统杀掉你的应用，只是因为你用了 1G 内存来展示一张自拍照。 但愿这些知识和技巧可以将你拯救于崩溃日志。\n下次见 ✌️。\n","wordCount":"738","inLanguage":"en","datePublished":"2019-06-19T00:00:00Z","dateModified":"2019-06-19T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://joeytat.github.io/posts/optimizing_images/"},"publisher":{"@type":"Organization","name":"Joeytat's Dev Log","logo":{"@type":"ImageObject","url":"https://joeytat.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://joeytat.github.io/ accesskey=h title="Dev Log (Alt + H)"><img src=https://joeytat.github.io/apple-touch-icon.png alt aria-label=logo height=35>Dev Log</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://joeytat.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=https://joeytat.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://joeytat.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://joeytat.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">翻译 - 图像优化</h1><div class=post-description>(通过啦～✌️) 发现 SwiftGG 在招人, 需要试译一篇文章. 花了半个下午加上午的时间来翻译, 于是就有了这篇. 不知道能不能通过.</div><div class=post-meta><span title='2019-06-19 00:00:00 +0000 UTC'>June 19, 2019</span></div></header><div class=post-content><p>翻译自 <a href=https://www.swiftjectivec.com/optimizing-images/>Optimizing Images</a> by <a href=https://twitter.com/jordanmorgan10>Jordan Morgan</a></p><p>有句话说：最好的照相机就是在你身边的那台。 如果这句俗语是对的，那么毫无疑问地— iPhone 是这个星球上最重要的相机， 并且我们的业界也证明了这一点。</p><p>在度假中? 如果没有在你的 Instagram Story 中留下几张照片，那就不算发生过。</p><p>爆炸新闻? 立刻打开 Twitter 来查看哪些媒体在通过照片实时报道事件。</p><p>等等。</p><p>由于图像在各个平台无处不在的出现，在低性能且内存紧张的情况下展示它们，会很容易地造成失控。 如果我们知道 UIKit 底层到底发生了什么，为什么以及如何处理图像，那么我们可以节省大量的资源开销，并且逃脱无情的系统清除制裁。</p><h2 id=理论上来说>理论上来说<a hidden class=anchor aria-hidden=true href=#理论上来说>#</a></h2><p>突击测验 - 这张我女儿的 266 KB 字节大小（并且还蛮时尚的）的照片，在一个 iOS App 中会展示需要用到多少内存?</p><p><img alt=Baylor loading=lazy src=https://www.swiftjectivec.com/assets/images/baylor.jpg></p><p>剧透一下 - 不是 266 KB，也不是 2.66 MB，而是大概 14 MB。</p><p>为什么?</p><p>本质上来说 iOS 申请内存是根据图像的尺寸 - 而图像的文件大小反而影响不大。 这张图片的尺寸是 1718 x 2048 像素。 假设每个像素会占用 4 个字节:</p><blockquote><p>1718 * 2048 * 4 / 1024 / 1024 = 13.42 MB 大约</p></blockquote><p>想象一下，如果你需要展示一个列表的用户信息，其中每一行都显示一个常见的圆形头像在左侧。 如果你觉得每一张图片都通过 ImageOptim 或者其他方式处理过就没问题，那就错了。 保守估计每一张头像是 256 x 256 大小，那依然会耗费大量内存。</p><h2 id=渲染路径>渲染路径<a hidden class=anchor aria-hidden=true href=#渲染路径>#</a></h2><p>这就是说 - 明白底层是怎么回事是很划算的。 当你加载一张图片的时候，会经由这三步处理:</p><p>1） 加载 - iOS 会获取到尚未解压的图片，然后开辟（我们的图片举例） 266 kb 的内存，目前为止没什么好担心的。</p><p>2） 解码 - 现在 iOS 会将图片转化为 GPU 可以读取并且处理的数据。 现在是解压，在这一步就会产生我们上面提到的 14 MB 的内存开销。</p><p>3） 渲染 - 按照字面意思理解，现在图片数据准备好了以任何方式进行渲染。 即使是放在 60 x 60 point 的 image view 中。</p><p>解码阶段是大头。 在这里 iOS 会创建一个缓冲区 - 准确的说是图片缓冲区。 这里会将图像放在内存中。 这也是为什么，其内存占用会和图片尺寸挂钩而不是图片文件大小。 这就清晰地解释了，当处理图片时，为什么尺寸对于内存消耗如此重要。</p><p>针对 <code>UIImage</code>， 当我们把从网络请求或者其他途径获取的图片数据传递给它时，它会将缓冲区的数据解码成数据声称的格式（比如 PNG 或者 JPEG）。 然而它就会在这停顿了。 由于渲染并非只是一次性操作，<code>UIImage</code> 会保留这个数据缓冲，这样它只需要解码一次。</p><p>我们来扩展一下这个概念 - 对于任何 iOS App 来说一个完整的缓冲区就是其帧缓冲区。 这就是当 app 展示在屏幕上时，负责持有输出渲染内容的东西。 任何 iOS 设备上的显示硬件，都会使用其中的像素信息来点亮对应的物理屏幕像素。</p><p>此处时间很重要。 为了达到每秒 60 帧如黄油般顺滑的滚动效果，在 app 的 window 及其 subviews 改变的时候（比如分配了一个 image 给 image view），帧缓冲区需要 UIKit 来渲染。 如果渲染慢了，就会掉帧。</p><blockquote><p>觉得只有 1/60 秒处理时间太短了? 具备 Pro Motion 的设备只会给 1/120 秒的时间。</p></blockquote><h2 id=大小真的很重要>大小真的很重要<a hidden class=anchor aria-hidden=true href=#大小真的很重要>#</a></h2><p>我们其实可以很轻松地观察到这步处理以及内存时如何被消耗掉的。 我创建了一个实验 app，用 image view 来展示了我女儿的照片。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=kd>let</span> <span class=nv>filePath</span> <span class=p>=</span> <span class=n>Bundle</span><span class=p>.</span><span class=n>main</span><span class=p>.</span><span class=n>path</span><span class=p>(</span><span class=n>forResource</span><span class=p>:</span><span class=s>&#34;baylor&#34;</span><span class=err>，</span><span class=n>ofType</span><span class=p>:</span> <span class=s>&#34;jpg&#34;</span><span class=p>)</span><span class=o>!</span>
</span></span><span class=line><span class=cl><span class=kd>let</span> <span class=nv>url</span> <span class=p>=</span> <span class=n>NSURL</span><span class=p>(</span><span class=n>fileURLWithPath</span><span class=p>:</span> <span class=n>filePath</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=kd>let</span> <span class=nv>fileImage</span> <span class=p>=</span> <span class=n>UIImage</span><span class=p>(</span><span class=n>contentsOfFile</span><span class=p>:</span> <span class=n>filePath</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Image view</span>
</span></span><span class=line><span class=cl><span class=kd>let</span> <span class=nv>imageView</span> <span class=p>=</span> <span class=n>UIImageView</span><span class=p>(</span><span class=n>image</span><span class=p>:</span> <span class=n>fileImage</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>imageView</span><span class=p>.</span><span class=n>translatesAutoresizingMaskIntoConstraints</span> <span class=p>=</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl><span class=n>imageView</span><span class=p>.</span><span class=n>contentMode</span> <span class=p>=</span> <span class=p>.</span><span class=n>scaleAspectFit</span>
</span></span><span class=line><span class=cl><span class=n>imageView</span><span class=p>.</span><span class=n>widthAnchor</span><span class=p>.</span><span class=n>constraint</span><span class=p>(</span><span class=n>equalToConstant</span><span class=p>:</span> <span class=mi>300</span><span class=p>).</span><span class=n>isActive</span> <span class=p>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl><span class=n>imageView</span><span class=p>.</span><span class=n>heightAnchor</span><span class=p>.</span><span class=n>constraint</span><span class=p>(</span><span class=n>equalToConstant</span><span class=p>:</span> <span class=mi>400</span><span class=p>).</span><span class=n>isActive</span> <span class=p>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>view</span><span class=p>.</span><span class=n>addSubview</span><span class=p>(</span><span class=n>imageView</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>imageView</span><span class=p>.</span><span class=n>centerXAnchor</span><span class=p>.</span><span class=n>constraint</span><span class=p>(</span><span class=n>equalTo</span><span class=p>:</span> <span class=n>view</span><span class=p>.</span><span class=n>centerXAnchor</span><span class=p>).</span><span class=n>isActive</span> <span class=p>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl><span class=n>imageView</span><span class=p>.</span><span class=n>centerYAnchor</span><span class=p>.</span><span class=n>constraint</span><span class=p>(</span><span class=n>equalTo</span><span class=p>:</span> <span class=n>view</span><span class=p>.</span><span class=n>centerYAnchor</span><span class=p>).</span><span class=n>isActive</span> <span class=p>=</span> <span class=kc>true</span>
</span></span></code></pre></div><blockquote><p>这里我们只是为了演示场景，在生产环境中请谨慎使用强制解包。</p></blockquote><p>上面的代码运行起来时这样:</p><p><img alt=Baylor loading=lazy src=https://www.swiftjectivec.com/assets/images/baylorPhone.jpg></p><p>虽然我们使用了一个小得多的 Image View 来展示图片，但通过 LLDB 我们可以查看到图片实际的尺寸。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=p>&lt;</span><span class=n>UIImage</span><span class=p>:</span> <span class=mh>0x600003d41a40</span><span class=p>&gt;</span><span class=err>，</span><span class=p>{</span><span class=mi>1718</span><span class=err>，</span><span class=mi>2048</span><span class=p>}</span>
</span></span></code></pre></div><p>记住，这是点表示。 所以如果我使用的是 3x 或者 2x 设备，这个数字需要更大一些。 我们可以使用 vmmap 来确定这张图片是否真的占用了 14 MB。</p><pre tabindex=0><code>vmmap --summary baylor.memgraph
</code></pre><p>有几个东西引起了注意（为了简洁只截出了部分输出）:</p><pre tabindex=0><code>Physical footprint:         69.5M
Physical footprint (peak):  69.7M
</code></pre><p>接近 70 MB 给了我们一个很好的参考来确定我们的重构是否有效。 如果我们通过 grep 命令来筛选 Image IO，我们也能够看到图片的开销。</p><pre tabindex=0><code>vmmap --summary baylor.memgraph | grep &#34;Image IO&#34;

Image IO  13.4M   13.4M   13.4M    0K  0K  0K   0K  2 
</code></pre><p>啊哈 - 这里就有接近 14 MB 的脏内存。 如同我们在餐巾纸背面写下的公式计算的那样。 背景补充一下，这是一个终端的屏幕截图，清楚地显示了每一列的含义。 （由于他们被 grep 命令给省略掉了）</p><p><img loading=lazy src=https://www.swiftjectivec.com/assets/images/vmmap.jpg></p><p>所以很明确了，此刻我们在 300 x 400 的 image view 中也依然付出了图像的完整开销。 图像的大小是很关键，但这并不是唯一重要的点。</p><h2 id=色域>色域<a hidden class=anchor aria-hidden=true href=#色域>#</a></h2><p>你所请求的内存消耗有一部分源于另一个重要因素 - 色域。 在上面的例子中我们做了一个假设，而这个假设并不适用于大多数 iPhone - 也就是图像采用的是 sRGB 格式。 每个像素 4 个字节对应的是红，蓝，绿以及透明。</p><p>如果你使用的是支持广色域格式的设备（iPhone 8+ 或 iPhone X）进行拍摄，那就可以肯定数字会加倍了。 当然了，反过来也一样，Metal 支持使用 Alpha 8 格式，就像其名字描述的那样只有单一通道。</p><p>这里有非常多需要考虑的东西。 这也是为什么你应该使用 <a href=https://swiftjectivec.com/UIGraphicsImageRenderer>UIGraphicsImageRenderer</a> 而不是 <code>UIGraphicsBeginImageContextWithOptions</code>。 后者会<strong>一直</strong>使用 sRGB，这也意味着你会丢失广色域格式，如果你 <a href=https://instagram-engineering.com/bringing-wide-color-to-instagram-5a5481802d7d>想要的话</a>，或是错失节省开销的机会。 在 iOS 12 之后，<code>UIGraphicsImageRenderer</code> 会自动帮你选择正确的方案。</p><p>最后别忘记了，很多图片并不是拍摄出来的，而是通过绘图绘制的。 这里并不是刻意重复我写过的东西，只是怕你之前错过了:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=kd>let</span> <span class=nv>circleSize</span> <span class=p>=</span> <span class=n>CGSize</span><span class=p>(</span><span class=n>width</span><span class=p>:</span> <span class=mi>60</span><span class=err>，</span><span class=n>height</span><span class=p>:</span> <span class=mi>60</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>UIGraphicsBeginImageContextWithOptions</span><span class=p>(</span><span class=n>circleSize</span><span class=err>，</span><span class=kc>true</span><span class=err>，</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Draw a circle</span>
</span></span><span class=line><span class=cl><span class=kd>let</span> <span class=nv>ctx</span> <span class=p>=</span> <span class=n>UIGraphicsGetCurrentContext</span><span class=p>()</span><span class=o>!</span>
</span></span><span class=line><span class=cl><span class=n>UIColor</span><span class=p>.</span><span class=n>red</span><span class=p>.</span><span class=n>setFill</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>ctx</span><span class=p>.</span><span class=n>setFillColor</span><span class=p>(</span><span class=n>UIColor</span><span class=p>.</span><span class=n>red</span><span class=p>.</span><span class=n>cgColor</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>ctx</span><span class=p>.</span><span class=n>addEllipse</span><span class=p>(</span><span class=k>in</span><span class=p>:</span> <span class=n>CGRect</span><span class=p>(</span><span class=n>x</span><span class=p>:</span> <span class=mi>0</span><span class=err>，</span><span class=n>y</span><span class=p>:</span> <span class=mi>0</span><span class=err>，</span><span class=n>width</span><span class=p>:</span> <span class=n>circleSize</span><span class=p>.</span><span class=n>width</span><span class=err>，</span><span class=n>height</span><span class=p>:</span> <span class=n>circleSize</span><span class=p>.</span><span class=n>height</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=n>ctx</span><span class=p>.</span><span class=n>drawPath</span><span class=p>(</span><span class=n>using</span><span class=p>:</span> <span class=p>.</span><span class=n>fill</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>let</span> <span class=nv>circleImage</span> <span class=p>=</span> <span class=n>UIGraphicsGetImageFromCurrentImageContext</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>UIGraphicsEndImageContext</span><span class=p>()</span>
</span></span></code></pre></div><p>这个圆形图片使用的是每个像素 4 字节格式。 如果你使用 <code>UIGraphicsImageRenderer</code> 那么渲染器会自动选择合适的格式，为每个像素节省 75% 的内存消耗。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=kd>let</span> <span class=nv>circleSize</span> <span class=p>=</span> <span class=n>CGSize</span><span class=p>(</span><span class=n>width</span><span class=p>:</span> <span class=mi>60</span><span class=err>，</span><span class=n>height</span><span class=p>:</span> <span class=mi>60</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=kd>let</span> <span class=nv>renderer</span> <span class=p>=</span> <span class=n>UIGraphicsImageRenderer</span><span class=p>(</span><span class=n>bounds</span><span class=p>:</span> <span class=n>CGRect</span><span class=p>(</span><span class=n>x</span><span class=p>:</span> <span class=mi>0</span><span class=err>，</span><span class=n>y</span><span class=p>:</span> <span class=mi>0</span><span class=err>，</span><span class=n>width</span><span class=p>:</span> <span class=n>circleSize</span><span class=p>.</span><span class=n>width</span><span class=err>，</span><span class=n>height</span><span class=p>:</span> <span class=n>circleSize</span><span class=p>.</span><span class=n>height</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>let</span> <span class=nv>circleImage</span> <span class=p>=</span> <span class=n>renderer</span><span class=p>.</span><span class=n>image</span><span class=p>{</span> <span class=n>ctx</span> <span class=k>in</span>
</span></span><span class=line><span class=cl>    <span class=n>UIColor</span><span class=p>.</span><span class=n>red</span><span class=p>.</span><span class=n>setFill</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>ctx</span><span class=p>.</span><span class=n>cgContext</span><span class=p>.</span><span class=n>setFillColor</span><span class=p>(</span><span class=n>UIColor</span><span class=p>.</span><span class=n>red</span><span class=p>.</span><span class=n>cgColor</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>ctx</span><span class=p>.</span><span class=n>cgContext</span><span class=p>.</span><span class=n>addEllipse</span><span class=p>(</span><span class=k>in</span><span class=p>:</span> <span class=n>CGRect</span><span class=p>(</span><span class=n>x</span><span class=p>:</span> <span class=mi>0</span><span class=err>，</span><span class=n>y</span><span class=p>:</span> <span class=mi>0</span><span class=err>，</span><span class=n>width</span><span class=p>:</span> <span class=n>circleSize</span><span class=p>.</span><span class=n>width</span><span class=err>，</span><span class=n>height</span><span class=p>:</span> <span class=n>circleSize</span><span class=p>.</span><span class=n>height</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=n>ctx</span><span class=p>.</span><span class=n>cgContext</span><span class=p>.</span><span class=n>drawPath</span><span class=p>(</span><span class=n>using</span><span class=p>:</span> <span class=p>.</span><span class=n>fill</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=缩小分辨率-vs-缩小采样>缩小分辨率 vs 缩小采样<a hidden class=anchor aria-hidden=true href=#缩小分辨率-vs-缩小采样>#</a></h2><p>让我们跳过简单绘图的场景 - 还有非常多与图像相关的内存问题，源自真实的摄影图片。 比如人像，风景照。</p><p>对于一些工程师来说，他们有理由（逻辑上也说得过去）相信，通过 <code>UIImage</code> 简单地缩小图像尺寸就足够了。 但由于上面提及的原因，这通常来说不够，而且据 Apple 员工 Kyle Howarth 描述这也没有那么高效。</p><p>如我们之前讨论渲染路径时提到的，<code>UIImage</code> 会产生内存问题的主要原因是它会将原始图像加载到内存中进行解压。 理想状态下，我们应该减少图像缓存区的大小。</p><p>幸运的是，我们其实可以只以调整图像文件的大小为代价，来影响图像内存大小。 通常人们会假设这就是系统如何实现的，但其实不是。</p><p>让我们用点底层 API 来缩小采样试试:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=kd>let</span> <span class=nv>imageSource</span> <span class=p>=</span> <span class=n>CGImageSourceCreateWithURL</span><span class=p>(</span><span class=n>url</span><span class=err>，</span><span class=kc>nil</span><span class=p>)</span><span class=o>!</span>
</span></span><span class=line><span class=cl><span class=kd>let</span> <span class=nv>options</span><span class=p>:</span> <span class=p>[</span><span class=n>NSString</span><span class=p>:</span><span class=nb>Any</span><span class=p>]</span> <span class=p>=</span> <span class=p>[</span><span class=n>kCGImageSourceThumbnailMaxPixelSize</span><span class=p>:</span><span class=mi>400</span><span class=err>，</span>
</span></span><span class=line><span class=cl>                               <span class=n>kCGImageSourceCreateThumbnailFromImageAlways</span><span class=p>:</span><span class=kc>true</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=kd>let</span> <span class=nv>scaledImage</span> <span class=p>=</span> <span class=n>CGImageSourceCreateThumbnailAtIndex</span><span class=p>(</span><span class=n>imageSource</span><span class=err>，</span><span class=mi>0</span><span class=err>，</span><span class=n>options</span> <span class=k>as</span> <span class=n>CFDictionary</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>let</span> <span class=nv>imageView</span> <span class=p>=</span> <span class=n>UIImageView</span><span class=p>(</span><span class=n>image</span><span class=p>:</span> <span class=n>UIImage</span><span class=p>(</span><span class=n>cgImage</span><span class=p>:</span> <span class=n>scaledImage</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>imageView</span><span class=p>.</span><span class=n>translatesAutoresizingMaskIntoConstraints</span> <span class=p>=</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>    <span class=n>imageView</span><span class=p>.</span><span class=n>contentMode</span> <span class=p>=</span> <span class=p>.</span><span class=n>scaleAspectFit</span>
</span></span><span class=line><span class=cl>    <span class=n>imageView</span><span class=p>.</span><span class=n>widthAnchor</span><span class=p>.</span><span class=n>constraint</span><span class=p>(</span><span class=n>equalToConstant</span><span class=p>:</span> <span class=mi>300</span><span class=p>).</span><span class=n>isActive</span> <span class=p>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>    <span class=n>imageView</span><span class=p>.</span><span class=n>heightAnchor</span><span class=p>.</span><span class=n>constraint</span><span class=p>(</span><span class=n>equalToConstant</span><span class=p>:</span> <span class=mi>400</span><span class=p>).</span><span class=n>isActive</span> <span class=p>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>view</span><span class=p>.</span><span class=n>addSubview</span><span class=p>(</span><span class=n>imageView</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>imageView</span><span class=p>.</span><span class=n>centerXAnchor</span><span class=p>.</span><span class=n>constraint</span><span class=p>(</span><span class=n>equalTo</span><span class=p>:</span> <span class=n>view</span><span class=p>.</span><span class=n>centerXAnchor</span><span class=p>).</span><span class=n>isActive</span> <span class=p>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>    <span class=n>imageView</span><span class=p>.</span><span class=n>centerYAnchor</span><span class=p>.</span><span class=n>constraint</span><span class=p>(</span><span class=n>equalTo</span><span class=p>:</span> <span class=n>view</span><span class=p>.</span><span class=n>centerYAnchor</span><span class=p>).</span><span class=n>isActive</span> <span class=p>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>再次运行，我们得到的显示效果和之前一样。 但在这里，我们使用了 <code>CGImageSourceCreateThumbnailAtIndex()</code> 而不是直接将原始图像放在 image view 中。 真相大白的时刻到了，让我们通过 <code>vmmap</code> 来看看我们的优化是否奏效（再一次，为了简洁只截取了部分）:</p><pre tabindex=0><code>vmmap -summary baylorOptimized.memgraph

Physical footprint:         56.3M
Physical footprint (peak):  56.7M
</code></pre><p>节省的开销都统计在了一起。 如果我们将之前的 69.5M 和现在的 56.3M 进行对比，我们节约了 13.2M。 这是个很大的节省，几乎是整个图片的大小。</p><p>再进一步，你可以根据你的需要通过各种选项来打磨。 在 WWDC 2018 Session 219 &ldquo;Images and Graphics Best Practices&rdquo; 中，Apple 工程师 Kyle Sluder 通过使用 <code>kCGImageSourceShouldCacheImmediately</code> 标记来展示了一个很有趣的技巧控制解码:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=kd>func</span> <span class=nf>downsampleImage</span><span class=p>(</span><span class=n>at</span> <span class=n>URL</span><span class=p>:</span><span class=n>NSURL</span><span class=err>，</span><span class=n>maxSize</span><span class=p>:</span><span class=nb>Float</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=n>UIImage</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>let</span> <span class=nv>sourceOptions</span> <span class=p>=</span> <span class=p>[</span><span class=n>kCGImageSourceShouldCache</span><span class=p>:</span><span class=kc>false</span><span class=p>]</span> <span class=k>as</span> <span class=n>CFDictionary</span>
</span></span><span class=line><span class=cl>    <span class=kd>let</span> <span class=nv>source</span> <span class=p>=</span> <span class=n>CGImageSourceCreateWithURL</span><span class=p>(</span><span class=n>URL</span> <span class=k>as</span> <span class=n>CFURL</span><span class=err>，</span><span class=n>sourceOptions</span><span class=p>)</span><span class=o>!</span>
</span></span><span class=line><span class=cl>    <span class=kd>let</span> <span class=nv>downsampleOptions</span> <span class=p>=</span> <span class=p>[</span><span class=n>kCGImageSourceCreateThumbnailFromImageAlways</span><span class=p>:</span><span class=kc>true</span><span class=err>，</span>
</span></span><span class=line><span class=cl>                             <span class=n>kCGImageSourceThumbnailMaxPixelSize</span><span class=p>:</span><span class=n>maxSize</span>
</span></span><span class=line><span class=cl>                             <span class=n>kCGImageSourceShouldCacheImmediately</span><span class=p>:</span><span class=kc>true</span><span class=err>，</span>
</span></span><span class=line><span class=cl>                             <span class=n>kCGImageSourceCreateThumbnailWithTransform</span><span class=p>:</span><span class=kc>true</span><span class=err>，</span>
</span></span><span class=line><span class=cl>                             <span class=p>]</span> <span class=k>as</span> <span class=n>CFDictionary</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=kd>let</span> <span class=nv>downsampledImage</span> <span class=p>=</span> <span class=n>CGImageSourceCreateThumbnailAtIndex</span><span class=p>(</span><span class=n>source</span><span class=p>,</span>  <span class=mi>0</span><span class=p>,</span> <span class=n>downsampleOptions</span><span class=p>)</span><span class=o>!</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>UIImage</span><span class=p>(</span><span class=n>cgImage</span><span class=p>:</span> <span class=n>downsampledImage</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Core Graphics 并不会参与解码图片，直到你明确需要使用缩略图的时候。 并且需要注意传入 <code>kCGImageSourceCreateThumbnailMaxPixelSize</code>，就像我们做的上面两个例子那样。 如果你不传，那么你会得到一个和原始图像一样大小的缩略图。 据文档描述:</p><blockquote><p>“…如果没有指定最大像素大小，那么缩略图就会是完整的图片大小，这可能不是你想要的。”
“…if a maximum pixel size isn’t specified, then the thumbnail will be the size of the full image, which probably isn’t what you want.”</p></blockquote><p>那么这里发生了什么? 简单来说，我们通过在缩略图上使用了缩小部分图片的等式，创建了一个小得多的解码图像缓冲区。 回忆一下之前提到的渲染路径，第一步（加载）现在我们没有创建一个原始图像大小的缓冲区，而是一个 image view 显示大小的缓冲区。</p><p>想要一个这篇文章的太长不读版本? 找机会降低图像采样，而不是使用 <code>UIImage</code> 缩小图片。</p><h2 id=附加部分>附加部分<a hidden class=anchor aria-hidden=true href=#附加部分>#</a></h2><p>我个人在 Tandem 中配合着 <a href="https://developer.apple.com/documentation/uikit/uitableviewdatasourceprefetching?language=swift">prefetch API</a> （iOS 11） 使用了这种技术。 但要记住即使我们在真正使用 table view 或者 collection view 之前这样做，我们在解码图片的时候，内部依然会带来的一个 CPU 使用量的高峰。</p><p>尽管 iOS 在面对持续性能消耗时有很高效的处理方案，但在我们的例子中，可能是时不时才会产生这样的高峰。 所以在处理这种问题的时候，最好把希望寄予你自己创建的队列。 另一个优势是，这样还能将解码移动到后台处理。</p><p>快遮住眼睛，我业余项目中的 Objective-C 代码要出来了:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-objc data-lang=objc><span class=line><span class=cl><span class=c1>//  用你自己的队列而不是 global 队列可以避免潜在的线程爆炸
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=p>-</span> <span class=p>(</span><span class=kt>void</span><span class=p>)</span><span class=nf>tableView:</span><span class=p>(</span><span class=n>UITableView</span> <span class=o>*</span><span class=p>)</span><span class=nv>tableView</span> <span class=nf>prefetchRowsAtIndexPaths:</span><span class=p>(</span><span class=n>NSArray</span><span class=o>&lt;</span><span class=n>NSIndexPath</span> <span class=o>*&gt;</span> <span class=o>*</span><span class=p>)</span><span class=nv>indexPaths</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nb>self</span><span class=p>.</span><span class=n>downsampledImage</span> <span class=o>!=</span> <span class=nb>nil</span> <span class=o>||</span> 
</span></span><span class=line><span class=cl>        <span class=nb>self</span><span class=p>.</span><span class=n>listItem</span><span class=p>.</span><span class=n>mediaAssetData</span> <span class=o>==</span> <span class=nb>nil</span><span class=p>)</span> <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>NSIndexPath</span> <span class=o>*</span><span class=n>mediaIndexPath</span> <span class=o>=</span> <span class=p>[</span><span class=n>NSIndexPath</span> <span class=nl>indexPathForRow</span><span class=p>:</span><span class=mi>0</span>
</span></span><span class=line><span class=cl>                                                     <span class=nl>inSection</span><span class=p>:</span><span class=n>SECTION_MEDIA</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>([</span><span class=n>indexPaths</span> <span class=nl>containsObject</span><span class=p>:</span><span class=n>mediaIndexPath</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>CGFloat</span> <span class=n>scale</span> <span class=o>=</span> <span class=n>tableView</span><span class=p>.</span><span class=n>traitCollection</span><span class=p>.</span><span class=n>displayScale</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>CGFloat</span> <span class=n>maxPixelSize</span> <span class=o>=</span> <span class=p>(</span><span class=n>tableView</span><span class=p>.</span><span class=n>width</span> <span class=o>-</span> <span class=n>SSSpacingJumboMargin</span><span class=p>)</span> <span class=o>*</span> <span class=n>scale</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=n>dispatch_async</span><span class=p>(</span><span class=nb>self</span><span class=p>.</span><span class=n>downsampleQueue</span><span class=err>，</span><span class=o>^</span><span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 缩减采样
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=nb>self</span><span class=p>.</span><span class=n>downsampledImage</span> <span class=o>=</span> <span class=p>[</span><span class=n>UIImage</span> <span class=nl>downsampledImageFromData</span><span class=p>:</span><span class=nb>self</span><span class=p>.</span><span class=n>listItem</span><span class=p>.</span><span class=n>mediaAssetData</span>
</span></span><span class=line><span class=cl>                               <span class=nl>scale</span><span class=p>:</span><span class=n>scale</span>
</span></span><span class=line><span class=cl>                        <span class=nl>maxPixelSize</span><span class=p>:</span><span class=n>maxPixelSize</span><span class=p>];</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=n>dispatch_async</span><span class=p>(</span><span class=n>dispatch_get_main_queue</span><span class=p>()</span><span class=err>，</span><span class=o>^</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nb>self</span><span class=p>.</span><span class=n>listItem</span><span class=p>.</span><span class=n>downsampledMediaImage</span> <span class=o>=</span> <span class=nb>self</span><span class=p>.</span><span class=n>downsampledImage</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>});</span>
</span></span><span class=line><span class=cl>        <span class=p>});</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><blockquote><p>注意在你有大量的原始图像（raw image）资源时使用资源管理（asset catalogs）。
因为它会帮你管理缓存大小（还有其他很多的优势）</p></blockquote><p>想要了解更多关于图像和内存管理的信息，可以关注这些信息量巨大的 WWDC 18 session:</p><ul><li><a href="https://developer.apple.com/videos/play/wwdc2018/416/?time=1074">iOS Memory Deep Dive</a></li><li><a href=https://developer.apple.com/videos/play/wwdc2018/219/>Images and Graphics Best Practices</a></li></ul><h2 id=总结一下>总结一下<a hidden class=anchor aria-hidden=true href=#总结一下>#</a></h2><p>你无法察觉你不知道的东西。 就编程来说，你基本上相当于报名参加了一个需要持续跑每小时 10，000 米以跟上创新和变革的职业生涯。 这意味着&mldr;有大量的 API，框架，设计模式或者优化方案你并不知晓。</p><p>在图像领域尤其是这样。 大多数时间，你可能只是初始化了一个 <code>UIImageView</code> 然后放进了一些好看的像素，就过了。 我知道啦，摩尔定理什么的。 现在这些电话运行速度很快，而且有数 G 的内存，并且我们把人类运送到了月球上，都只用了一台不到 100K 内存的电脑。</p><p>但是和魔鬼共舞不会长久，他必然需要滋养他的角。 别让系统杀掉你的应用，只是因为你用了 1G 内存来展示一张自拍照。 但愿这些知识和技巧可以将你拯救于崩溃日志。</p><p>下次见 ✌️。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://joeytat.github.io/tags/ios/>IOS</a></li><li><a href=https://joeytat.github.io/tags/%E7%BF%BB%E8%AF%91/>翻译</a></li></ul><nav class=paginav><a class=prev href=https://joeytat.github.io/posts/compound-component/><span class=title>« Prev</span><br><span>React 进阶模式之复合组件（Compound Component）</span>
</a><a class=next href=https://joeytat.github.io/posts/wwdc2019_platforms_state_of_the_union/><span class=title>Next »</span><br><span>Platforms State of the Union(WWDC 2019)</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://joeytat.github.io/>Joeytat's Dev Log</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>