<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Dev Log</title><link>https://joeytat.github.io/posts/</link><description>Recent content in Posts on Dev Log</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Fri, 02 Jun 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://joeytat.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>构建易维护的 Design System: 为什么 SwiftUI 会是更好的选择</title><link>https://joeytat.github.io/posts/why-swiftui-is-better-at-building-a-design-system/</link><pubDate>Fri, 02 Jun 2023 00:00:00 +0000</pubDate><guid>https://joeytat.github.io/posts/why-swiftui-is-better-at-building-a-design-system/</guid><description>
&lt;p>&lt;code>SwiftUI&lt;/code> 自 iOS 13 发布以来，虽然已经面向公众近 4 年，但由于在实现复杂布局时的性能不佳，以及因其内置组件的底层实现变更（iOS 16 上 &lt;code>List&lt;/code> 的底层实现从 &lt;code>UITableView&lt;/code> 改成了 &lt;code>UICollectionView&lt;/code> ），导致开发者们原本良好运行代码随系统升级被破坏了。iOS 14 之前 SwiftUI 的开发者体验也让人一言难尽。尽管有很多的槽点，但我们还是能发现社区整体上还是比较接纳 SwiftUI。所以如果你对 SwiftUI 还有所犹豫，不清楚为何要使用它，这篇文章或许能够带来一些新的想法。&lt;/p>
&lt;p>本篇文章主要是想要通过 Design System 为切入点，同大家讨论相比起 UIKit，为什么更推荐使用 SwiftUI 来实现大多数业务场景下的 UI 组件。&lt;/p>
&lt;p>首先简单概括一下 Design System 是什么，Design System 是一个包含了设计原则、组件库和代码资源等系统化的指导，旨在促进团队间的协作和提高项目的一致性。它可以帮助团队更快速、高效地构建应用程序，同时确保应用程序的外观和交互保持一致。&lt;/p>
&lt;p>接下来就进入正题，从以下几点来探讨一下通过 SwiftUI 构建 Design System 有哪些优势。&lt;/p>
&lt;ul>
&lt;li>声明式语法会更具有可读性和易于实现&lt;/li>
&lt;li>内建的一致性和统一性表达&lt;/li>
&lt;li>单向数据流带来的可预测性&lt;/li>
&lt;li>与 Design System 有更相似的哲学思想&lt;/li>
&lt;/ul>
&lt;h2 id="声明式语法会更具有可读性和易于实现">
声明式语法会更具有可读性和易于实现
&lt;a href="#%e5%a3%b0%e6%98%8e%e5%bc%8f%e8%af%ad%e6%b3%95%e4%bc%9a%e6%9b%b4%e5%85%b7%e6%9c%89%e5%8f%af%e8%af%bb%e6%80%a7%e5%92%8c%e6%98%93%e4%ba%8e%e5%ae%9e%e7%8e%b0" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h2>
&lt;p>首先从实现和维护成本上来说，SwiftUI 与 Apple 现有的 UIKit 和 AppKit 不同，SwiftUI 采用了声明式语法构建 UI。由于声明式语法更关注于描述 UI 的最终效果，而不是具体实现方式。这使得通过声明式语法编写的 UI 组件更具可读性，有助于团队更好地协作实现 Design System。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// SwiftUI&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>VStack(spacing: &lt;span style="color:#ae81ff">20&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Text(&lt;span style="color:#e6db74">&amp;#34;Hello&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .font(.largeTitle)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Text(&lt;span style="color:#e6db74">&amp;#34;World&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .font(.largeTitle)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>.foregroundColor(.blue)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// UIKit&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> stackView = UIStackView()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>stackView.axis = .vertical
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>stackView.spacing = &lt;span style="color:#ae81ff">20&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> helloLabel = UILabel()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>helloLabel.text = &lt;span style="color:#e6db74">&amp;#34;Hello&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>helloLabel.font = UIFont.systemFont(ofSize: &lt;span style="color:#ae81ff">34&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>stackView.addArrangedSubview(helloLabel)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> worldLabel = UILabel()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>worldLabel.text = &lt;span style="color:#e6db74">&amp;#34;World&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>worldLabel.font = UIFont.systemFont(ofSize: &lt;span style="color:#ae81ff">34&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>stackView.addArrangedSubview(worldLabel)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>stackView.backgroundColor = .blue
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>除了代码数量上的差距，我们还可以在 SwiftUI 示例中通过代码结构就直观地感受到 UI 组件是如何被排列的。&lt;/p>
&lt;h2 id="内建的一致性和统一性表达">
内建的一致性和统一性表达
&lt;a href="#%e5%86%85%e5%bb%ba%e7%9a%84%e4%b8%80%e8%87%b4%e6%80%a7%e5%92%8c%e7%bb%9f%e4%b8%80%e6%80%a7%e8%a1%a8%e8%be%be" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h2>
&lt;p>在 SwiftUI 中，我们可以通过 &lt;code>View Modifier&lt;/code> 来实现对 UI 组件的统一性表达。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// SwiftUI&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Button(&lt;span style="color:#e6db74">&amp;#34;Primary&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// action&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>.buttonStyle(PrimaryButtonStyle())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Button(&lt;span style="color:#e6db74">&amp;#34;Secondary&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// action&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>.buttonStyle(SecondaryButtonStyle()) &lt;span style="color:#75715e">// 当 Primary， 或 Secondary style 发生变化时，所有使用了这两个 style 的按钮都会被自动更新&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// UIKit&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> primaryButton = UIButton()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>primaryButton.setTitle(&lt;span style="color:#e6db74">&amp;#34;Primary&amp;#34;&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">，&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span>: .normal)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>primaryButton.titleLabel?.font = UIFont.systemFont(ofSize: &lt;span style="color:#ae81ff">16&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>primaryButton.backgroundColor = UIColor.blue
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>primaryButton.layer.cornerRadius = &lt;span style="color:#ae81ff">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> secondaryButton = UIButton()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>secondaryButton.setTitle(&lt;span style="color:#e6db74">&amp;#34;Secondary&amp;#34;&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">，&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span>: .normal)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>secondaryButton.titleLabel?.font = UIFont.systemFont(ofSize: &lt;span style="color:#ae81ff">16&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>secondaryButton.backgroundColor = UIColor.gray
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>secondaryButton.layer.cornerRadius = &lt;span style="color:#ae81ff">5&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>通过代码我们可以看到 SwiftUI 预定义的设计规范，使开发者更易于表达和保证 Design System 的统一性。&lt;/p>
&lt;p>虽然开发者也可以对 UIKit 的 UI 组件进行封装，实现类似 SwiftUI View Modifier 的效果。但是 SwiftUI 的 View Modifier 是内在耦合的，会天然具有更好的一致性。而对 UIKit 进行二次封装，仍需依赖于开发者自觉遵循设计规范，难免会产生疏忽的情况，影响最终 UI 的一致性。&lt;/p>
&lt;h2 id="单向数据流带来的可预测性">
单向数据流带来的可预测性
&lt;a href="#%e5%8d%95%e5%90%91%e6%95%b0%e6%8d%ae%e6%b5%81%e5%b8%a6%e6%9d%a5%e7%9a%84%e5%8f%af%e9%a2%84%e6%b5%8b%e6%80%a7" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h2>
&lt;p>SwiftUI 所编写的 UI 组件更具有可预测性。体现在其遵循单向数据流原则，这样可以减少因为状态管理复杂性导致的 UI 错误。同时 UI 组件的样式是通过高阶函数或组合来创建的，而不是通过副作用或隐式规则创建，这使得开发者更容易识别组件会具备哪些样式及其来源。&lt;/p>
&lt;p>相比之下 UIKit 作为命令式 UI 框架，其 UI 渲染过程则相对复杂和难以预测。&lt;/p>
&lt;ul>
&lt;li>状态变化会导致难以跟踪的副作用，这使 UI 更易出错且难以调试。&lt;/li>
&lt;li>样式规则由开发者自行定义并应用，存在较大随意性，阅读和理解起来也更加困难。&lt;/li>
&lt;li>样式的来源和应用不像 SwiftUI 那样清晰，需要开发者自行理清各个样式规则之间的关系，以确保 UI 的正确性。&lt;/li>
&lt;/ul>
&lt;h2 id="更相似的哲学思想">
更相似的哲学思想
&lt;a href="#%e6%9b%b4%e7%9b%b8%e4%bc%bc%e7%9a%84%e5%93%b2%e5%ad%a6%e6%80%9d%e6%83%b3" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h2>
&lt;p>SwiftUI 中组合和函数式的思想与 Design System 中原子组件和组合的原则相吻合。&lt;/p>
&lt;ul>
&lt;li>两者都倾向于构建出小的、自洽的单位，然后通过组合来创建更为复杂的结构，SwiftUI 中的视图和 Modifier 就是这种单位和组合的体现。&lt;/li>
&lt;li>组件和函数都是可以是通用的或定制的，同时可以将其重复使用或组合。在 SwiftUI 中，我们可以构建出通用的 Modifier 和视图，也可以为某一具体视图定制特有的 Modifier。&lt;/li>
&lt;li>当改变基础单位(如字号，间距等基础单位)会以可控方式影响所有组合。如果我们改变一个 Modifier 的行为或属性，所有应用该 Modifier 的视图将会相应改变。这使得在设计系统中调整细节时，更易预测和控制其影响范围。&lt;/li>
&lt;/ul>
&lt;p>而相比之下，UIKit 作为命令式框架，其 UI 构建方式则相对零散和随意:&lt;/p>
&lt;ul>
&lt;li>构建 UI 时，开发者自行决定组装哪些控件和设置何种属性，难以遵循统一的组合规则。&lt;/li>
&lt;li>没有类似 Modifier 的机制，每个视图的样式都需要单独设置，无法在多处重复使用。这使得调整样式时，需要逐个修改每个视图，难以高效地应用设计变化。&lt;/li>
&lt;li>属性的变化并不一定会影响所有相关视图，需要开发者自己再逐个对应用的视图做出修改。这加大了设计系统维护的难度。&lt;/li>
&lt;/ul>
&lt;h2 id="最后">
最后
&lt;a href="#%e6%9c%80%e5%90%8e" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h2>
&lt;p>还需要说明的是，本文只是想探讨在实现移动平台的 Design System 时相比起 UIKit，SwiftUI 所具有的一定优势。&lt;/p>
&lt;p>在某些复杂的场景下，UIKit 这样命令式的 UI 框架的灵活性和性能可能会更强。所以需要注意的是，SwiftUI 的组件状态和行为都是由数据驱动，这可能会导致性能问题，如大量的数据绑定和更新可能会引起 UI 界面的卡顿和延迟。相比之下，UIKit 接近底层渲染机制，性能表现可能更佳。但 SwiftUI 也有实现跨平台需求的优势。&lt;/p>
&lt;p>在选择具体哪个框架实现 Design System 时，开发者还是得根据具体需求，权衡两者之间的优缺点。在追求性能或需要高度定制化的场景下，UIKit 的灵活性和性能表现可能更占优。但在大多数情况下，SwiftUI 的声明式语法和组合特性，使其天然更适合构建统一且易维护的 Design System。&lt;/p></description></item><item><title>移动开发中实现 Deep Linking 的 URL Scheme 和 Universal Links 的区别是什么？</title><link>https://joeytat.github.io/posts/differences_between_scheme_and_universal_links/</link><pubDate>Wed, 27 Jul 2022 00:00:00 +0000</pubDate><guid>https://joeytat.github.io/posts/differences_between_scheme_and_universal_links/</guid><description>
&lt;p>经历过的 Mobile 项目基本上都有支持 Deep Linking 的需求，每次新项目都会经历向其他端同事和 BA 解释实现 Deep Linking 两种方案的区别，于是就有了这一篇短文。主要是介绍两种方案的优缺点和实现成本差异，并不涉及如何实现的代码步骤。&lt;/p>
&lt;p>首先什么是 Deep Linking，简单来说就是让一个 App 可以通过 URL 打开其他的 App，以提供更便捷高效的用户体验。&lt;/p>
&lt;h2 id="如果想跳到别人那去">
如果想跳到别人那去
&lt;a href="#%e5%a6%82%e6%9e%9c%e6%83%b3%e8%b7%b3%e5%88%b0%e5%88%ab%e4%ba%ba%e9%82%a3%e5%8e%bb" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h2>
&lt;p>BA 老刘：「如果想在 App 里打开人家的 App 应该怎么做呢？」&lt;br>
开发小曾：「目前有两种选项，URL Scheme 和 Universal Links。」&lt;br>
BA 老刘：「区别是啥？」&lt;br>
开发小曾：「主要看你想不想处理用户没有安装对方 App 的情况。」&lt;/p>
&lt;p>&lt;em>ps: Android 中这两种选项是 Deep Links 和 App Links，运作原理大体相同，实现方式 iOS 和 Android 有些许差异。为少打字，下文将统一使用 URL Scheme 和 Universal Links。&lt;/em>&lt;/p>
&lt;h3 id="url-scheme">
URL Scheme
&lt;a href="#url-scheme" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h3>
&lt;p>通常长这样： &lt;code>example://destination?param1=hello&lt;/code>。&lt;/p>
&lt;p>想通过 URL Scheme 跳转到某个 App，我们需要知道对方 App 定义的 Scheme 是什么（这不算是废话）。&lt;/p>
&lt;p>以 Twitter 为例，如果当前设备&lt;strong>安装了 Twitter&lt;/strong>：&lt;br>
通过 &lt;code>twitter://user?screen_name=elonmusk&lt;/code> 这样一个 URL Scheme，就可以打开 Twitter 并且跳转到 Elon Musk 的主页（scheme 可以输入 Safari 地址栏进行测试）。&lt;/p>
&lt;p>如果当前设备&lt;strong>没有安装 Twitter&lt;/strong>：&lt;br>
可以通过代码得到无法解析 URL 的错误，接下来要如何处理，就需要工程师自己去实现了。
比如可以加上判断，如果打不开 Twitter 的 Scheme，就去打开 App Store 的 Scheme 引导用户下载 Twitter，或者去打开微博。&lt;/p>
&lt;h3 id="universal-links">
Universal Links
&lt;a href="#universal-links" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h3>
&lt;p>Universal Links 则是使用了 HTTP 或 HTTPS（iOS 只支持 HTTPS）Scheme 的 URL。&lt;/p>
&lt;p>依然用 Twitter 举例：&lt;/p>
&lt;p>如果当前设备&lt;strong>安装了 Twitter&lt;/strong>：&lt;br>
通过打开 URL &lt;code>https://twitter.com/elonmusk&lt;/code> 可以跳转到 Twitter App 中 Elon Musk 的主页。&lt;/p>
&lt;p>如果用户&lt;strong>没有安装 Twitter&lt;/strong>：&lt;br>
会打开网页版 Elon Musk 的主页。&lt;/p>
&lt;h3 id="方案对比">
方案对比
&lt;a href="#%e6%96%b9%e6%a1%88%e5%af%b9%e6%af%94" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>有安装对应 App&lt;/th>
&lt;th>没有安装对应 App&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>URL Scheme&lt;/td>
&lt;td>直接打开对应 App&lt;/td>
&lt;td>需要自行处理设备没有安装对应 App 的情况，但处理方案可以非常灵活多变&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Universal Links&lt;/td>
&lt;td>直接打开对应 App&lt;/td>
&lt;td>无需额外处理，通常 Universal Link 就对应了一个网页，在当前设备没有安装 App 的情况下，会跳转到对应网页&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="如果想让别人跳过来">
如果想让别人跳过来
&lt;a href="#%e5%a6%82%e6%9e%9c%e6%83%b3%e8%ae%a9%e5%88%ab%e4%ba%ba%e8%b7%b3%e8%bf%87%e6%9d%a5" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h2>
&lt;p>BA 老刘：「那如果想让我们的 App 支持跳转呢？」。&lt;br>
开发小曾：「还是那两种选项，URL Scheme 和 Universal Links。」&lt;br>
BA 老刘：「区别是啥？」&lt;br>
开发小曾：「主要是实现成本和想支持跳转的范围。」&lt;/p>
&lt;h3 id="url-scheme-1">
URL Scheme
&lt;a href="#url-scheme-1" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h3>
&lt;p>在 App 中设置一个自定义 Scheme 即可。当三方 App 通过代码调用尝试跳转某个 Scheme，系统会检测当前设备是否安装了有定义该 Scheme 的 App。&lt;/p>
&lt;p>如果想要支持对方跳转到某个特定界面，只需要在 App 中增加解析 URL 的方法即可。
具体实现细节可以参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://developer.apple.com/documentation/xcode/defining-a-custom-url-scheme-for-your-app">iOS - Defining a custom URL scheme for your app&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developer.android.com/training/app-links#deep-links">Android - Hanling Android App Link - Deep Links&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="universal-links-1">
Universal Links
&lt;a href="#universal-links-1" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h3>
&lt;p>相比起 URL Scheme 只需要前端实现，Universal Links 的支持要复杂一些，原因是在于其使用场景扩大了。&lt;br>
URL Scheme 的跳转，需要让三方 App 知道我们的 Scheme 定义即可，由&lt;strong>第三方 App 来发起跳转&lt;/strong>。如果当前设备并没有安装 App，如何提供备选方案，就完全依赖于三方实现了。&lt;/p>
&lt;p>Universal Links 的跳转，是三方 App 打开一个链接时，由系统决定应该跳转到 App（将其当作 Universal Link） 还是跳转到网页（将其当作普通的 HTTP Link）。同时系统来控制跳转，则意味着用户从系统中几乎任何地方（比如邮件、短信、备忘录、日历）点击 Universal Link 都能跳转到 App 中。这样即使在当前设备没有安装 App 的情况下，依然保证用户可以通过网页访问到需要的资源。&lt;/p>
&lt;p>所以实现的区别在于，需要让系统知道，哪些域名的 URL 是应该跳转到我们的 App。&lt;/p>
&lt;p>依然用 Twitter 举例，当我们需要让系统支持在点击任何带有 &lt;code>twitter.com&lt;/code> 为 Host 的链接时，都尝试着唤起 Twitter 就需要：&lt;/p>
&lt;ol>
&lt;li>开发人员需要在 Twitter App 的配置中，添加 associated domain 的记录，比如 &lt;code>twitter.com&lt;/code>。&lt;/li>
&lt;li>当 Twitter App 被安装到用户的手机或者应用更新时，系统会去 Twitter App 包中查找 associated domain 记录。&lt;/li>
&lt;li>如果存在这样一份记录，系统会去访问该 domain 下的一个 JSON 文件，该文件中需要包含 Twitter App 的 App ID，以建立该站点与 App 的联系。比如 Twitter 就将这份 JSON 文件放在了 &lt;code>https://twitter.com/.well-known/apple-app-site-association&lt;/code>。&lt;/li>
&lt;li>由此当系统在处理链接的点击时，会去判断 &lt;code>https://twitter.com&lt;/code> 是否和当前设备中安装的某个 App 之间存在联系，如果已安装的某个 App 的 app id 存在于该 domain 下的 site association JSON 文件中，则将 URL 作为参数代入，跳转到 App 中。&lt;/li>
&lt;/ol>
&lt;p>用图片来表示的话，大概是这样，首先让 OS 建立域名和 App 的联系：&lt;/p>
&lt;p>&lt;img src="https://joeytat.github.io/deeplinking_connection.png" alt="make connection between domain and the app">&lt;/p>
&lt;p>当存在联系之后，点击链接时，OS 会去唤起 App：&lt;/p>
&lt;p>&lt;img src="https://joeytat.github.io/deeplinking_connection1.png" alt="tapping on the link will navigate to the app">&lt;/p>
&lt;p>具体实现细节可以参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://developer.apple.com/documentation/xcode/allowing-apps-and-websites-to-link-to-your-content">iOS - Allowing Apps and Websites to Link to Your Content&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developer.android.com/training/app-links#android-app-links">Android - Hanling Android App Link&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="对比">
对比
&lt;a href="#%e5%af%b9%e6%af%94" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>实现成本&lt;/th>
&lt;th>支持跳转的范围&lt;/th>
&lt;th>没有安装 App&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>URL Scheme&lt;/td>
&lt;td>需要在 App 中维护一个支持被跳转的 Scheme 列表&lt;/td>
&lt;td>只能由知道 Scheme 的 App 来主动进行跳转&lt;/td>
&lt;td>需要让三方 App 来处理没有安装 App 的情况&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Universal Links&lt;/td>
&lt;td>App 中要维护一个支持被跳转的 domain 列表，同时需要在 domain 对应服务器中放一个 JSON 文件，让系统知道该 domain 同 App 之间的联系&lt;/td>
&lt;td>系统中几乎所有可点击链接区域都可以被系统触发跳转，比如点击邮件、短信、网页、三方 App 中的 Universal Link 时&lt;/td>
&lt;td>用户会跳转到 Universal Link 对应的网页，在网页中我们可以实现一套 Web 版本，或者直接在网页中打开应用商店，引导用户下载 App&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="简单总结">
简单总结
&lt;a href="#%e7%ae%80%e5%8d%95%e6%80%bb%e7%bb%93" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h2>
&lt;p>跳到别人那去，一般来说在需要灵活处理当前设备&lt;strong>没有安装&lt;/strong>对方 App 的情况下，通常会选择 URL Scheme，否则选择 Universal Links。&lt;/p>
&lt;p>支持别人跳过来，两个方案可以共存。&lt;/p>
&lt;ul>
&lt;li>URL Scheme 相对来说实现成本非常低廉，仅需要前端维护 Scheme 列表并且负责解析即可。但需要让对方来处理，如果当前设备没有安装 App 应该怎么办。&lt;/li>
&lt;li>Universal Links 的实现则相对复杂，必须要把 domain 和 app 之间建立联系的 json 文件放在服务器，让系统在安装 App 的时候去访问。但好处是，如果本来就有 Web 版的业务，那么自动就可以在用户未安装 App 时得到相应的服务。&lt;/li>
&lt;/ul></description></item><item><title>参加 Apple 开发者线上活动是什么样的体验？</title><link>https://joeytat.github.io/posts/apple_swiftui_workshop/</link><pubDate>Mon, 28 Mar 2022 00:00:35 +0000</pubDate><guid>https://joeytat.github.io/posts/apple_swiftui_workshop/</guid><description>
&lt;p>从朋友圈看到思琦发了一个《使用 SwiftUI 打造卓越体验》的 Apple 开发者线上活动的报名链接，刚好最近参与的项目也在大规模使用 SwiftUI 就报名了，即使时间很不凑巧是工作日（另一报名要求是必须要有中国区的开发者账号）。&lt;/p>
&lt;p>活动分两天第一天主要是一些 SwiftUI 的介绍，SwiftUI 对数据的处理和布局的一些要点。第二天是社区开发者交流。&lt;/p>
&lt;p>技术细节后面可以分好几篇博客来描述，但总的来说技术相关的收获其实和自己去看 WWDC 差不多。并且由于长期以 2x 速度观看这类视频，刚开始还出现了一些不适应。但想着这是来自苹果的开发者的分享，还是管住了想拿起手机的手，毕竟机会难得。&lt;/p>
&lt;p>事实证明确实认真观看还是有收获，主要是以下几点：&lt;/p>
&lt;ul>
&lt;li>知道了一些 SwiftUI 相关的 Xcode 快捷操作，比如 Preview 和代码其实是可以相互影响的。Library 中可以搜索 &lt;code>ViewModifier&lt;/code> 等等。&lt;/li>
&lt;li>来自苹果的工程师对 SwiftUI 这样响应式 UI 编写方式的数据流思考的建议。&lt;/li>
&lt;li>一些编写 SwiftUI 代码时能够让渲染引擎更高效的建议。&lt;/li>
&lt;/ul>
&lt;p>除了上面开发者分享的内容之外，最重要的是可以提出一些自己在使用 SwiftUI 时遇到的问题，感觉只要描述得够清楚并且和本次活动主题相关，那么都能够得到苹果开发者的解答，虽然受形式或时间限制，答案并不一定完整，但当一个 SwiftUI 的疑问是由苹果的工程师解答时，即使只是关键字的指引也能起到画龙点睛的作用（比如 &lt;code>StateObject&lt;/code> 与 &lt;code>ObservedObject&lt;/code> 的差异）。&lt;/p>
&lt;p>第二天更多的是听社区开发者的一些交流，收获到了不少之前并不知道的资料。一并列在下方。&lt;/p>
&lt;p>ps：感觉参加这次活动对自己来说还有一个副作用就是，由于资料的推荐者有足够的可信度，并且提供了一个可靠的学习路线，所以会用格外的认真来对待它们。&lt;/p>
&lt;p>Swift UI 的入门指引&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://developer.apple.com/videos/play/wwdc2020/10119/">WWDC - Introduction to SwiftUI&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developer.apple.com/videos/play/wwdc2019/216/">WWDC - SwiftUI Essentials&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developer.apple.com/tutorials/sample-apps">十个很有代表性的 Playground&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developer.apple.com/tutorials/swiftui">交互式的 SwiftUI 入门教程&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developer.apple.com/tutorials/app-dev-training">使用 SwiftUI 构建完整 App 的交互式教程&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>SwiftUI 数据处理要素&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://developer.apple.com/videos/play/wwdc2020/10040/">WWDC - Data Essentials in SwiftUI&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developer.apple.com/videos/play/wwdc2021/10022">WWDC - Demystify SwiftUI&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developer.apple.com/documentation/SwiftUI/State-and-Data-Flow">状态与数据流&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developer.apple.com/documentation/swiftui/managing-model-data-in-your-app">如何管理 App 中的模型数据&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developer.apple.com/documentation/swiftui/managing-user-interface-state">如何管理 UI 状态&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>SwiftUI 布局和渲染&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://developer.apple.com/videos/play/wwdc2021/10018/">WWDC - What&amp;rsquo;s new in SwiftUI&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developer.apple.com/videos/play/wwdc2020/10031/">WWDC - Stacks, Grids, and Outlines in SwiftUI&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developer.apple.com/videos/play/wwdc2021/10021/">WWDC - Add rich graphics to your SwiftUI app&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developer.apple.com/videos/play/wwdc2019/237/">WWDC - Building Custom Views with SwiftUI&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developer.apple.com/documentation/swiftui/layout-containers">布局容器&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developer.apple.com/documentation/swiftui/collection-containers">集合布局容器&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developer.apple.com/documentation/swiftui/drawing-and-graphics">图像与绘制&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>用 SwiftUI 打造 watchOS app&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://developer.apple.com/videos/play/wwdc2019/219/">WWDC - SwiftUI on watchOS&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developer.apple.com/videos/play/wwdc2020/10048/">WWDC - Build complications in SwiftUI&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developer.apple.com/documentation/example-articles/building_a_watchos_app">打造 watchOS App&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developer.apple.com/documentation/watchosapps/developing_a_user_interface_with_swiftui">如何利用 SwiftUI 以及手表特定功能打造复杂 app 的代码示例&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>社区开发者提及&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://developer.apple.com/documentation/docc#Overview">文档生成工具 - DocC&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://swiftui-lab.com/random-lessons/">WWDC Digital Lounges 中的开发者问答整理&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://swiftui-lab.com/companion/">SwiftUI Companion - 交互式 SwiftUI API 文档工具&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>iOS 架构之另一种依赖注入的思路</title><link>https://joeytat.github.io/posts/swift_dependency_injection/</link><pubDate>Tue, 15 Mar 2022 00:00:00 +0000</pubDate><guid>https://joeytat.github.io/posts/swift_dependency_injection/</guid><description>
&lt;p>在 iOS 业务开发过程经常面对网络请求，数据持久化这样带有副作用的操作。为了能够在测试中 mock 这些操作，通常的做法就是抽象一层 protocol 出来，然后编写不同的实现。&lt;/p>
&lt;p>比如需要处理一个简陋的注册业务（示例省略了一点细节），需要用户输入信息后发送网络请求，成功后返回对应用户对象。&lt;/p>
&lt;p>首先为网络请求定义一个 protocol：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">protocol&lt;/span> &lt;span style="color:#a6e22e">SignUpRepositoryProtocol&lt;/span>: RepositoryProtocol {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">handleSignUp&lt;/span>(name: String, email: String, pwd: String) -&amp;gt; AnyPublisher&amp;lt;User, Error&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>对其进行实现：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">SignUpRepository&lt;/span>: SignUpRepositoryProtocol {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">handleSignUp&lt;/span>(name: String, email: String, pwd: String) -&amp;gt; AnyPublisher&amp;lt;User, Error&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> client(.signUp(name, email, pwd))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .map
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .decode
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .eraseToAnyPublisher()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>将其注入到 &lt;code>ViewModel&lt;/code> 或是 &lt;code>Interactor&lt;/code> 中（取决于你采取的架构是什么 :p ），并且调用对应方法：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">SignUpViewModel&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">enum&lt;/span> &lt;span style="color:#a6e22e">State&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> loading
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> success
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> failed
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> repository: SignUpRepositoryPortocol
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> state: State = .loading
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">init&lt;/span>(repository: SignUpRepositoryPortocol) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">self&lt;/span>.repository = repository
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">onSubmit&lt;/span>(name: String, email: String, pwd: String) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> repository.hanldeSignUp(name: name, email: email, pwd: pwd)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .sink {[&lt;span style="color:#66d9ef">weak&lt;/span> &lt;span style="color:#66d9ef">self&lt;/span>] completion &lt;span style="color:#66d9ef">in&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">switch&lt;/span> completion {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> .failure:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">self&lt;/span>.?state = .failed
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> .finished: &lt;span style="color:#66d9ef">break&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } receiveValue: {[&lt;span style="color:#66d9ef">weak&lt;/span> &lt;span style="color:#66d9ef">self&lt;/span>] result &lt;span style="color:#66d9ef">in&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">self&lt;/span>?.state = .success
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }.store(&lt;span style="color:#66d9ef">in&lt;/span>: &amp;amp;bag)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>由此如果需要测试对应的方法，只需要再创建一份 &lt;code>MockSignUpRepository&lt;/code> 的实现即可，比如想要测试注册成功或失败场景下的处理：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">MockSignUpRepository&lt;/span>: SignUpRepositoryPortocol {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> shouldSignUpSuccess: Bool
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">handleSignUp&lt;/span>(name: String, email: String, pwd: String) -&amp;gt; AnyPublisher&amp;lt;User, Error&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> shouldSignUpSuccess {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Just(User.mock)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .mapError{ &lt;span style="color:#66d9ef">_&lt;/span> &lt;span style="color:#66d9ef">in&lt;/span> SignUpError.someError }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .eraseToAnyPublisher()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Fail(error: SignUpError.someError)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .eraseToAnyPublisher()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在编写测试的时候，传入 &lt;code>SignUpViewModel&lt;/code> 的依赖替换成我们想要测试的 Mock 实现：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">shouldSignUpSuccessWhenXXX&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Given&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> sut = SignUpViewModel(repository: MockSignUpSuccessRepository(shouldSignUpSuccess: &lt;span style="color:#66d9ef">true&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// When&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sut.onSubmit(...) &lt;span style="color:#75715e">// 合法输入&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Then&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> XCTAssertEqual(sut.state, .success)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">shouldSignUpFailWhenXXX&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Given&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> sut = SignUpViewModel(repository: MockSignUpSuccessRepository(shouldSignUpSuccess: &lt;span style="color:#66d9ef">false&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// When&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sut.onSubmit(...) &lt;span style="color:#75715e">// 非法输入&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Then&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> XCTAssertEqual(sut.state, .failed)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这时候似乎一切都很美好，但现在再补充一些业务需求，如果需要返回不同的错误类型怎么办？比如用户名错误，那就需要额外的布尔值来表示；再比如邮箱错误，那又需要增加新的布尔值。而这还仅仅只是一个方法的几个分支逻辑处理。当出现较多的逻辑分支之后，如果我们实际的业务再发生变动需要重构，那还得去对 Mock 类也进行重构，同时还需要确保这些控制逻辑分支的布尔值也得到了正确的更新。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> sut = SignUpViewModel(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> repository: MockSignUpSuccessRepository(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> shouldSignUpSuccess: &lt;span style="color:#66d9ef">false&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> shouldShowUsernameError: &lt;span style="color:#66d9ef">true&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> shouldShowEmailError: &lt;span style="color:#66d9ef">true&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> shouldUsernamePassValidation: &lt;span style="color:#66d9ef">true&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> shouldEmailPassValidation: &lt;span style="color:#66d9ef">true&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...😱&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这时候就可以介绍另一种依赖注入方式了。首先定义一个 &lt;code>Repository&lt;/code> 对象，这个对象就像之前的 &lt;code>Repository&lt;/code> 一样，区别是网络请求通过一个属性来持有，同时会提供一个标记为 private 的默认实现：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Repository&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> handleSignUp = handleSignUp(name:, email:, pwd:)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">handleSignUp&lt;/span>(name: String, email: String, pwd: String) -&amp;gt; AnyPublisher&amp;lt;User, Error&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> client(.signUp(name, email, pwd))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .map
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .decode
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .eraseToAnyPublisher()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后将这个 &lt;code>Repository&lt;/code> 实例放到一个 &lt;code>Environment&lt;/code> 对象中：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Environment&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> repo = Repository()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>同时替换 ViewModel 中之前对 &lt;code>Repository&lt;/code> 的引用：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">SignUpViewModel&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">enum&lt;/span> &lt;span style="color:#a6e22e">State&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> loading
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> success
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> failed
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// let repository: SignUpRepositoryPortocol&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> current: Environment &lt;span style="color:#75715e">// 👈&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> state: State = .loading
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">init&lt;/span>(current: Environment) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">self&lt;/span>.current = current &lt;span style="color:#75715e">// 👈&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">onSubmit&lt;/span>(name: String, email: String, pwd: String) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> current.repo.hanldeSignUp(name, email, pwd) &lt;span style="color:#75715e">// 👈&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .sink { completion &lt;span style="color:#66d9ef">in&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">switch&lt;/span> completion {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> .failure:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">self&lt;/span>.state = .failed
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> .finished: &lt;span style="color:#66d9ef">break&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } receiveValue: {[&lt;span style="color:#66d9ef">weak&lt;/span> &lt;span style="color:#66d9ef">self&lt;/span>] result &lt;span style="color:#66d9ef">in&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">self&lt;/span>?.state = .success
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }.store(&lt;span style="color:#66d9ef">in&lt;/span>: &amp;amp;bag)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>代码几乎和之前相同，但保持了更高的可替换性，怎么体现的呢？需要 mock 网络请求 时，可以给 Repository 创建一个 extension：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">extension&lt;/span> &lt;span style="color:#a6e22e">Repository&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">let&lt;/span> mock = Repository(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> handleSignUp: Just(User.mock)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .mapError{ &lt;span style="color:#66d9ef">_&lt;/span> &lt;span style="color:#66d9ef">in&lt;/span> SignUpError.someError }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .eraseToAnyPublisher()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后在测试代码构建 ViewModel 的时候就可以将 Mock 传递进去：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">shouldSignUpSuccessWhenXXX&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Given&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> sut = SignUpViewModel(current: Environment(repo: Repository.mock))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// When&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sut.onSubmit(...) &lt;span style="color:#75715e">// 合法输入&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Then&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> XCTAssertEqual(sut.state, .success)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>对于方法多分支的逻辑，则可以独立实现一份，而不是重新创建整个 &lt;code>MockRepository&lt;/code> 类或者是用一些变量来控制分支逻辑：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">shouldSignUpFailWhenXXX&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Given&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> sut = SignUpViewModel(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> current: Environment(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> repo: Repository(handleSignUp:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Fail(error: SignUpError.someError).eraseToAnyPublisher()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// When&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sut.onSubmit(...) &lt;span style="color:#75715e">// 非法输入&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Then&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> XCTAssertEqual(sut.state, .failed)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这种方式来注入依赖的优势在于：&lt;/p>
&lt;ul>
&lt;li>不需要像 protocol 那样写太多模版代码&lt;/li>
&lt;li>mock 的逻辑分支很容易可以实现相互独立的版本&lt;/li>
&lt;li>依赖的副作用会更容易 mock，特别是系统类&lt;/li>
&lt;/ul></description></item><item><title>Swift 状态管理 —— 如何拆分庞大的 reducer</title><link>https://joeytat.github.io/posts/combining_reducers/</link><pubDate>Sun, 16 Jan 2022 00:00:00 +0000</pubDate><guid>https://joeytat.github.io/posts/combining_reducers/</guid><description>
&lt;p>因为项目需要使用 SwiftUI，想起来之前买过喵神的 &lt;a href="https://objccn.io/products/swift-ui">《SwiftUI 与 Combine 编程》&lt;/a> 。书中介绍了 &lt;a href="https://redux.js.org">Redux&lt;/a> 这一在 Web 前端领域广泛被验证过的数据管理模式是如何通过 Swift 来实现的，非常推荐 SwiftUI 初见者阅读。&lt;/p>
&lt;p>在学习过程中还产生了一个疑问，如果 reducer 越来越大，有什么更 “swift” 的办法能解决这一问题呢？（在 Redux.js 中的原生解决方案是 &lt;a href="https://redux.js.org/usage/structuring-reducers/beyond-combinereducers">&lt;code>combineReducers&lt;/code>&lt;/a>）&lt;/p>
&lt;h2 id="拆分-reducer">
拆分 Reducer
&lt;a href="#%e6%8b%86%e5%88%86-reducer" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h2>
&lt;p>首先看看问题在代码中的表现是什么样的，假设我们有这样一个 reducer：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">appReducer&lt;/span>(appState: &lt;span style="color:#66d9ef">inout&lt;/span> AppState, action: AppAction) -&amp;gt; Void {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">switch&lt;/span> action {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> .emailValid(&lt;span style="color:#66d9ef">let&lt;/span> isValid):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> appState.settings.isEmailValid = isValid
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> .register(&lt;span style="color:#66d9ef">let&lt;/span> email, &lt;span style="color:#66d9ef">let&lt;/span> password):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> appState.settings.loginUser = User(email, password)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> .login(&lt;span style="color:#66d9ef">let&lt;/span> email, &lt;span style="color:#66d9ef">let&lt;/span> password):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> appState.settings.loginUser = User(email, password)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> .logout:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> appState.settings.loginUser = &lt;span style="color:#66d9ef">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> .loadPokemon(&lt;span style="color:#66d9ef">let&lt;/span> result):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> appState.pokemonList.pokemons = result
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> .favoratePokemon(&lt;span style="color:#66d9ef">let&lt;/span> pokemon):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> appState.favoritePokemons.append(pokemon)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> .removeFavoritePokemon(&lt;span style="color:#66d9ef">let&lt;/span> pokemon):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> index = appState.favoritePokemons.indexOf(pokemon)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> appState.favoritePokemons.remove(at: index)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>应用的 action 主要包含三个模块：&lt;/p>
&lt;ul>
&lt;li>账号登录注册注销&lt;/li>
&lt;li>对神奇宝贝数据进行加载&lt;/li>
&lt;li>处理对神奇宝贝数据的收藏和取消收藏&lt;/li>
&lt;/ul>
&lt;p>从这段代码我们很快就能发现，即使只是非常简单的示例也已经包含了不短的代码了。这里还省略掉了处理状态时可能还需要的异步 action 的处理（数据加载等）。这还仅仅只有两个非常简单的界面状态，当面对真实的 app 所需要处理的数十个页面状态会更恐怖。&lt;/p>
&lt;p>将 reducer 拆分成如下三个独立 reducer：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">accountReducer&lt;/span>(appState: &lt;span style="color:#66d9ef">inout&lt;/span> AppState, action: AppAction) -&amp;gt; Void {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">switch&lt;/span> action {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> .emailValid(&lt;span style="color:#66d9ef">let&lt;/span> isValid):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> appState.settings.isEmailValid = isValid
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> .register(&lt;span style="color:#66d9ef">let&lt;/span> email, &lt;span style="color:#66d9ef">let&lt;/span> password):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> appState.settings.loginUser = User(email, password)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> .login(&lt;span style="color:#66d9ef">let&lt;/span> email, &lt;span style="color:#66d9ef">let&lt;/span> password):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> appState.settings.loginUser = User(email, password)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> .logout:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> appState.settings.loginUser = &lt;span style="color:#66d9ef">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">default&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">pokemonListReducer&lt;/span>(appState: &lt;span style="color:#66d9ef">inout&lt;/span> AppState, action: AppAction) -&amp;gt; Void {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">switch&lt;/span> action {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> .loadPokemon(&lt;span style="color:#66d9ef">let&lt;/span> result):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> appState.pokemonList.pokemons = result
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">default&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">favoritePokemonReducer&lt;/span>(appState: &lt;span style="color:#66d9ef">inout&lt;/span> AppState, action: AppAction) -&amp;gt; Void {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">switch&lt;/span> action {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> .favoratePokemon(&lt;span style="color:#66d9ef">let&lt;/span> pokemon):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> appState.favoritePokemons.append(pokemon)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> .removeFavoritePokemon(&lt;span style="color:#66d9ef">let&lt;/span> pokemon):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> index = appState.favoritePokemons.indexOf(pokemon)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> appState.favoritePokemons.remove(at: index)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">default&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>因为对 reducer 的数量并不确定，所以这里使用可变参数来构建 &lt;code>combine&lt;/code> 方法，对传入的 reducer 进行遍历调用处理 appState。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">combine&lt;/span>&amp;lt;Value, Action&amp;gt;(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">_&lt;/span> reducers: (&lt;span style="color:#66d9ef">inout&lt;/span> Value, Action) -&amp;gt; Void...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>) -&amp;gt; (&lt;span style="color:#66d9ef">inout&lt;/span> Value, Action) -&amp;gt; Void {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> { value, action &lt;span style="color:#66d9ef">in&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> reducer &lt;span style="color:#66d9ef">in&lt;/span> reducers {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> reducer(&amp;amp;value, action)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> appReducer = combine(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> accountReducer,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pokemonListReducer,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> favoritePokemonReducer
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>完成，我们的巨大 reducer 被拆分成了独立的 reducer，再通过自己实现的 combine 方法完成了组装。&lt;/p>
&lt;h2 id="隔离-reducer-数据">
隔离 reducer 数据
&lt;a href="#%e9%9a%94%e7%a6%bb-reducer-%e6%95%b0%e6%8d%ae" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h2>
&lt;p>但仔细观看代码还会发现一个问题，每个 reducer 都只需要处理 &lt;code>appState&lt;/code> 上的部分数据，比如 &lt;code>pokemonListReducer&lt;/code> 明明只操作了 &lt;code>appState.pokemonList&lt;/code>，我们却把整个 state 都丢给了它：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">pokemonListReducer&lt;/span>(appState: &lt;span style="color:#66d9ef">inout&lt;/span> AppState, action: AppAction) -&amp;gt; Void {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">switch&lt;/span> action {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> .loadPokemon(&lt;span style="color:#66d9ef">let&lt;/span> result):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> appState.pokemonList.pokemons = result
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">default&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这会增加代码维护上的困难，不熟悉代码的人在不浏览整个 reducer 之前，很难知道这个 reducer 到底操作了哪些数据。更理想的 reducer 可能长这样：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">pokemonListReducer&lt;/span>(value: &lt;span style="color:#66d9ef">inout&lt;/span> PokemonList, action: AppAction) -&amp;gt; Void {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">switch&lt;/span> action {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> .loadPokemon(&lt;span style="color:#66d9ef">let&lt;/span> result):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> value.pokemons = result &lt;span style="color:#75715e">// 👈 只能操作 pokemonList&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">default&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>只是这样改动之后，之前定义的 combine 就无法编译通过，pokemonListReducer 的签名已经不符合 combine 的要求了。&lt;/p>
&lt;blockquote>
&lt;p>Cannot convert value of type ‘(inout PokemonList, AppAction) -&amp;gt; ()’ to expected argument&lt;/p>
&lt;/blockquote>
&lt;h3 id="拉回">
拉回
&lt;a href="#%e6%8b%89%e5%9b%9e" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h3>
&lt;p>解决这个问题可以引入一个数学中的概念 —— 拉回。&lt;/p>
&lt;blockquote>
&lt;p>引用 wikipedia 上的解释：“简单地说，设 &lt;em>f&lt;/em> 是一个变量 &lt;em>y&lt;/em> 的函数，这里 &lt;em>y&lt;/em> 自身又是另一个变量 &lt;em>x&lt;/em> 的函数，那么 &lt;em>f&lt;/em> 可以写成 &lt;em>x&lt;/em> 的函数，这即 &lt;em>f&lt;/em> 被函数 &lt;em>y&lt;/em>(&lt;em>x&lt;/em>) 拉回。”&lt;/p>
&lt;/blockquote>
&lt;p>在 reducer 中的例子里，也可以套用相同的概念。只需要将持有了部分状态数据的 reducer，转化成一个拥有着全部状态数据的 reducer 签名即可：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">pullback&lt;/span>&amp;lt;LocalValue, GlobalValue, Action&amp;gt;(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">_&lt;/span> reducer: @escaping (&lt;span style="color:#66d9ef">inout&lt;/span> LocalValue, Action) -&amp;gt; Void,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">get&lt;/span>: @escaping (GlobalValue) -&amp;gt; LocalValue,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">set&lt;/span>: @escaping (&lt;span style="color:#66d9ef">inout&lt;/span> GlobalValue, LocalValue) -&amp;gt; Void
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>) -&amp;gt; (&lt;span style="color:#66d9ef">inout&lt;/span> GlobalValue, Action) -&amp;gt; Void {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> { globalValue, action &lt;span style="color:#66d9ef">in&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> localValue = &lt;span style="color:#66d9ef">get&lt;/span>(globalValue)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> reducer(&amp;amp;localValue, action)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">set&lt;/span>(&amp;amp;globalValue, localValue)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>该函数包含三个入参：&lt;/p>
&lt;ol>
&lt;li>用于处理局部状态的 reducer&lt;/li>
&lt;li>提供从全部状态中提取部分状态的函数&lt;/li>
&lt;li>提供将局部状态设置到全部状态中的函数&lt;/li>
&lt;/ol>
&lt;p>这样就得到了一个可以用来转化用于处理局部状态 reducer 到全部状态 reducer 的 pullback 函数：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>pullback(pokemonListReducer,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">get&lt;/span>: { $0.pokemonList },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">set&lt;/span>: { $0.pokemonList = $1 }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>再进一步还可以通过 keyPath 来优化 pullback 函数：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">pullback&lt;/span>&amp;lt;LocalValue, GlobalValue, Action&amp;gt;(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">_&lt;/span> reducer: @escaping (&lt;span style="color:#66d9ef">inout&lt;/span> LocalValue, Action) -&amp;gt; Void,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> value: WritableKeyPath&amp;lt;GlobalValue, LocalValue&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>) -&amp;gt; (&lt;span style="color:#66d9ef">inout&lt;/span> GlobalValue, Action) -&amp;gt; Void {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> { globalValue, action &lt;span style="color:#66d9ef">in&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> reducer(&amp;amp;globalValue[keyPath: value], action)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pullback(pokemonListReducer, value: &lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>AppState.pokemonList)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样就实现了 reducer 的拆分以及对处理状态的隔离&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> appReducer = combine(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pullback(accountReducer, value: &lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>.pokemonList),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pullback(pokemonListReducer, value: &lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>.settings),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pullback(favoritePokemonReducer, value: &lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>.favoritePokemons)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="参考资料">
参考资料
&lt;a href="#%e5%8f%82%e8%80%83%e8%b5%84%e6%96%99" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://objccn.io/products/swift-ui">ObjC 中国 - SwiftUI 与 Combine 编程&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.pointfree.co/collections/composable-architecture/reducers-and-stores/ep69-composable-state-management-state-pullbacks#downloads">Point Free - State Pullbacks&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.swiftbysundell.com/articles/the-power-of-key-paths-in-swift/">Swift by Sundell - The power of key paths in Swift&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>SwiftUI 状态管理 —— Composible Binding</title><link>https://joeytat.github.io/posts/composible_binding/</link><pubDate>Mon, 03 Jan 2022 00:00:00 +0000</pubDate><guid>https://joeytat.github.io/posts/composible_binding/</guid><description>
&lt;p>在 SwiftUI 中，需要通过数据来驱动 UI 的变化。数据结构抽象描述的质量也影响着我们对 SwiftUI 界面的维护。&lt;/p>
&lt;p>通常数据中可能存在很多状态，如果使用很多的 boolean 值来描述这些状态，那么 App 的可维护性可能会大大降低。&lt;/p>
&lt;h2 id="管理独立状态的问题">
管理独立状态的问题
&lt;a href="#%e7%ae%a1%e7%90%86%e7%8b%ac%e7%ab%8b%e7%8a%b6%e6%80%81%e7%9a%84%e9%97%ae%e9%a2%98" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h2>
&lt;p>假设我们有一个 App，用户可以在登录与非登录状态下进行操作。所以我们的界面需要兼容这两种状态，其描述可能是这样的：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">AppState&lt;/span>: ObservableObject {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @Published &lt;span style="color:#66d9ef">var&lt;/span> user: User? = &lt;span style="color:#66d9ef">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @Published &lt;span style="color:#66d9ef">var&lt;/span> error: Error? = &lt;span style="color:#66d9ef">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> authenticated: Bool { user &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> hasError: Bool { error &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>基于这样的状态描述，如果我们想创建一个仅展示用户名的组件大概会是这样：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> body: some View {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Group {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> state.hasError {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Text(&lt;span style="color:#e6db74">&amp;#34;Oops, sth went wrong: &lt;/span>&lt;span style="color:#e6db74">\(&lt;/span>state.error!.localizedDescription&lt;span style="color:#e6db74">)&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> state.authenticated {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Text(&lt;span style="color:#e6db74">&amp;#34;Hello &lt;/span>&lt;span style="color:#e6db74">\(&lt;/span>state.user?.name ?? &lt;span style="color:#e6db74">&amp;#34;Unknown&amp;#34;&lt;/span>&lt;span style="color:#e6db74">)&lt;/span>&lt;span style="color:#e6db74">!&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Text(&lt;span style="color:#e6db74">&amp;#34;Hello, stranger&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>粗看没有什么问题，实际上在维护这样的数据结构时就需要格外小心了。比如第一次我们登录失败，为了展示错误信息给 &lt;code>error&lt;/code> 设置了值之后。必须在登录成功之后要及时地去清空 error，否则即使 &lt;code>state.authenticated&lt;/code> 等于 &lt;code>true&lt;/code>，用户依然无法看到正确的信息。&lt;/p>
&lt;p>这还仅仅是有两个状态的情况下，像这样独立状态属性会带来很大的维护成本，开发者需要牢记各个属性之间的依赖关系，甚至编写界面的时候，还需要注意代码执行顺序。&lt;/p>
&lt;h2 id="引入状态机">
引入状态机
&lt;a href="#%e5%bc%95%e5%85%a5%e7%8a%b6%e6%80%81%e6%9c%ba" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h2>
&lt;p>把状态抽象成带有 associated values 的 enum 是个更好的选择，比如:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">AppState&lt;/span>: ObservableObject {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">enum&lt;/span> &lt;span style="color:#a6e22e">AccountState&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> authenticated(User)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> unauthenticated
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> error(Error)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @Published &lt;span style="color:#66d9ef">var&lt;/span> accountState: AccountState = .unauthenticated
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 界面中的使用&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> body: some View {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> VStack {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">switch&lt;/span> state.accountState {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> .authenticated(&lt;span style="color:#66d9ef">let&lt;/span> user):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Text(&lt;span style="color:#e6db74">&amp;#34;Hello &lt;/span>&lt;span style="color:#e6db74">\(&lt;/span>user.name&lt;span style="color:#e6db74">)&lt;/span>&lt;span style="color:#e6db74">!&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> .unauthenticated:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Text(&lt;span style="color:#e6db74">&amp;#34;unregister&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> .error(&lt;span style="color:#66d9ef">let&lt;/span> error):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Text(&lt;span style="color:#e6db74">&amp;#34;Oops, sth went wrong: &lt;/span>&lt;span style="color:#e6db74">\(&lt;/span>error.localizedDescription&lt;span style="color:#e6db74">)&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样被状态机驱动的界面看起来要直观多了。并且在每个状态中对数据的操作，也由 enum 赋予了隔离能力。&lt;/p>
&lt;h2 id="双向绑定怎么办">
双向绑定怎么办？
&lt;a href="#%e5%8f%8c%e5%90%91%e7%bb%91%e5%ae%9a%e6%80%8e%e4%b9%88%e5%8a%9e" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h2>
&lt;p>但这样做又来带个新的问题，现在没办法直接通过 &lt;code>$&lt;/code> 来获取 Binding wrapper 来修改状态：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">switch&lt;/span> state.accountState {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> .authenticated(&lt;span style="color:#66d9ef">let&lt;/span> user):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Text(&lt;span style="color:#e6db74">&amp;#34;Hello &lt;/span>&lt;span style="color:#e6db74">\(&lt;/span>user.name&lt;span style="color:#e6db74">)&lt;/span>&lt;span style="color:#e6db74">!&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TextField(&lt;span style="color:#e6db74">&amp;#34;Change username&amp;#34;&lt;/span>, text: &amp;lt;Binding&amp;lt;String&amp;gt;&lt;span style="color:#f92672">&amp;gt;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 不支持填入 self.$state.accountState.name 👆&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>Xcode 会提示: dynamic member &amp;rsquo;name&amp;rsquo; using key path from root type &amp;lsquo;AppState.AccountState&amp;rsquo;&lt;/p>
&lt;/blockquote>
&lt;p>为什么当操作对象是 class 时，是可以做到通过
&lt;code>self.$state.user.name&lt;/code> 来获取到 name 属性的 Binding 封装的？&lt;/p>
&lt;h2 id="实现动态成员查找dynamic-member-lookup">
实现动态成员查找(dynamic member lookup)
&lt;a href="#%e5%ae%9e%e7%8e%b0%e5%8a%a8%e6%80%81%e6%88%90%e5%91%98%e6%9f%a5%e6%89%bedynamic-member-lookup" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h2>
&lt;p>因为 Enum 还不支持动态成员查找特性。什么是动态成员查找？简而言之就是通过 &lt;code>\&lt;/code> 来获取到成员属性的 &lt;code>KeyPath&lt;/code> 封装（&lt;a href="https://www.swiftbysundell.com/articles/the-power-of-key-paths-in-swift/">什么又是 KeyPath&lt;/a>？），然后将其转化为对应的 Binding 封装。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">extension&lt;/span> &lt;span style="color:#a6e22e">Binding&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">transform&lt;/span>&amp;lt;LocalValue&amp;gt;(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">_&lt;/span> keyPath: WritableKeyPath&amp;lt;Value, LocalValue&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ) -&amp;gt; Binding&amp;lt;LocalValue&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Binding&amp;lt;LocalValue&amp;gt;(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">get&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">self&lt;/span>.wrappedValue[keyPath: keyPath]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">set&lt;/span>: { localValue &lt;span style="color:#66d9ef">in&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">self&lt;/span>.wrappedValue[keyPath: keyPath] = localValue
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">self&lt;/span>.&lt;span style="color:#960050;background-color:#1e0010">$&lt;/span>state.accountState.username
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 等价于 &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">self&lt;/span>.&lt;span style="color:#960050;background-color:#1e0010">$&lt;/span>state.transform(&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>accountState).transform(&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>username)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>所以接下来只需要为 enum 添加动态成员查找的支持就可以了&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">extension&lt;/span> &lt;span style="color:#a6e22e">Binding&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">unwrap&lt;/span>&amp;lt;Wrapped&amp;gt;() -&amp;gt; Binding&amp;lt;Wrapped&amp;gt;? &lt;span style="color:#66d9ef">where&lt;/span> Value == Wrapped? {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">guard&lt;/span> &lt;span style="color:#66d9ef">let&lt;/span> value = &lt;span style="color:#66d9ef">self&lt;/span>.wrappedValue &lt;span style="color:#66d9ef">else&lt;/span> { &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Binding&amp;lt;Wrapped&amp;gt;(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">get&lt;/span>: { value },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">set&lt;/span>: { &lt;span style="color:#66d9ef">self&lt;/span>.wrappedValue = $0 }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后再到 enum 里添加一个计算属性方便我们获取&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">enum&lt;/span> &lt;span style="color:#a6e22e">AccountState&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> loggedIn(User)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> unregister
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> username: String? {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">get&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">guard&lt;/span> &lt;span style="color:#66d9ef">case&lt;/span> .loggedIn(&lt;span style="color:#66d9ef">let&lt;/span> user) = &lt;span style="color:#66d9ef">self&lt;/span> &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> user.username
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">set&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">guard&lt;/span> &lt;span style="color:#66d9ef">case&lt;/span> .loggedIn(&lt;span style="color:#66d9ef">let&lt;/span> user) = &lt;span style="color:#66d9ef">self&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> newValue = newValue &lt;span style="color:#66d9ef">else&lt;/span> { &lt;span style="color:#66d9ef">return&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> user.username = newValue
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">self&lt;/span> = .loggedIn(user)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>现在就可以在 SwiftUI 中对 enum 使用绑定了&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#66d9ef">let&lt;/span> username = &lt;span style="color:#66d9ef">self&lt;/span>.&lt;span style="color:#960050;background-color:#1e0010">$&lt;/span>state.accountState.username.unwrap() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TextField(&lt;span style="color:#e6db74">&amp;#34;Change username&amp;#34;&lt;/span>, text: username)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>看起来还是有些麻烦，对于每个要使用 Binding 的属性都需要去写一个计算属性来包装一层。这样显然这并不如 &lt;code>KeyPath&lt;/code> 那样，直接通过 &lt;code>self.$state.accountState[\.authenticated]&lt;/code> 来获取到 enum 中 associated value 的 Binding 包装来得方便。&lt;/p>
&lt;p>虽然 Swift 目前不支持，但我们还是可以通过引入 &lt;a href="https://github.com/pointfreeco/swift-case-paths">CasePaths&lt;/a> 这个第三方依赖来实现。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">import&lt;/span> &lt;span style="color:#a6e22e">CasePaths&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">enum&lt;/span> &lt;span style="color:#a6e22e">AccountState&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> authenticated(User)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> unauthenticated
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> error(Error)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 计算属性可以删除掉了&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// var username: String? {&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// get {&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// guard case .authenticated(let user) = self else {&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// return nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// }&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// return user.name&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// }&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// set {&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// guard case .authenticated(let user) = self,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// let newValue = newValue else { return }&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// user.name = newValue&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// self = .authenticated(user)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// }&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// }&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 界面中直接使用 CasePath&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#66d9ef">let&lt;/span> user = &lt;span style="color:#66d9ef">self&lt;/span>.&lt;span style="color:#960050;background-color:#1e0010">$&lt;/span>state.accountState.matching(&lt;span style="color:#f92672">/&lt;/span>.authenticated) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TextField(&lt;span style="color:#e6db74">&amp;#34;Change username&amp;#34;&lt;/span>, text: user.name)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>由此为 Enum 也增加了与 Struct、Class 等效的 KeyPath 支持，从而使得文章开头用 Enum 作为 SwiftUI 的状态机管理工具更便捷了一些。&lt;/p>
&lt;h2 id="参考资料">
参考资料
&lt;a href="#%e5%8f%82%e8%80%83%e8%b5%84%e6%96%99" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://kentcdodds.com/blog/stop-using-isloading-booleans">Stop using isLoading booleans&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.swiftbysundell.com/articles/the-power-of-key-paths-in-swift/">The power of key paths in Swift&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.pointfree.co/collections/swiftui/composable-bindings/ep107-composable-swiftui-bindings-the-problem">Composable SwiftUI Bindings: The Problem&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>JavaScript 既然是单线程语言，为什么 setTimeout 不会阻塞线程？</title><link>https://joeytat.github.io/posts/asynchronous-javascript/</link><pubDate>Mon, 19 Aug 2019 00:00:00 +0000</pubDate><guid>https://joeytat.github.io/posts/asynchronous-javascript/</guid><description>
&lt;p>先看下面的代码&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">printHello&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Hello&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">printWorld&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;World&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">printHello&lt;/span>(); &lt;span style="color:#75715e">// 输出 Hello
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">printWorld&lt;/span>(); &lt;span style="color:#75715e">// 输出 World
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在 JavaScript 中，存在一个全局调用栈(Global Call Stack)。当我们调用 &lt;code>printHello&lt;/code> 时，会将该方法加入到栈中，由于 JavaScript 是单线程执行机制（同一时间只执行一个命令），所以会在执行完成了 &lt;code>printHello&lt;/code> 之后再执行 &lt;code>printWorld&lt;/code>。&lt;/p>
&lt;p>那么现在就引入标题中的问题，&lt;strong>JavaScript 既然是单线程语言，为什么 setTimeout 不会阻塞线程？&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">printHello&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Hello&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">printWorld&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;World&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">setTimeout&lt;/span>(&lt;span style="color:#a6e22e">printHello&lt;/span>, &lt;span style="color:#ae81ff">1000&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">printWorld&lt;/span>();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>表面上来看 &lt;code>setTimeout&lt;/code> 也是一个方法，他的定义可能是这样：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">setTimeout&lt;/span>(&lt;span style="color:#a6e22e">callbackFunc&lt;/span>, &lt;span style="color:#a6e22e">interval&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ....
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>那么按照 JS 单线程理论来说，应该是先将 &lt;code>setTimeout&lt;/code> 方法压入全局调用栈，并且执行该方法，等待 1 秒钟，然后再执行 &lt;code>printWorld&lt;/code> 才对。但实际上我们都知道，打印的结果会是 &amp;ldquo;World&amp;rdquo; 然后 &amp;ldquo;Hello&amp;rdquo;，这是为什么？&lt;/p>
&lt;h3 id="web-browser-api---callback-queue">
Web Browser API &amp;amp; Callback Queue
&lt;a href="#web-browser-api---callback-queue" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h3>
&lt;p>事实上 &lt;code>setTimeout&lt;/code> 并不是完全是 JS 代码，而是属于 &lt;strong>Web Browser API&lt;/strong> 中的方法。就像名字中所指的那样， JS 调用了 &lt;code>setTimeout&lt;/code> 之后，浏览器（Web Browser）会去创建一个 timer，同时将我们传入 &lt;code>setTimeout&lt;/code> 的方法 - &lt;code>printHello&lt;/code> 加入到 &lt;strong>Callback Queue（回调队列）&lt;/strong> 中。&lt;/p>
&lt;p>1000 毫秒过去后，浏览器会通知 JavaScript 引擎将回调队列中的 &lt;code>printHello&lt;/code> 加入到 JS 的全局调用栈中执行。&lt;/p>
&lt;p>所以在 JS 的全局调用栈看来，是先有一个 &lt;code>printWorld&lt;/code> 加入到了调用栈，过了 1000 毫秒之后，又加入了一个 &lt;code>printHello&lt;/code> 方法。&lt;/p>
&lt;p>那如果我们的 &lt;code>printWorld&lt;/code> 之后还有其他的方法执行时间超过了 1000 毫秒呢？&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/// 省略掉 printHello 和 printWorld 定义
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">heavyWork&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">1000000&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Heavy Work&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">setTimeout&lt;/span>(&lt;span style="color:#a6e22e">printHello&lt;/span>, &lt;span style="color:#ae81ff">1000&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">printWorld&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">heavyWork&lt;/span>(); &lt;span style="color:#75715e">// 假设会执行 2000ms
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>现在让我们假设 &lt;code>heavyWork&lt;/code> 方法会执行 2000ms，可是我们的 &lt;code>setTimeout&lt;/code> 只会执行 1000ms，那么按照上面的理论，1000ms 到了之后，&lt;code>printHello&lt;/code> 会被加入到 JS 的调用栈中执行，那现在的输出会是一堆“Heavy Work”之中夹带着一个“Hello”吗？&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">World&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">Heavy&lt;/span> &lt;span style="color:#a6e22e">Work&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">Hello&lt;/span> &lt;span style="color:#75715e">// 会输出一堆 Heavy Work 中夹带一个 Hello 吗？
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">Heavy&lt;/span> &lt;span style="color:#a6e22e">Work&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>当然不会啦，因为我们有 Event Loop（事件循环机制）。&lt;/p>
&lt;h3 id="event-loop">
Event Loop
&lt;a href="#event-loop" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h3>
&lt;p>Event Loop 其实理解起来非常简单，就是一个循环会不停地检查 JS 调用栈。只有在 JS 调用栈&lt;strong>没有任务&lt;/strong>的情况下，Callback Queue 中的任务，才会被添加到 JS 调用栈。&lt;/p>
&lt;p>所以上面的代码中，&lt;code>setTimeout&lt;/code> 虽然指定了 1000ms 之后就执行 &lt;code>printHello&lt;/code>，但实际上会被需要执行 2000ms 的 &lt;code>heavyWork&lt;/code>阻塞住， 输出的结果会是：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">World&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">Heavy&lt;/span> &lt;span style="color:#a6e22e">Work&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>.... &lt;span style="color:#75715e">// 长达 2000ms 的 Heavy Work
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">Heavy&lt;/span> &lt;span style="color:#a6e22e">Work&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">Hello&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="总结">
总结
&lt;a href="#%e6%80%bb%e7%bb%93" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>Web Browser API&lt;br>
提供给我们 JavaScript 所没有后台运行任务的能力，除了 &lt;code>setTimeout&lt;/code> 和 &lt;code>setInterval&lt;/code> 这样创建 timer 的 API 之外，还包括了 Ajax，用户交互，文件读写等操作。&lt;/li>
&lt;li>Callback Queue&lt;br>
用于持有提交到 Web Browser API 中等待回调的 callback。&lt;/li>
&lt;li>Event Loop&lt;br>
一个不停地检查 JavaScript 调用栈中是否还有任务的循环。&lt;/li>
&lt;/ul></description></item><item><title>React 进阶模式之复合组件（Compound Component）</title><link>https://joeytat.github.io/posts/compound-component/</link><pubDate>Mon, 12 Aug 2019 00:00:00 +0000</pubDate><guid>https://joeytat.github.io/posts/compound-component/</guid><description>
&lt;h3 id="复合组件是什么">
复合组件是什么
&lt;a href="#%e5%a4%8d%e5%90%88%e7%bb%84%e4%bb%b6%e6%98%af%e4%bb%80%e4%b9%88" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h3>
&lt;p>编写页面时，经常存在多个子组件的展示，是依赖于同一个数据源的情况。
比如单选框：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-jsx" data-lang="jsx">&lt;span style="display:flex;">&lt;span>&amp;lt;&lt;span style="color:#f92672">Switcher&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;&lt;span style="color:#f92672">Switch&lt;/span> &lt;span style="color:#a6e22e">on&lt;/span>&lt;span style="color:#f92672">=&lt;/span>{&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">props&lt;/span>.&lt;span style="color:#a6e22e">selecting&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;React&amp;#39;&lt;/span>}&amp;gt;&lt;span style="color:#a6e22e">React&lt;/span>&amp;lt;/&lt;span style="color:#f92672">Switch&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;&lt;span style="color:#f92672">Switch&lt;/span> &lt;span style="color:#a6e22e">on&lt;/span>&lt;span style="color:#f92672">=&lt;/span>{&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">props&lt;/span>.&lt;span style="color:#a6e22e">selecting&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;Vue&amp;#39;&lt;/span>}&amp;gt;&lt;span style="color:#a6e22e">Vue&lt;/span>&amp;lt;/&lt;span style="color:#f92672">Switch&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;lt;/&lt;span style="color:#f92672">Switcher&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们可以看到，所有的 &lt;code>Switch&lt;/code> 的数据都需要对 &lt;code>selecting&lt;/code> 的值进行判断，并且代码中其实只有 &lt;code>this.props.selecting ==&lt;/code> 后面的部分不同，如果能改写成这样：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-jsx" data-lang="jsx">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#a6e22e">Switcher&lt;/span>.&lt;span style="color:#a6e22e">React&lt;/span> &lt;span style="color:#f92672">=&lt;/span> ({&lt;span style="color:#a6e22e">selecting&lt;/span>}) =&amp;gt; (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;&lt;span style="color:#f92672">Switch&lt;/span> &lt;span style="color:#a6e22e">on&lt;/span>&lt;span style="color:#f92672">=&lt;/span>{&lt;span style="color:#a6e22e">selecting&lt;/span> &lt;span style="color:#f92672">===&lt;/span> &lt;span style="color:#e6db74">&amp;#39;React&amp;#39;&lt;/span>}&amp;gt;&lt;span style="color:#a6e22e">React&lt;/span>&amp;lt;/&lt;span style="color:#f92672">Switch&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#a6e22e">Switcher&lt;/span>.&lt;span style="color:#a6e22e">Vue&lt;/span> &lt;span style="color:#f92672">=&lt;/span> ({&lt;span style="color:#a6e22e">selecting&lt;/span>}) =&amp;gt; (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;&lt;span style="color:#f92672">Switch&lt;/span> &lt;span style="color:#a6e22e">on&lt;/span>&lt;span style="color:#f92672">=&lt;/span>{&lt;span style="color:#a6e22e">selecting&lt;/span> &lt;span style="color:#f92672">===&lt;/span> &lt;span style="color:#e6db74">&amp;#39;Vue&amp;#39;&lt;/span>}&amp;gt;&lt;span style="color:#a6e22e">Vue&lt;/span>&amp;lt;/&lt;span style="color:#f92672">Switch&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;lt;&lt;span style="color:#f92672">Switcher&lt;/span> &lt;span style="color:#a6e22e">selecting&lt;/span>&lt;span style="color:#f92672">=&lt;/span>{&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">props&lt;/span>.&lt;span style="color:#a6e22e">selecting&lt;/span>}&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;&lt;span style="color:#f92672">Switcher.React&lt;/span>/&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;&lt;span style="color:#f92672">Switcher.Vue&lt;/span>/&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;lt;/&lt;span style="color:#f92672">Switcher&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>隐式地将父组件的数据传递给子组件，其显示逻辑交由给子组件自行处理，代码的组织结构将会清晰很多。后续即使需求变动，数据的传递改变也并不需要我们操心（不需要一个子组件一个子组件地添加传递），只需要修改 &lt;code>Switcher&lt;/code> 子控件内部处理逻辑即可。&lt;/p>
&lt;p>那么要怎么实现这个&lt;strong>隐式数据传递&lt;/strong>呢？ 可以通过 &lt;a href="https://reactjs.org/docs/react-api.html#reactchildren">&lt;code>React.Children.map&lt;/code>&lt;/a> 和 &lt;a href="https://reactjs.org/docs/react-api.html#cloneelement">&lt;code>React.cloneElement&lt;/code>&lt;/a> 这两个 API 来实现。&lt;/p>
&lt;h3 id="reactchildrenmap-与-reactcloneelement">
React.Children.map 与 React.cloneElement
&lt;a href="#reactchildrenmap-%e4%b8%8e-reactcloneelement" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h3>
&lt;p>在 &lt;code>render&lt;/code> 中我们可以使用 &lt;code>React.Children.map&lt;/code> 来获取到 &lt;code>Switcher&lt;/code> 中的子组件，然后通过 &lt;code>React.cloneElement&lt;/code> 对组件进行克隆及数据传递：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-jsx" data-lang="jsx">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">render&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">React&lt;/span>.&lt;span style="color:#a6e22e">Children&lt;/span>.&lt;span style="color:#a6e22e">map&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">props&lt;/span>.&lt;span style="color:#a6e22e">children&lt;/span>, &lt;span style="color:#a6e22e">child&lt;/span> =&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">React&lt;/span>.&lt;span style="color:#a6e22e">cloneElement&lt;/span>(&lt;span style="color:#a6e22e">child&lt;/span>, {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">on&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">state&lt;/span>.&lt;span style="color:#a6e22e">on&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">toggle&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">toggle&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样，即使我们在使用 &lt;code>Switcher.React&lt;/code> 和 &lt;code>Switcher.Vue&lt;/code> 时，没有显式地传递参数，子组件也能获取数据。&lt;/p>
&lt;blockquote>
&lt;p>这里 &lt;code>React.Children.map&lt;/code> 与 &lt;code>this.props.children.map&lt;/code> 并不等价，后者在只有一个子组件的时候，返回的不是数组，而是唯一的那个组件。&lt;/p>
&lt;/blockquote>
&lt;h3 id="reactchildrenmap-的局限性">
React.Children.map 的局限性
&lt;a href="#reactchildrenmap-%e7%9a%84%e5%b1%80%e9%99%90%e6%80%a7" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h3>
&lt;p>上面代码有个问题是，如果出现了更多层级的子组件，那么参数传递只会到第一层。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-jsx" data-lang="jsx">&lt;span style="display:flex;">&lt;span>&amp;lt;&lt;span style="color:#f92672">Switcher&lt;/span> &lt;span style="color:#a6e22e">selecting&lt;/span>&lt;span style="color:#f92672">=&lt;/span>{&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">props&lt;/span>.&lt;span style="color:#a6e22e">selecting&lt;/span>}&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;&lt;span style="color:#f92672">Switcher.React&lt;/span>/&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;&lt;span style="color:#f92672">div&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;&lt;span style="color:#f92672">Switcher.Vue&lt;/span>/&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;/&lt;span style="color:#f92672">div&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;lt;/&lt;span style="color:#f92672">Switcher&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样写会提示传递了错误的参数给 &lt;code>div&lt;/code>，因为我们 &lt;code>React.Children.map&lt;/code> 只能获取到第一层子组件（&lt;code>[Switcher.React, div]&lt;/code>）。&lt;/p>
&lt;p>那怎么办，难道要用递归？React 16.x 提供了新的 &lt;a href="https://reactjs.org/docs/context.html#when-to-use-context">Context&lt;/a> 可以很好地解决这个问题。&lt;/p>
&lt;p>Context 的使用方法很简单，首先创建一个 Context：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-jsx" data-lang="jsx">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">selecting&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">SwitcherContext&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">React&lt;/span>.&lt;span style="color:#a6e22e">createContext&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>接着是 &lt;code>render&lt;/code>，既然我们不确定会有多少层的子组件，那么就直接将 &lt;code>this.props.children&lt;/code> 包裹在 &lt;code>Context.Provider&lt;/code> 中：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-jsx" data-lang="jsx">&lt;span style="display:flex;">&lt;span>&amp;lt;&lt;span style="color:#f92672">SwitcherContext.Provider&lt;/span> &lt;span style="color:#a6e22e">value&lt;/span>&lt;span style="color:#f92672">=&lt;/span>{&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">props&lt;/span>.&lt;span style="color:#a6e22e">selecting&lt;/span>}&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">props&lt;/span>.&lt;span style="color:#a6e22e">children&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;lt;/&lt;span style="color:#f92672">SwitcherContext.Provider&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后改写我们的子组件数据获取方式，之前是通过 &lt;code>React.cloneElement&lt;/code> 来将数据通过 &lt;code>props&lt;/code> 传递到组件中，现在可以直接从 &lt;code>Context.Consumer&lt;/code> 中获取：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-jsx" data-lang="jsx">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#a6e22e">Switcher&lt;/span>.&lt;span style="color:#a6e22e">React&lt;/span> &lt;span style="color:#f92672">=&lt;/span>() =&amp;gt; (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;&lt;span style="color:#f92672">SwitcherContext.Consumer&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> { &lt;span style="color:#a6e22e">selecting&lt;/span> =&amp;gt; (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;&lt;span style="color:#f92672">Switch&lt;/span> &lt;span style="color:#a6e22e">on&lt;/span>&lt;span style="color:#f92672">=&lt;/span>{&lt;span style="color:#a6e22e">selecting&lt;/span> &lt;span style="color:#f92672">===&lt;/span> &lt;span style="color:#e6db74">&amp;#39;React&amp;#39;&lt;/span>}&amp;gt;&lt;span style="color:#a6e22e">React&lt;/span>&amp;lt;/&lt;span style="color:#f92672">Switch&lt;/span>&amp;gt;)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;/&lt;span style="color:#f92672">SwitcherContext.Consumer&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如此一来就完成了我们的改造。外部使用到 &lt;code>Switcher&lt;/code> 的地方没有任何变动，依然是：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-jsx" data-lang="jsx">&lt;span style="display:flex;">&lt;span>&amp;lt;&lt;span style="color:#f92672">Switcher&lt;/span> &lt;span style="color:#a6e22e">selecting&lt;/span>&lt;span style="color:#f92672">=&lt;/span>{&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">props&lt;/span>.&lt;span style="color:#a6e22e">selecting&lt;/span>}&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;&lt;span style="color:#f92672">Switcher.React&lt;/span>/&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;&lt;span style="color:#f92672">div&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;&lt;span style="color:#f92672">Switcher.Vue&lt;/span>/&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;/&lt;span style="color:#f92672">div&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;lt;/&lt;span style="color:#f92672">Switcher&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="相关资料">
相关资料
&lt;a href="#%e7%9b%b8%e5%85%b3%e8%b5%84%e6%96%99" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h4>
&lt;ul>
&lt;li>&lt;a href="https://frontendmasters.com/courses/advanced-react-patterns/">Frontend Masters - Advanced React Patterns&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://reactjs.org/docs/context.html#when-to-use-context">React Context&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>翻译 - 图像优化</title><link>https://joeytat.github.io/posts/optimizing_images/</link><pubDate>Wed, 19 Jun 2019 00:00:00 +0000</pubDate><guid>https://joeytat.github.io/posts/optimizing_images/</guid><description>
&lt;p>翻译自 &lt;a href="https://www.swiftjectivec.com/optimizing-images/">Optimizing Images&lt;/a> by &lt;a href="https://twitter.com/jordanmorgan10">Jordan Morgan&lt;/a>&lt;/p>
&lt;p>有句话说：最好的照相机就是在你身边的那台。 如果这句俗语是对的，那么毫无疑问地— iPhone 是这个星球上最重要的相机， 并且我们的业界也证明了这一点。&lt;/p>
&lt;p>在度假中? 如果没有在你的 Instagram Story 中留下几张照片，那就不算发生过。&lt;/p>
&lt;p>爆炸新闻? 立刻打开 Twitter 来查看哪些媒体在通过照片实时报道事件。&lt;/p>
&lt;p>等等。&lt;/p>
&lt;p>由于图像在各个平台无处不在的出现，在低性能且内存紧张的情况下展示它们，会很容易地造成失控。 如果我们知道 UIKit 底层到底发生了什么，为什么以及如何处理图像，那么我们可以节省大量的资源开销，并且逃脱无情的系统清除制裁。&lt;/p>
&lt;h2 id="理论上来说">
理论上来说
&lt;a href="#%e7%90%86%e8%ae%ba%e4%b8%8a%e6%9d%a5%e8%af%b4" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h2>
&lt;p>突击测验 - 这张我女儿的 266 KB 字节大小（并且还蛮时尚的）的照片，在一个 iOS App 中会展示需要用到多少内存?&lt;/p>
&lt;p>&lt;img src="https://www.swiftjectivec.com/assets/images/baylor.jpg" alt="Baylor">&lt;/p>
&lt;p>剧透一下 - 不是 266 KB，也不是 2.66 MB，而是大概 14 MB。&lt;/p>
&lt;p>为什么?&lt;/p>
&lt;p>本质上来说 iOS 申请内存是根据图像的尺寸 - 而图像的文件大小反而影响不大。 这张图片的尺寸是 1718 x 2048 像素。 假设每个像素会占用 4 个字节:&lt;/p>
&lt;blockquote>
&lt;p>1718 * 2048 * 4 / 1024 / 1024 = 13.42 MB 大约&lt;/p>
&lt;/blockquote>
&lt;p>想象一下，如果你需要展示一个列表的用户信息，其中每一行都显示一个常见的圆形头像在左侧。 如果你觉得每一张图片都通过 ImageOptim 或者其他方式处理过就没问题，那就错了。 保守估计每一张头像是 256 x 256 大小，那依然会耗费大量内存。&lt;/p>
&lt;h2 id="渲染路径">
渲染路径
&lt;a href="#%e6%b8%b2%e6%9f%93%e8%b7%af%e5%be%84" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h2>
&lt;p>这就是说 - 明白底层是怎么回事是很划算的。 当你加载一张图片的时候，会经由这三步处理:&lt;/p>
&lt;p>1） 加载 - iOS 会获取到尚未解压的图片，然后开辟（我们的图片举例） 266 kb 的内存，目前为止没什么好担心的。&lt;/p>
&lt;p>2） 解码 - 现在 iOS 会将图片转化为 GPU 可以读取并且处理的数据。 现在是解压，在这一步就会产生我们上面提到的 14 MB 的内存开销。&lt;/p>
&lt;p>3） 渲染 - 按照字面意思理解，现在图片数据准备好了以任何方式进行渲染。 即使是放在 60 x 60 point 的 image view 中。&lt;/p>
&lt;p>解码阶段是大头。 在这里 iOS 会创建一个缓冲区 - 准确的说是图片缓冲区。 这里会将图像放在内存中。 这也是为什么，其内存占用会和图片尺寸挂钩而不是图片文件大小。 这就清晰地解释了，当处理图片时，为什么尺寸对于内存消耗如此重要。&lt;/p>
&lt;p>针对 &lt;code>UIImage&lt;/code>， 当我们把从网络请求或者其他途径获取的图片数据传递给它时，它会将缓冲区的数据解码成数据声称的格式（比如 PNG 或者 JPEG）。 然而它就会在这停顿了。 由于渲染并非只是一次性操作，&lt;code>UIImage&lt;/code> 会保留这个数据缓冲，这样它只需要解码一次。&lt;/p>
&lt;p>我们来扩展一下这个概念 - 对于任何 iOS App 来说一个完整的缓冲区就是其帧缓冲区。 这就是当 app 展示在屏幕上时，负责持有输出渲染内容的东西。 任何 iOS 设备上的显示硬件，都会使用其中的像素信息来点亮对应的物理屏幕像素。&lt;/p>
&lt;p>此处时间很重要。 为了达到每秒 60 帧如黄油般顺滑的滚动效果，在 app 的 window 及其 subviews 改变的时候（比如分配了一个 image 给 image view），帧缓冲区需要 UIKit 来渲染。 如果渲染慢了，就会掉帧。&lt;/p>
&lt;blockquote>
&lt;p>觉得只有 1/60 秒处理时间太短了? 具备 Pro Motion 的设备只会给 1/120 秒的时间。&lt;/p>
&lt;/blockquote>
&lt;h2 id="大小真的很重要">
大小真的很重要
&lt;a href="#%e5%a4%a7%e5%b0%8f%e7%9c%9f%e7%9a%84%e5%be%88%e9%87%8d%e8%a6%81" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h2>
&lt;p>我们其实可以很轻松地观察到这步处理以及内存时如何被消耗掉的。 我创建了一个实验 app，用 image view 来展示了我女儿的照片。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> filePath = Bundle.main.path(forResource:&lt;span style="color:#e6db74">&amp;#34;baylor&amp;#34;&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">，&lt;/span>ofType: &lt;span style="color:#e6db74">&amp;#34;jpg&amp;#34;&lt;/span>)&lt;span style="color:#f92672">!&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> url = NSURL(fileURLWithPath: filePath)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> fileImage = UIImage(contentsOfFile: filePath)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Image view&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> imageView = UIImageView(image: fileImage)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>imageView.translatesAutoresizingMaskIntoConstraints = &lt;span style="color:#66d9ef">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>imageView.contentMode = .scaleAspectFit
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>imageView.widthAnchor.constraint(equalToConstant: &lt;span style="color:#ae81ff">300&lt;/span>).isActive = &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>imageView.heightAnchor.constraint(equalToConstant: &lt;span style="color:#ae81ff">400&lt;/span>).isActive = &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>view.addSubview(imageView)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>imageView.centerXAnchor.constraint(equalTo: view.centerXAnchor).isActive = &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>imageView.centerYAnchor.constraint(equalTo: view.centerYAnchor).isActive = &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>这里我们只是为了演示场景，在生产环境中请谨慎使用强制解包。&lt;/p>
&lt;/blockquote>
&lt;p>上面的代码运行起来时这样:&lt;/p>
&lt;p>&lt;img src="https://www.swiftjectivec.com/assets/images/baylorPhone.jpg" alt="Baylor">&lt;/p>
&lt;p>虽然我们使用了一个小得多的 Image View 来展示图片，但通过 LLDB 我们可以查看到图片实际的尺寸。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&amp;lt;UIImage: &lt;span style="color:#ae81ff">0x600003d41a40&lt;/span>&amp;gt;&lt;span style="color:#960050;background-color:#1e0010">，&lt;/span>{&lt;span style="color:#ae81ff">1718&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">，&lt;/span>&lt;span style="color:#ae81ff">2048&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>记住，这是点表示。 所以如果我使用的是 3x 或者 2x 设备，这个数字需要更大一些。 我们可以使用 vmmap 来确定这张图片是否真的占用了 14 MB。&lt;/p>
&lt;pre tabindex="0">&lt;code>vmmap --summary baylor.memgraph
&lt;/code>&lt;/pre>&lt;p>有几个东西引起了注意（为了简洁只截出了部分输出）:&lt;/p>
&lt;pre tabindex="0">&lt;code>Physical footprint: 69.5M
Physical footprint (peak): 69.7M
&lt;/code>&lt;/pre>&lt;p>接近 70 MB 给了我们一个很好的参考来确定我们的重构是否有效。 如果我们通过 grep 命令来筛选 Image IO，我们也能够看到图片的开销。&lt;/p>
&lt;pre tabindex="0">&lt;code>vmmap --summary baylor.memgraph | grep &amp;#34;Image IO&amp;#34;
Image IO 13.4M 13.4M 13.4M 0K 0K 0K 0K 2
&lt;/code>&lt;/pre>&lt;p>啊哈 - 这里就有接近 14 MB 的脏内存。 如同我们在餐巾纸背面写下的公式计算的那样。 背景补充一下，这是一个终端的屏幕截图，清楚地显示了每一列的含义。 （由于他们被 grep 命令给省略掉了）&lt;/p>
&lt;p>&lt;img src="https://www.swiftjectivec.com/assets/images/vmmap.jpg" alt="">&lt;/p>
&lt;p>所以很明确了，此刻我们在 300 x 400 的 image view 中也依然付出了图像的完整开销。 图像的大小是很关键，但这并不是唯一重要的点。&lt;/p>
&lt;h2 id="色域">
色域
&lt;a href="#%e8%89%b2%e5%9f%9f" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h2>
&lt;p>你所请求的内存消耗有一部分源于另一个重要因素 - 色域。 在上面的例子中我们做了一个假设，而这个假设并不适用于大多数 iPhone - 也就是图像采用的是 sRGB 格式。 每个像素 4 个字节对应的是红，蓝，绿以及透明。&lt;/p>
&lt;p>如果你使用的是支持广色域格式的设备（iPhone 8+ 或 iPhone X）进行拍摄，那就可以肯定数字会加倍了。 当然了，反过来也一样，Metal 支持使用 Alpha 8 格式，就像其名字描述的那样只有单一通道。&lt;/p>
&lt;p>这里有非常多需要考虑的东西。 这也是为什么你应该使用 &lt;a href="https://swiftjectivec.com/UIGraphicsImageRenderer">UIGraphicsImageRenderer&lt;/a> 而不是 &lt;code>UIGraphicsBeginImageContextWithOptions&lt;/code>。 后者会&lt;strong>一直&lt;/strong>使用 sRGB，这也意味着你会丢失广色域格式，如果你 &lt;a href="https://instagram-engineering.com/bringing-wide-color-to-instagram-5a5481802d7d">想要的话&lt;/a>，或是错失节省开销的机会。 在 iOS 12 之后，&lt;code>UIGraphicsImageRenderer&lt;/code> 会自动帮你选择正确的方案。&lt;/p>
&lt;p>最后别忘记了，很多图片并不是拍摄出来的，而是通过绘图绘制的。 这里并不是刻意重复我写过的东西，只是怕你之前错过了:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> circleSize = CGSize(width: &lt;span style="color:#ae81ff">60&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">，&lt;/span>height: &lt;span style="color:#ae81ff">60&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>UIGraphicsBeginImageContextWithOptions(circleSize&lt;span style="color:#960050;background-color:#1e0010">，&lt;/span>&lt;span style="color:#66d9ef">true&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">，&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Draw a circle&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> ctx = UIGraphicsGetCurrentContext()&lt;span style="color:#f92672">!&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>UIColor.red.setFill()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ctx.setFillColor(UIColor.red.cgColor)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ctx.addEllipse(&lt;span style="color:#66d9ef">in&lt;/span>: CGRect(x: &lt;span style="color:#ae81ff">0&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">，&lt;/span>y: &lt;span style="color:#ae81ff">0&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">，&lt;/span>width: circleSize.width&lt;span style="color:#960050;background-color:#1e0010">，&lt;/span>height: circleSize.height))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ctx.drawPath(using: .fill)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> circleImage = UIGraphicsGetImageFromCurrentImageContext()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>UIGraphicsEndImageContext()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个圆形图片使用的是每个像素 4 字节格式。 如果你使用 &lt;code>UIGraphicsImageRenderer&lt;/code> 那么渲染器会自动选择合适的格式，为每个像素节省 75% 的内存消耗。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> circleSize = CGSize(width: &lt;span style="color:#ae81ff">60&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">，&lt;/span>height: &lt;span style="color:#ae81ff">60&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> renderer = UIGraphicsImageRenderer(bounds: CGRect(x: &lt;span style="color:#ae81ff">0&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">，&lt;/span>y: &lt;span style="color:#ae81ff">0&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">，&lt;/span>width: circleSize.width&lt;span style="color:#960050;background-color:#1e0010">，&lt;/span>height: circleSize.height))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> circleImage = renderer.image{ ctx &lt;span style="color:#66d9ef">in&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> UIColor.red.setFill()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ctx.cgContext.setFillColor(UIColor.red.cgColor)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ctx.cgContext.addEllipse(&lt;span style="color:#66d9ef">in&lt;/span>: CGRect(x: &lt;span style="color:#ae81ff">0&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">，&lt;/span>y: &lt;span style="color:#ae81ff">0&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">，&lt;/span>width: circleSize.width&lt;span style="color:#960050;background-color:#1e0010">，&lt;/span>height: circleSize.height))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ctx.cgContext.drawPath(using: .fill)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="缩小分辨率-vs-缩小采样">
缩小分辨率 vs 缩小采样
&lt;a href="#%e7%bc%a9%e5%b0%8f%e5%88%86%e8%be%a8%e7%8e%87-vs-%e7%bc%a9%e5%b0%8f%e9%87%87%e6%a0%b7" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h2>
&lt;p>让我们跳过简单绘图的场景 - 还有非常多与图像相关的内存问题，源自真实的摄影图片。 比如人像，风景照。&lt;/p>
&lt;p>对于一些工程师来说，他们有理由（逻辑上也说得过去）相信，通过 &lt;code>UIImage&lt;/code> 简单地缩小图像尺寸就足够了。 但由于上面提及的原因，这通常来说不够，而且据 Apple 员工 Kyle Howarth 描述这也没有那么高效。&lt;/p>
&lt;p>如我们之前讨论渲染路径时提到的，&lt;code>UIImage&lt;/code> 会产生内存问题的主要原因是它会将原始图像加载到内存中进行解压。 理想状态下，我们应该减少图像缓存区的大小。&lt;/p>
&lt;p>幸运的是，我们其实可以只以调整图像文件的大小为代价，来影响图像内存大小。 通常人们会假设这就是系统如何实现的，但其实不是。&lt;/p>
&lt;p>让我们用点底层 API 来缩小采样试试:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> imageSource = CGImageSourceCreateWithURL(url&lt;span style="color:#960050;background-color:#1e0010">，&lt;/span>&lt;span style="color:#66d9ef">nil&lt;/span>)&lt;span style="color:#f92672">!&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> options: [NSString:Any] = [kCGImageSourceThumbnailMaxPixelSize:&lt;span style="color:#ae81ff">400&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">，&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> kCGImageSourceCreateThumbnailFromImageAlways:&lt;span style="color:#66d9ef">true&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#66d9ef">let&lt;/span> scaledImage = CGImageSourceCreateThumbnailAtIndex(imageSource&lt;span style="color:#960050;background-color:#1e0010">，&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">，&lt;/span>options &lt;span style="color:#66d9ef">as&lt;/span> CFDictionary) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> imageView = UIImageView(image: UIImage(cgImage: scaledImage))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> imageView.translatesAutoresizingMaskIntoConstraints = &lt;span style="color:#66d9ef">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> imageView.contentMode = .scaleAspectFit
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> imageView.widthAnchor.constraint(equalToConstant: &lt;span style="color:#ae81ff">300&lt;/span>).isActive = &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> imageView.heightAnchor.constraint(equalToConstant: &lt;span style="color:#ae81ff">400&lt;/span>).isActive = &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> view.addSubview(imageView)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> imageView.centerXAnchor.constraint(equalTo: view.centerXAnchor).isActive = &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> imageView.centerYAnchor.constraint(equalTo: view.centerYAnchor).isActive = &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>再次运行，我们得到的显示效果和之前一样。 但在这里，我们使用了 &lt;code>CGImageSourceCreateThumbnailAtIndex()&lt;/code> 而不是直接将原始图像放在 image view 中。 真相大白的时刻到了，让我们通过 &lt;code>vmmap&lt;/code> 来看看我们的优化是否奏效（再一次，为了简洁只截取了部分）:&lt;/p>
&lt;pre tabindex="0">&lt;code>vmmap -summary baylorOptimized.memgraph
Physical footprint: 56.3M
Physical footprint (peak): 56.7M
&lt;/code>&lt;/pre>&lt;p>节省的开销都统计在了一起。 如果我们将之前的 69.5M 和现在的 56.3M 进行对比，我们节约了 13.2M。 这是个很大的节省，几乎是整个图片的大小。&lt;/p>
&lt;p>再进一步，你可以根据你的需要通过各种选项来打磨。 在 WWDC 2018 Session 219 &amp;ldquo;Images and Graphics Best Practices&amp;rdquo; 中，Apple 工程师 Kyle Sluder 通过使用 &lt;code>kCGImageSourceShouldCacheImmediately&lt;/code> 标记来展示了一个很有趣的技巧控制解码:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">downsampleImage&lt;/span>(at URL:NSURL&lt;span style="color:#960050;background-color:#1e0010">，&lt;/span>maxSize:Float) -&amp;gt; UIImage
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> sourceOptions = [kCGImageSourceShouldCache:&lt;span style="color:#66d9ef">false&lt;/span>] &lt;span style="color:#66d9ef">as&lt;/span> CFDictionary
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> source = CGImageSourceCreateWithURL(URL &lt;span style="color:#66d9ef">as&lt;/span> CFURL&lt;span style="color:#960050;background-color:#1e0010">，&lt;/span>sourceOptions)&lt;span style="color:#f92672">!&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> downsampleOptions = [kCGImageSourceCreateThumbnailFromImageAlways:&lt;span style="color:#66d9ef">true&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">，&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> kCGImageSourceThumbnailMaxPixelSize:maxSize
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> kCGImageSourceShouldCacheImmediately:&lt;span style="color:#66d9ef">true&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">，&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> kCGImageSourceCreateThumbnailWithTransform:&lt;span style="color:#66d9ef">true&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">，&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ] &lt;span style="color:#66d9ef">as&lt;/span> CFDictionary
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> downsampledImage = CGImageSourceCreateThumbnailAtIndex(source, &lt;span style="color:#ae81ff">0&lt;/span>, downsampleOptions)&lt;span style="color:#f92672">!&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> UIImage(cgImage: downsampledImage)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Core Graphics 并不会参与解码图片，直到你明确需要使用缩略图的时候。 并且需要注意传入 &lt;code>kCGImageSourceCreateThumbnailMaxPixelSize&lt;/code>，就像我们做的上面两个例子那样。 如果你不传，那么你会得到一个和原始图像一样大小的缩略图。 据文档描述:&lt;/p>
&lt;blockquote>
&lt;p>“…如果没有指定最大像素大小，那么缩略图就会是完整的图片大小，这可能不是你想要的。”
“…if a maximum pixel size isn’t specified, then the thumbnail will be the size of the full image, which probably isn’t what you want.”&lt;/p>
&lt;/blockquote>
&lt;p>那么这里发生了什么? 简单来说，我们通过在缩略图上使用了缩小部分图片的等式，创建了一个小得多的解码图像缓冲区。 回忆一下之前提到的渲染路径，第一步（加载）现在我们没有创建一个原始图像大小的缓冲区，而是一个 image view 显示大小的缓冲区。&lt;/p>
&lt;p>想要一个这篇文章的太长不读版本? 找机会降低图像采样，而不是使用 &lt;code>UIImage&lt;/code> 缩小图片。&lt;/p>
&lt;h2 id="附加部分">
附加部分
&lt;a href="#%e9%99%84%e5%8a%a0%e9%83%a8%e5%88%86" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h2>
&lt;p>我个人在 Tandem 中配合着 &lt;a href="https://developer.apple.com/documentation/uikit/uitableviewdatasourceprefetching?language=swift">prefetch API&lt;/a> （iOS 11） 使用了这种技术。 但要记住即使我们在真正使用 table view 或者 collection view 之前这样做，我们在解码图片的时候，内部依然会带来的一个 CPU 使用量的高峰。&lt;/p>
&lt;p>尽管 iOS 在面对持续性能消耗时有很高效的处理方案，但在我们的例子中，可能是时不时才会产生这样的高峰。 所以在处理这种问题的时候，最好把希望寄予你自己创建的队列。 另一个优势是，这样还能将解码移动到后台处理。&lt;/p>
&lt;p>快遮住眼睛，我业余项目中的 Objective-C 代码要出来了:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-objc" data-lang="objc">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 用你自己的队列而不是 global 队列可以避免潜在的线程爆炸
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- (&lt;span style="color:#66d9ef">void&lt;/span>)&lt;span style="color:#a6e22e">tableView:&lt;/span>(UITableView &lt;span style="color:#f92672">*&lt;/span>)tableView &lt;span style="color:#a6e22e">prefetchRowsAtIndexPaths:&lt;/span>(NSArray&lt;span style="color:#f92672">&amp;lt;&lt;/span>NSIndexPath &lt;span style="color:#f92672">*&amp;gt;&lt;/span> &lt;span style="color:#f92672">*&lt;/span>)indexPaths
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (self.downsampledImage &lt;span style="color:#f92672">!=&lt;/span> nil &lt;span style="color:#f92672">||&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self.listItem.mediaAssetData &lt;span style="color:#f92672">==&lt;/span> nil) &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> NSIndexPath &lt;span style="color:#f92672">*&lt;/span>mediaIndexPath &lt;span style="color:#f92672">=&lt;/span> [NSIndexPath indexPathForRow:&lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> inSection:SECTION_MEDIA];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> ([indexPaths containsObject:mediaIndexPath])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CGFloat scale &lt;span style="color:#f92672">=&lt;/span> tableView.traitCollection.displayScale;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CGFloat maxPixelSize &lt;span style="color:#f92672">=&lt;/span> (tableView.width &lt;span style="color:#f92672">-&lt;/span> SSSpacingJumboMargin) &lt;span style="color:#f92672">*&lt;/span> scale;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dispatch_async(self.downsampleQueue&lt;span style="color:#960050;background-color:#1e0010">，&lt;/span>&lt;span style="color:#f92672">^&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 缩减采样
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> self.downsampledImage &lt;span style="color:#f92672">=&lt;/span> [UIImage downsampledImageFromData:self.listItem.mediaAssetData
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> scale:scale
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> maxPixelSize:maxPixelSize];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dispatch_async(dispatch_get_main_queue()&lt;span style="color:#960050;background-color:#1e0010">，&lt;/span>&lt;span style="color:#f92672">^&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self.listItem.downsampledMediaImage &lt;span style="color:#f92672">=&lt;/span> self.downsampledImage;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>注意在你有大量的原始图像（raw image）资源时使用资源管理（asset catalogs）。
因为它会帮你管理缓存大小（还有其他很多的优势）&lt;/p>
&lt;/blockquote>
&lt;p>想要了解更多关于图像和内存管理的信息，可以关注这些信息量巨大的 WWDC 18 session:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://developer.apple.com/videos/play/wwdc2018/416/?time=1074">iOS Memory Deep Dive&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developer.apple.com/videos/play/wwdc2018/219/">Images and Graphics Best Practices&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="总结一下">
总结一下
&lt;a href="#%e6%80%bb%e7%bb%93%e4%b8%80%e4%b8%8b" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h2>
&lt;p>你无法察觉你不知道的东西。 就编程来说，你基本上相当于报名参加了一个需要持续跑每小时 10，000 米以跟上创新和变革的职业生涯。 这意味着&amp;hellip;有大量的 API，框架，设计模式或者优化方案你并不知晓。&lt;/p>
&lt;p>在图像领域尤其是这样。 大多数时间，你可能只是初始化了一个 &lt;code>UIImageView&lt;/code> 然后放进了一些好看的像素，就过了。 我知道啦，摩尔定理什么的。 现在这些电话运行速度很快，而且有数 G 的内存，并且我们把人类运送到了月球上，都只用了一台不到 100K 内存的电脑。&lt;/p>
&lt;p>但是和魔鬼共舞不会长久，他必然需要滋养他的角。 别让系统杀掉你的应用，只是因为你用了 1G 内存来展示一张自拍照。 但愿这些知识和技巧可以将你拯救于崩溃日志。&lt;/p>
&lt;p>下次见 ✌️。&lt;/p></description></item><item><title>Platforms State of the Union(WWDC 2019)</title><link>https://joeytat.github.io/posts/wwdc2019_platforms_state_of_the_union/</link><pubDate>Wed, 05 Jun 2019 00:00:00 +0000</pubDate><guid>https://joeytat.github.io/posts/wwdc2019_platforms_state_of_the_union/</guid><description>
&lt;h2 id="swiftui">
SwiftUI
&lt;a href="#swiftui" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h2>
&lt;p>在 View 层级提供了四种特性:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Declarative
通过声明式的语句来描述 UI 布局, 样式, 动画等.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Automatic
可交互形动画, 动态字号, 夜间模式都可以通过配置来轻松实现.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Compositional
组合性. 各种控件都能极其方便地组合在一起, 远比 &lt;code>UIStackView&lt;/code> 方便.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>VStack(alignment: .leading) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Text(item.title)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Text(item.subtitle)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>Consistent
自带 Reactive 特性. 将 Model 对象继承自 &lt;code>BindableObject&lt;/code>, 并且声明属性为 &lt;code>@State&lt;/code> 即可获得当属性改变时, UI 控件自动更新的效果.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>真的如果如此美好, 超级吃性能的 xib 和 storyboard 是不是可以退出舞台了.&lt;/p>
&lt;h2 id="xcode-11">
Xcode 11
&lt;a href="#xcode-11" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>Live Development
直接在 Xcode Preview 中拖动控件即可生成对应的 SwiftUI 代码. 对应的修改 SwiftUI 代码也能实时在 Preview 中响应.&lt;/p>
&lt;p>Preview 还能通过提供一个 &lt;code>PreviewProvider&lt;/code> 来为其提供数据填充展示, 样式更改甚至循环语句来生成多个 Preview 同时查看控件在夜间模式和白日模式下不同的效果.&lt;/p>
&lt;p>Preview 部署在设备上也能热加载.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Package Management
Swift 终于有自己的 Package manage 了. 并且和 Xcode 进行了深度整合.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Minimap
代码在右侧会呈现类似 ctrl+6 的缩略图.
如果代码中写了 &lt;code>// MARK: -&lt;/code> &lt;code>// TODO: -&lt;/code> 等标记, 会更清晰地显示出来. 按住 cmd 会显示所有的标记.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>版本管理
可以直接在修改代码的位置查看到原来的版本.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Test Plan
同时测试各种平台各种设备.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="跨平台方案">
跨平台方案
&lt;a href="#%e8%b7%a8%e5%b9%b3%e5%8f%b0%e6%96%b9%e6%a1%88" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h2>
&lt;p>SwiftUI 支持跨平台, 同时支持 iOS, macOS, iPadOS. 那如何在 iOS App 的基础上创建一个 macOS App 呢? 只需要三个步骤:&lt;/p>
&lt;ol>
&lt;li>勾选上 deployment 中的 ✅ mac&lt;/li>
&lt;li>同时勾选上 ✅ iPad, 一个好的 iPad app, 就是一个好的 macOS app&lt;/li>
&lt;li>针对 macOS 的菜单, 快捷键等具有平台特殊性质的操作进行一些单独适配.&lt;/li>
&lt;/ol>
&lt;p>还对 catalina 的一些系统修改进行了介绍, 比如各种资源权限的收紧, 并且文件资源权限分成了两部分, 系统文件对于三方 app 变成了只读.&lt;/p>
&lt;blockquote>
&lt;p>后面都是各平台系统或新功能的介绍, 还是不继续施工了.&lt;/p>
&lt;/blockquote></description></item><item><title>如何实现 JavaScript 函数参数必填的支持?</title><link>https://joeytat.github.io/posts/js_required_property/</link><pubDate>Mon, 03 Jun 2019 00:00:00 +0000</pubDate><guid>https://joeytat.github.io/posts/js_required_property/</guid><description>
&lt;p>JS 在 ES6 的中新增了函数参数指定默认值的支持:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">Greeting&lt;/span> &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#a6e22e">name&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Joeytat&amp;#34;&lt;/span>) =&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">`Hello &lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#a6e22e">name&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">`&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">Greeting&lt;/span>() &lt;span style="color:#75715e">// Hello Joeytat
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>那我们就可以利用这一特性, 将一个会抛出异常的方法作为默认参数传递.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">Greeting&lt;/span> &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#a6e22e">name&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#a6e22e">EmptyPropertyException&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;name&amp;#34;&lt;/span>)) =&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">`Hello &lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#a6e22e">name&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">`&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">EmptyPropertyException&lt;/span> &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#a6e22e">propertyName&lt;/span>) =&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> Error(&lt;span style="color:#e6db74">`&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#a6e22e">propertyName&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74"> 为必填参数`&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">Greeting&lt;/span>() &lt;span style="color:#75715e">// 抛出异常: &amp;#34;Error: name 为必填参数&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样如果没有传递参数就会抛出异常, 并且带有友好的提示了.&lt;/p></description></item><item><title>2018</title><link>https://joeytat.github.io/posts/2018_overview/</link><pubDate>Fri, 28 Dec 2018 00:00:00 +0000</pubDate><guid>https://joeytat.github.io/posts/2018_overview/</guid><description>
&lt;p>刚毕业那阵儿还每年都写好长的总结, 然后这两年变懒了. 今年又想再记录一下了嘿 | ᐕ)⁾⁾&lt;/p>
&lt;ul>
&lt;li>
&lt;p>年度 App: &lt;a href="https://www.duolingo.com">多邻国&lt;/a>&lt;/p>
&lt;p>零基础学语言的感觉很不错.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>年度电影: &lt;a href="https://movie.douban.com/subject/26611804/">《三块广告牌》&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>年度漫画: &lt;a href="https://zh.wikipedia.org/wiki/%E5%8F%AA%E6%9C%89%E6%88%91%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84%E5%9F%8E%E5%B8%82">《只有我不存在的城市》&lt;/a>&lt;/p>
&lt;p>忘了在哪被人推荐的了, 被安利到的话大概是这么说的「非常庆幸在没有被剧透的情况下一口气看完了」. 看完了之后感觉果然如此. 而且漫画真是存在着动画无法表现出的节奏感啊.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>年度游戏: &lt;a href="https://zh.wikipedia.org/wiki/%E7%A5%9E%E7%95%8C%EF%BC%9A%E5%8E%9F%E7%BD%AA2">《神界原罪 2》&lt;/a>&lt;/p>
&lt;p>接触的第一款 CRPG, 有趣到什么程度呢? 从游戏体验时发出「wow, 居然还能这样?」的频率来看, 和《塞尔达: 旷野之息》差不多吧.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>年度虚构类图书: 《剑来》&lt;/p>
&lt;p>不知道为啥现在提起网络文学, 多数时候对方都还是觉得「格」不够. 可现在的网络小说与《明报》连载的武侠小说, 有多大的区别?&lt;/p>
&lt;/li>
&lt;li>
&lt;p>年度非虚构类图书: &lt;a href="https://book.douban.com/subject/27091742/">《邻人之妻》&lt;/a>&lt;/p>
&lt;p>我姓王和我看这本书没有任何联系(认真脸), 真的是好奇性美国解放运动到底是怎么产生的而看的.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>年度电器: Sony 9000E 电视&lt;/p>
&lt;p>大屏幕 4k HDR 的全新体验让我想把之前在显示器上玩的好游戏看的好电影都重新来一次.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>年度音乐: &lt;a href="http://music.163.com/song/443875380/?userid=564654" title="@网易云音乐">《生きていたんだよな(她曾活过啊)》&lt;/a>&lt;/p>
&lt;p>歌词很棒? 看到年度音乐四个字, 脑子里第一首出现的歌.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>年度视频: 井越的 vlog——&lt;a href="https://www.bilibili.com/video/av17898771/">《别再问我什么是 2017》&lt;/a>&lt;/p>
&lt;p>看了几十个 Casey Neistat 的 vlog 也没能让自己行动起来用视频记录生活. 但看完这个视频的第二天, 就开始尝试着在大街上对着手机镜头说话啦.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>年度电子产品: iPhoneX&lt;/p>
&lt;p>用来拍了不少视频, 照片. 人像模式拍出的照片, 会让我这个摄影门外汉产生一种「自己拍的还不错嘛」的错觉, 从而达到了要经常掏出手机记录生活的目标.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>希望明年也能多创造一些东西, 能够在 19 年的年终总结中, 选出自己满意的年度 XXX 吧&lt;/p></description></item><item><title>为什么 Cocoapods 1.5 支持编译静态库之后大家这么高兴?</title><link>https://joeytat.github.io/posts/cocoapods-1.5-static-library/</link><pubDate>Thu, 27 Dec 2018 00:00:00 +0000</pubDate><guid>https://joeytat.github.io/posts/cocoapods-1.5-static-library/</guid><description>
&lt;p>昨天在 Twitter 上看到 TualatriX 说&lt;a href="https://twitter.com/tualatrix/status/1077166131956264960">把私有库都通过 Cocoapods 编译成静态库之后很爽&lt;/a>, 就有点好奇到底是爽在哪里.&lt;/p>
&lt;p>于是去搜了一下, 原来是前段时间(大半年前吧&amp;hellip;), Cocoapods 发布了 1.5 的 &lt;a href="http://blog.cocoapods.org/CocoaPods-1.5.0/">release note&lt;/a>, 宣布支持 Swift 静态库编译. 并且文中提到了对于担心动态二进制文件影响应用启动速度的人来说, 这是个了不起的更新.
jh
那又是为什么 App 使用静态库会比动态库有更快的启动速度呢? 又跑去搜了一下官方文档. 打开 &lt;a href="https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/DynamicLibraries/100-Articles/OverviewOfDynamicLibraries.html">Dynamic Library Programming Topics&lt;/a> 开头就看到:&lt;/p>
&lt;blockquote>
&lt;p>This article introduces dynamic libraries and shows how using dynamic libraries instead of static libraries reduces both the file size and initial memory footprint of the apps that use them.&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>这篇文章主要介绍了动态库, 并且展示了通过&lt;strong>使用动态库&lt;/strong>而不是静态库, 是如何&lt;strong>缩减&lt;/strong>了应用的大小和初始内存空间的.&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="http://ww1.rs.fanjian.net/c/ab/c8/25/53abf0c06ec808c1fe250d3565ff0d32.jpg" alt="黑人问号">&lt;/p>
&lt;p>┻━┻ (ヽ(`Д ́)ノ( ┻━┻ 这和说好的不一样啊?&lt;/p>
&lt;p>带着疑问我又跑去看了一下苹果的 &lt;a href="https://developer.apple.com/videos/play/wwdc2016/406">WWDC 2016 - Optimizing App Startup Time&lt;/a> 的视频, 这次问题终于得到了解决.&lt;/p>
&lt;p>这里的库是什么? 是可执行文件的集合. 静态库与动态库调用时机的区别在于, 静态库在应用启动的时候, 会和程序的可执行代码一起, 被加载到应用的内存空间中. 这就会导致应用启动慢, 并且内存占用大. 而动态库则是在代码真正被需要调用的时候, 才加载到内存中.&lt;/p>
&lt;p>所以才会有苹果文档中提到的「通过&lt;strong>使用动态库&lt;/strong>而不是静态库, 是如何&lt;strong>缩减&lt;/strong>了应用的大小和初始内存空间的」这句话.&lt;/p>
&lt;p>可这是站在系统角度来说的. 在 iOS 中, 平均每个 App 包含了 &lt;a href="https://developer.apple.com/videos/play/wwdc2016-406/?time=1684">1 到 400&lt;/a> 个动态库. 其中有很大一部分是系统级动态库. 苹果为其做了许多的优化, 比如提前计算, 提前缓存等. 这对于系统提供的动态库来说, 当然比静态库更快.&lt;/p>
&lt;p>但 App 中还包含了很多自有的动态库, 这部分动态库苹果没有办法为期提供优化. 而对于 dylib 的加载又是非常耗费资源的. 所以苹果对其的建议是最好在 &lt;a href="https://developer.apple.com/videos/play/wwdc2016-406/?time=1794">6&lt;/a> 个左右.&lt;/p>
&lt;p>然后我也把项目中的 Swift pods 编译为静态库了, 效果如下.&lt;/p>
&lt;pre tabindex="0">&lt;code>// 优化前
[DYMTLInitPlatform] platform initialization successful
Total pre-main time: 1.5 seconds (100.0%)
dylib loading time: 968.07 milliseconds (61.1%)
......
......
&lt;/code>&lt;/pre>&lt;pre tabindex="0">&lt;code>// Pods 使用静态库后
[DYMTLInitPlatform] platform initialization successful
Total pre-main time: 1.1 seconds (100.0%)
dylib loading time: 520.52 milliseconds (47.2%)
......
......
&lt;/code>&lt;/pre>&lt;p>最后再总结一下.&lt;/p>
&lt;ul>
&lt;li>对于系统提供了优化的动态库来说, 一定是比静态库启动加载快且占用内存更小的. 14er&lt;/li>
&lt;li>而对于 App 自有的动态库来说, 系统在加载动态库所消耗的资源要比加载静态库来得多, 所以最好限制在 6 个左右.&lt;/li>
&lt;/ul>
&lt;h2 id="参考链接">
参考链接
&lt;a href="#%e5%8f%82%e8%80%83%e9%93%be%e6%8e%a5" class="h-anchor" aria-hidden="true">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.jianshu.com/p/3d0ae289dee0">Cocoapods 的静态库和动态库&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developer.apple.com/videos/play/wwdc2016/406/?time=203">WWDC 2016 - Optimizing App Startup Time&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/DynamicLibraries/100-Articles/OverviewOfDynamicLibraries.html">Dynamic Library Programming Topics&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://tech.meituan.com/waimai_ios_optimizing_startup.html">美团外卖 iOS App冷启动治理&lt;/a>&lt;/li>
&lt;/ul></description></item></channel></rss>