<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Dev Log</title><link>https://joeytat.github.io/posts/</link><description>Recent content in Posts on Dev Log</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 03 Jan 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://joeytat.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>SwiftUI 状态管理 —— Composible Binding</title><link>https://joeytat.github.io/posts/20220103_notes_composible_binding/</link><pubDate>Mon, 03 Jan 2022 00:00:00 +0000</pubDate><guid>https://joeytat.github.io/posts/20220103_notes_composible_binding/</guid><description>
&lt;p>在 SwiftUI 中，需要通过数据来驱动 UI 的变化。数据结构抽象描述的质量也影响着我们对 SwiftUI 界面的维护。&lt;/p>
&lt;p>通常数据中可能存在很多状态，如果使用很多的 boolean 值来描述这些状态，那么 App 的可维护性可能会大大降低。&lt;/p>
&lt;h2 id="管理独立状态的问题">管理独立状态的问题&lt;/h2>
&lt;p>假设我们有一个 App，用户可以在登录与非登录状态下进行操作。所以我们的界面需要兼容这两种状态，其描述可能是这样的：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-swift" data-lang="swift">&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">AppState&lt;/span>: ObservableObject {
@Published &lt;span style="color:#66d9ef">var&lt;/span> user: User? = &lt;span style="color:#66d9ef">nil&lt;/span>
@Published &lt;span style="color:#66d9ef">var&lt;/span> error: Error? = &lt;span style="color:#66d9ef">nil&lt;/span>
&lt;span style="color:#66d9ef">var&lt;/span> authenticated: Bool { user &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> }
&lt;span style="color:#66d9ef">var&lt;/span> hasError: Bool { error &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> }
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>基于这样的状态描述，如果我们想创建一个仅展示用户名的组件大概会是这样：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-swift" data-lang="swift"> &lt;span style="color:#66d9ef">var&lt;/span> body: some View {
Group {
&lt;span style="color:#66d9ef">if&lt;/span> state.hasError {
Text(&lt;span style="color:#e6db74">&amp;#34;Oops, sth went wrong: &lt;/span>&lt;span style="color:#e6db74">\(&lt;/span>state.error!.localizedDescription&lt;span style="color:#e6db74">)&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
}
&lt;span style="color:#66d9ef">if&lt;/span> state.authenticated {
Text(&lt;span style="color:#e6db74">&amp;#34;Hello &lt;/span>&lt;span style="color:#e6db74">\(&lt;/span>state.user?.name ?? &lt;span style="color:#e6db74">&amp;#34;Unknown&amp;#34;&lt;/span>&lt;span style="color:#e6db74">)&lt;/span>&lt;span style="color:#e6db74">!&amp;#34;&lt;/span>)
} &lt;span style="color:#66d9ef">else&lt;/span> {
Text(&lt;span style="color:#e6db74">&amp;#34;Hello, stranger&amp;#34;&lt;/span>)
}
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>粗看没有什么问题，实际上在维护这样的数据结构时就需要格外小心了。比如第一次我们登录失败，为了展示错误信息给 &lt;code>error&lt;/code> 设置了值之后。必须在登录成功之后要及时地去清空 error，否则即使 &lt;code>state.authenticated&lt;/code> 等于 &lt;code>true&lt;/code>，用户依然无法看到正确的信息。&lt;/p>
&lt;p>这还仅仅是有两个状态的情况下，像这样独立状态属性会带来很大的维护成本，开发者需要牢记各个属性之间的依赖关系，甚至编写界面的时候，还需要注意代码执行顺序。&lt;/p>
&lt;h2 id="引入状态机">引入状态机&lt;/h2>
&lt;p>把状态抽象成带有 associated values 的 enum 是个更好的选择，比如:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-swift" data-lang="swift">&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">AppState&lt;/span>: ObservableObject {
&lt;span style="color:#66d9ef">enum&lt;/span> &lt;span style="color:#a6e22e">AccountState&lt;/span> {
&lt;span style="color:#66d9ef">case&lt;/span> authenticated(User)
&lt;span style="color:#66d9ef">case&lt;/span> unauthenticated
&lt;span style="color:#66d9ef">case&lt;/span> error(Error)
}
@Published &lt;span style="color:#66d9ef">var&lt;/span> accountState: AccountState = .unauthenticated
}
&lt;span style="color:#75715e">// 界面中的使用&lt;/span>
&lt;span style="color:#66d9ef">var&lt;/span> body: some View {
VStack {
&lt;span style="color:#66d9ef">switch&lt;/span> state.accountState {
&lt;span style="color:#66d9ef">case&lt;/span> .authenticated(&lt;span style="color:#66d9ef">let&lt;/span> user):
Text(&lt;span style="color:#e6db74">&amp;#34;Hello &lt;/span>&lt;span style="color:#e6db74">\(&lt;/span>user.name&lt;span style="color:#e6db74">)&lt;/span>&lt;span style="color:#e6db74">!&amp;#34;&lt;/span>)
&lt;span style="color:#66d9ef">case&lt;/span> .unauthenticated:
Text(&lt;span style="color:#e6db74">&amp;#34;unregister&amp;#34;&lt;/span>)
&lt;span style="color:#66d9ef">case&lt;/span> .error(&lt;span style="color:#66d9ef">let&lt;/span> error):
Text(&lt;span style="color:#e6db74">&amp;#34;Oops, sth went wrong: &lt;/span>&lt;span style="color:#e6db74">\(&lt;/span>error.localizedDescription&lt;span style="color:#e6db74">)&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样被状态机驱动的界面看起来要直观多了。并且在每个状态中对数据的操作，也由 enum 赋予了隔离能力。&lt;/p>
&lt;h2 id="双向绑定怎么办">双向绑定怎么办？&lt;/h2>
&lt;p>但这样做又来带个新的问题，现在没办法直接通过 &lt;code>$&lt;/code> 来获取 Binding wrapper 来修改状态：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-swift" data-lang="swift">&lt;span style="color:#66d9ef">switch&lt;/span> state.accountState {
&lt;span style="color:#66d9ef">case&lt;/span> .authenticated(&lt;span style="color:#66d9ef">let&lt;/span> user):
Text(&lt;span style="color:#e6db74">&amp;#34;Hello &lt;/span>&lt;span style="color:#e6db74">\(&lt;/span>user.name&lt;span style="color:#e6db74">)&lt;/span>&lt;span style="color:#e6db74">!&amp;#34;&lt;/span>)
TextField(&lt;span style="color:#e6db74">&amp;#34;Change username&amp;#34;&lt;/span>, text: &amp;lt;Binding&amp;lt;String&amp;gt;&lt;span style="color:#f92672">&amp;gt;&lt;/span>)
&lt;span style="color:#75715e">// 不支持填入 self.$state.accountState.name 👆&lt;/span>
...
&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>Xcode 会提示: dynamic member &amp;lsquo;name&amp;rsquo; using key path from root type &amp;lsquo;AppState.AccountState&amp;rsquo;&lt;/p>
&lt;/blockquote>
&lt;p>为什么当操作对象是 class 时，是可以做到通过
&lt;code>self.$state.user.name&lt;/code> 来获取到 name 属性的 Binding 封装的？&lt;/p>
&lt;h2 id="实现动态成员查找dynamic-member-lookup">实现动态成员查找(dynamic member lookup)&lt;/h2>
&lt;p>因为 Enum 还不支持动态成员查找特性。什么是动态成员查找？简而言之就是通过 &lt;code>\&lt;/code> 来获取到成员属性的 &lt;code>KeyPath&lt;/code> 封装（&lt;a href="https://www.swiftbysundell.com/articles/the-power-of-key-paths-in-swift/">什么又是 KeyPath&lt;/a>？），然后将其转化为对应的 Binding 封装。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-swift" data-lang="swift">&lt;span style="color:#66d9ef">extension&lt;/span> &lt;span style="color:#a6e22e">Binding&lt;/span> {
&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">transform&lt;/span>&amp;lt;LocalValue&amp;gt;(
&lt;span style="color:#66d9ef">_&lt;/span> keyPath: WritableKeyPath&amp;lt;Value, LocalValue&amp;gt;
) -&amp;gt; Binding&amp;lt;LocalValue&amp;gt; {
Binding&amp;lt;LocalValue&amp;gt;(
&lt;span style="color:#66d9ef">get&lt;/span>: {
&lt;span style="color:#66d9ef">self&lt;/span>.wrappedValue[keyPath: keyPath]
},
&lt;span style="color:#66d9ef">set&lt;/span>: { localValue &lt;span style="color:#66d9ef">in&lt;/span>
&lt;span style="color:#66d9ef">self&lt;/span>.wrappedValue[keyPath: keyPath] = localValue
}
)
}
}
&lt;span style="color:#66d9ef">self&lt;/span>.&lt;span style="color:#960050;background-color:#1e0010">$&lt;/span>state.accountState.username
&lt;span style="color:#75715e">// 等价于 &lt;/span>
&lt;span style="color:#66d9ef">self&lt;/span>.&lt;span style="color:#960050;background-color:#1e0010">$&lt;/span>state.transform(&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>accountState).transform(&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>username)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>所以接下来只需要为 enum 添加动态成员查找的支持就可以了&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-swift" data-lang="swift">&lt;span style="color:#66d9ef">extension&lt;/span> &lt;span style="color:#a6e22e">Binding&lt;/span> {
&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">unwrap&lt;/span>&amp;lt;Wrapped&amp;gt;() -&amp;gt; Binding&amp;lt;Wrapped&amp;gt;? &lt;span style="color:#66d9ef">where&lt;/span> Value == Wrapped? {
&lt;span style="color:#66d9ef">guard&lt;/span> &lt;span style="color:#66d9ef">let&lt;/span> value = &lt;span style="color:#66d9ef">self&lt;/span>.wrappedValue &lt;span style="color:#66d9ef">else&lt;/span> { &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> }
&lt;span style="color:#66d9ef">return&lt;/span> Binding&amp;lt;Wrapped&amp;gt;(
&lt;span style="color:#66d9ef">get&lt;/span>: { value },
&lt;span style="color:#66d9ef">set&lt;/span>: { &lt;span style="color:#66d9ef">self&lt;/span>.wrappedValue = $0 }
)
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后再到 enum 里添加一个计算属性方便我们获取&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-swift" data-lang="swift">&lt;span style="color:#66d9ef">enum&lt;/span> &lt;span style="color:#a6e22e">AccountState&lt;/span> {
&lt;span style="color:#66d9ef">case&lt;/span> loggedIn(User)
&lt;span style="color:#66d9ef">case&lt;/span> unregister
&lt;span style="color:#75715e">//&lt;/span>
&lt;span style="color:#66d9ef">var&lt;/span> username: String? {
&lt;span style="color:#66d9ef">get&lt;/span> {
&lt;span style="color:#66d9ef">guard&lt;/span> &lt;span style="color:#66d9ef">case&lt;/span> .loggedIn(&lt;span style="color:#66d9ef">let&lt;/span> user) = &lt;span style="color:#66d9ef">self&lt;/span> &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span>
}
&lt;span style="color:#66d9ef">return&lt;/span> user.username
}
&lt;span style="color:#66d9ef">set&lt;/span> {
&lt;span style="color:#66d9ef">guard&lt;/span> &lt;span style="color:#66d9ef">case&lt;/span> .loggedIn(&lt;span style="color:#66d9ef">let&lt;/span> user) = &lt;span style="color:#66d9ef">self&lt;/span>,
&lt;span style="color:#66d9ef">let&lt;/span> newValue = newValue &lt;span style="color:#66d9ef">else&lt;/span> { &lt;span style="color:#66d9ef">return&lt;/span> }
user.username = newValue
&lt;span style="color:#66d9ef">self&lt;/span> = .loggedIn(user)
}
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>现在就可以在 SwiftUI 中对 enum 使用绑定了&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-swift" data-lang="swift">&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#66d9ef">let&lt;/span> username = &lt;span style="color:#66d9ef">self&lt;/span>.&lt;span style="color:#960050;background-color:#1e0010">$&lt;/span>state.accountState.username.unwrap() {
TextField(&lt;span style="color:#e6db74">&amp;#34;Change username&amp;#34;&lt;/span>, text: username)
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>看起来还是有些麻烦，对于每个要使用 Binding 的属性都需要去写一个计算属性来包装一层。这样显然这并不如 &lt;code>KeyPath&lt;/code> 那样，直接通过 &lt;code>self.$state.accountState[\.authenticated]&lt;/code> 来获取到 enum 中 associated value 的 Binding 包装来得方便。&lt;/p>
&lt;p>虽然 Swift 目前不支持，但我们还是可以通过引入 &lt;a href="https://github.com/pointfreeco/swift-case-paths">CasePaths&lt;/a> 这个第三方依赖来实现。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-swift" data-lang="swift">&lt;span style="color:#66d9ef">import&lt;/span> &lt;span style="color:#a6e22e">CasePaths&lt;/span>
&lt;span style="color:#66d9ef">enum&lt;/span> &lt;span style="color:#a6e22e">AccountState&lt;/span> {
&lt;span style="color:#66d9ef">case&lt;/span> authenticated(User)
&lt;span style="color:#66d9ef">case&lt;/span> unauthenticated
&lt;span style="color:#66d9ef">case&lt;/span> error(Error)
&lt;span style="color:#75715e">// 计算属性可以删除掉了&lt;/span>
&lt;span style="color:#75715e">// var username: String? {&lt;/span>
&lt;span style="color:#75715e">// get {&lt;/span>
&lt;span style="color:#75715e">// guard case .authenticated(let user) = self else {&lt;/span>
&lt;span style="color:#75715e">// return nil&lt;/span>
&lt;span style="color:#75715e">// }&lt;/span>
&lt;span style="color:#75715e">// return user.name&lt;/span>
&lt;span style="color:#75715e">// }&lt;/span>
&lt;span style="color:#75715e">// set {&lt;/span>
&lt;span style="color:#75715e">// guard case .authenticated(let user) = self,&lt;/span>
&lt;span style="color:#75715e">// let newValue = newValue else { return }&lt;/span>
&lt;span style="color:#75715e">// user.name = newValue&lt;/span>
&lt;span style="color:#75715e">// self = .authenticated(user)&lt;/span>
&lt;span style="color:#75715e">// }&lt;/span>
&lt;span style="color:#75715e">// }&lt;/span>
}
&lt;span style="color:#75715e">// 界面中直接使用 CasePath&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#66d9ef">let&lt;/span> user = &lt;span style="color:#66d9ef">self&lt;/span>.&lt;span style="color:#960050;background-color:#1e0010">$&lt;/span>state.accountState.matching(&lt;span style="color:#f92672">/&lt;/span>.authenticated) {
TextField(&lt;span style="color:#e6db74">&amp;#34;Change username&amp;#34;&lt;/span>, text: user.name)
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>由此为 Enum 也增加了与 Struct、Class 等效的 KeyPath 支持，从而使得文章开头用 Enum 作为 SwiftUI 的状态机管理工具更便捷了一些。&lt;/p>
&lt;h2 id="参考资料">参考资料&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://kentcdodds.com/blog/stop-using-isloading-booleans">Stop using isLoading booleans&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.swiftbysundell.com/articles/the-power-of-key-paths-in-swift/">The power of key paths in Swift&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.pointfree.co/collections/swiftui/composable-bindings/ep107-composable-swiftui-bindings-the-problem">Composable SwiftUI Bindings: The Problem&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>JavaScript 既然是单线程语言，为什么 setTimeout 不会阻塞线程？</title><link>https://joeytat.github.io/posts/190819_asynchronous-javascript/</link><pubDate>Mon, 19 Aug 2019 00:00:00 +0000</pubDate><guid>https://joeytat.github.io/posts/190819_asynchronous-javascript/</guid><description>
&lt;p>先看下面的代码&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">printHello&lt;/span>() {
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Hello&amp;#34;&lt;/span>);
}
&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">printWorld&lt;/span>() {
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;World&amp;#34;&lt;/span>);
}
&lt;span style="color:#a6e22e">printHello&lt;/span>(); &lt;span style="color:#75715e">// 输出 Hello
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">printWorld&lt;/span>(); &lt;span style="color:#75715e">// 输出 World
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在 JavaScript 中，存在一个全局调用栈(Global Call Stack)。当我们调用 &lt;code>printHello&lt;/code> 时，会将该方法加入到栈中，由于 JavaScript 是单线程执行机制（同一时间只执行一个命令），所以会在执行完成了 &lt;code>printHello&lt;/code> 之后再执行 &lt;code>printWorld&lt;/code>。&lt;/p>
&lt;p>那么现在就引入标题中的问题，&lt;strong>JavaScript 既然是单线程语言，为什么 setTimeout 不会阻塞线程？&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">printHello&lt;/span>() {
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Hello&amp;#34;&lt;/span>);
}
&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">printWorld&lt;/span>() {
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;World&amp;#34;&lt;/span>);
}
&lt;span style="color:#a6e22e">setTimeout&lt;/span>(&lt;span style="color:#a6e22e">printHello&lt;/span>, &lt;span style="color:#ae81ff">1000&lt;/span>);
&lt;span style="color:#a6e22e">printWorld&lt;/span>();
&lt;/code>&lt;/pre>&lt;/div>&lt;p>表面上来看 &lt;code>setTimeout&lt;/code> 也是一个方法，他的定义可能是这样：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">setTimeout&lt;/span>(&lt;span style="color:#a6e22e">callbackFunc&lt;/span>, &lt;span style="color:#a6e22e">interval&lt;/span>) {
&lt;span style="color:#75715e">// ....
&lt;/span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>那么按照 JS 单线程理论来说，应该是先将 &lt;code>setTimeout&lt;/code> 方法压入全局调用栈，并且执行该方法，等待 1 秒钟，然后再执行 &lt;code>printWorld&lt;/code> 才对。但实际上我们都知道，打印的结果会是 &amp;ldquo;World&amp;rdquo; 然后 &amp;ldquo;Hello&amp;rdquo;，这是为什么？&lt;/p>
&lt;h3 id="web-browser-api---callback-queue">Web Browser API &amp;amp; Callback Queue&lt;/h3>
&lt;p>事实上 &lt;code>setTimeout&lt;/code> 并不是完全是 JS 代码，而是属于 &lt;strong>Web Browser API&lt;/strong> 中的方法。就像名字中所指的那样， JS 调用了 &lt;code>setTimeout&lt;/code> 之后，浏览器（Web Browser）会去创建一个 timer，同时将我们传入 &lt;code>setTimeout&lt;/code> 的方法 - &lt;code>printHello&lt;/code> 加入到 &lt;strong>Callback Queue（回调队列）&lt;/strong> 中。&lt;/p>
&lt;p>1000 毫秒过去后，浏览器会通知 JavaScript 引擎将回调队列中的 &lt;code>printHello&lt;/code> 加入到 JS 的全局调用栈中执行。&lt;/p>
&lt;p>所以在 JS 的全局调用栈看来，是先有一个 &lt;code>printWorld&lt;/code> 加入到了调用栈，过了 1000 毫秒之后，又加入了一个 &lt;code>printHello&lt;/code> 方法。&lt;/p>
&lt;p>那如果我们的 &lt;code>printWorld&lt;/code> 之后还有其他的方法执行时间超过了 1000 毫秒呢？&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#75715e">/// 省略掉 printHello 和 printWorld 定义
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">heavyWork&lt;/span>() {
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">1000000&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">++&lt;/span>) {
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Heavy Work&amp;#34;&lt;/span>);
}
}
&lt;span style="color:#a6e22e">setTimeout&lt;/span>(&lt;span style="color:#a6e22e">printHello&lt;/span>, &lt;span style="color:#ae81ff">1000&lt;/span>);
&lt;span style="color:#a6e22e">printWorld&lt;/span>();
&lt;span style="color:#a6e22e">heavyWork&lt;/span>(); &lt;span style="color:#75715e">// 假设会执行 2000ms
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>现在让我们假设 &lt;code>heavyWork&lt;/code> 方法会执行 2000ms，可是我们的 &lt;code>setTimeout&lt;/code> 只会执行 1000ms，那么按照上面的理论，1000ms 到了之后，&lt;code>printHello&lt;/code> 会被加入到 JS 的调用栈中执行，那现在的输出会是一堆“Heavy Work”之中夹带着一个“Hello”吗？&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#a6e22e">World&lt;/span>
&lt;span style="color:#a6e22e">Heavy&lt;/span> &lt;span style="color:#a6e22e">Work&lt;/span>
...
&lt;span style="color:#a6e22e">Hello&lt;/span> &lt;span style="color:#75715e">// 会输出一堆 Heavy Work 中夹带一个 Hello 吗？
&lt;/span>&lt;span style="color:#75715e">&lt;/span>...
&lt;span style="color:#a6e22e">Heavy&lt;/span> &lt;span style="color:#a6e22e">Work&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>当然不会啦，因为我们有 Event Loop（事件循环机制）。&lt;/p>
&lt;h3 id="event-loop">Event Loop&lt;/h3>
&lt;p>Event Loop 其实理解起来非常简单，就是一个循环会不停地检查 JS 调用栈。只有在 JS 调用栈&lt;strong>没有任务&lt;/strong>的情况下，Callback Queue 中的任务，才会被添加到 JS 调用栈。&lt;/p>
&lt;p>所以上面的代码中，&lt;code>setTimeout&lt;/code> 虽然指定了 1000ms 之后就执行 &lt;code>printHello&lt;/code>，但实际上会被需要执行 2000ms 的 &lt;code>heavyWork&lt;/code>阻塞住， 输出的结果会是：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#a6e22e">World&lt;/span>
&lt;span style="color:#a6e22e">Heavy&lt;/span> &lt;span style="color:#a6e22e">Work&lt;/span>
.... &lt;span style="color:#75715e">// 长达 2000ms 的 Heavy Work
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">Heavy&lt;/span> &lt;span style="color:#a6e22e">Work&lt;/span>
&lt;span style="color:#a6e22e">Hello&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="总结">总结&lt;/h3>
&lt;ul>
&lt;li>Web Browser API&lt;br>
提供给我们 JavaScript 所没有后台运行任务的能力，除了 &lt;code>setTimeout&lt;/code> 和 &lt;code>setInterval&lt;/code> 这样创建 timer 的 API 之外，还包括了 Ajax，用户交互，文件读写等操作。&lt;/li>
&lt;li>Callback Queue&lt;br>
用于持有提交到 Web Browser API 中等待回调的 callback。&lt;/li>
&lt;li>Event Loop&lt;br>
一个不停地检查 JavaScript 调用栈中是否还有任务的循环。&lt;/li>
&lt;/ul></description></item><item><title>React 进阶模式之复合组件（Compound Component）</title><link>https://joeytat.github.io/posts/190812_compound-component/</link><pubDate>Mon, 12 Aug 2019 00:00:00 +0000</pubDate><guid>https://joeytat.github.io/posts/190812_compound-component/</guid><description>
&lt;h3 id="复合组件是什么">复合组件是什么&lt;/h3>
&lt;p>编写页面时，经常存在多个子组件的展示，是依赖于同一个数据源的情况。
比如单选框：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-jsx" data-lang="jsx">&amp;lt;&lt;span style="color:#f92672">Switcher&lt;/span>&amp;gt;
&amp;lt;&lt;span style="color:#f92672">Switch&lt;/span> &lt;span style="color:#a6e22e">on&lt;/span>&lt;span style="color:#f92672">=&lt;/span>{&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">props&lt;/span>.&lt;span style="color:#a6e22e">selecting&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;React&amp;#39;&lt;/span>}&amp;gt;&lt;span style="color:#a6e22e">React&lt;/span>&amp;lt;/&lt;span style="color:#f92672">Switch&lt;/span>&amp;gt;
&amp;lt;&lt;span style="color:#f92672">Switch&lt;/span> &lt;span style="color:#a6e22e">on&lt;/span>&lt;span style="color:#f92672">=&lt;/span>{&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">props&lt;/span>.&lt;span style="color:#a6e22e">selecting&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;Vue&amp;#39;&lt;/span>}&amp;gt;&lt;span style="color:#a6e22e">Vue&lt;/span>&amp;lt;/&lt;span style="color:#f92672">Switch&lt;/span>&amp;gt;
&amp;lt;/&lt;span style="color:#f92672">Switcher&lt;/span>&amp;gt;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们可以看到，所有的 &lt;code>Switch&lt;/code> 的数据都需要对 &lt;code>selecting&lt;/code> 的值进行判断，并且代码中其实只有 &lt;code>this.props.selecting ==&lt;/code> 后面的部分不同，如果能改写成这样：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-jsx" data-lang="jsx">&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#a6e22e">Switcher&lt;/span>.&lt;span style="color:#a6e22e">React&lt;/span> &lt;span style="color:#f92672">=&lt;/span> ({&lt;span style="color:#a6e22e">selecting&lt;/span>}) =&amp;gt; (
&amp;lt;&lt;span style="color:#f92672">Switch&lt;/span> &lt;span style="color:#a6e22e">on&lt;/span>&lt;span style="color:#f92672">=&lt;/span>{&lt;span style="color:#a6e22e">selecting&lt;/span> &lt;span style="color:#f92672">===&lt;/span> &lt;span style="color:#e6db74">&amp;#39;React&amp;#39;&lt;/span>}&amp;gt;&lt;span style="color:#a6e22e">React&lt;/span>&amp;lt;/&lt;span style="color:#f92672">Switch&lt;/span>&amp;gt;
)
&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#a6e22e">Switcher&lt;/span>.&lt;span style="color:#a6e22e">Vue&lt;/span> &lt;span style="color:#f92672">=&lt;/span> ({&lt;span style="color:#a6e22e">selecting&lt;/span>}) =&amp;gt; (
&amp;lt;&lt;span style="color:#f92672">Switch&lt;/span> &lt;span style="color:#a6e22e">on&lt;/span>&lt;span style="color:#f92672">=&lt;/span>{&lt;span style="color:#a6e22e">selecting&lt;/span> &lt;span style="color:#f92672">===&lt;/span> &lt;span style="color:#e6db74">&amp;#39;Vue&amp;#39;&lt;/span>}&amp;gt;&lt;span style="color:#a6e22e">Vue&lt;/span>&amp;lt;/&lt;span style="color:#f92672">Switch&lt;/span>&amp;gt;
)
&amp;lt;&lt;span style="color:#f92672">Switcher&lt;/span> &lt;span style="color:#a6e22e">selecting&lt;/span>&lt;span style="color:#f92672">=&lt;/span>{&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">props&lt;/span>.&lt;span style="color:#a6e22e">selecting&lt;/span>}&amp;gt;
&amp;lt;&lt;span style="color:#f92672">Switcher.React&lt;/span>/&amp;gt;
&amp;lt;&lt;span style="color:#f92672">Switcher.Vue&lt;/span>/&amp;gt;
&amp;lt;/&lt;span style="color:#f92672">Switcher&lt;/span>&amp;gt;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>隐式地将父组件的数据传递给子组件，其显示逻辑交由给子组件自行处理，代码的组织结构将会清晰很多。后续即使需求变动，数据的传递改变也并不需要我们操心（不需要一个子组件一个子组件地添加传递），只需要修改 &lt;code>Switcher&lt;/code> 子控件内部处理逻辑即可。&lt;/p>
&lt;p>那么要怎么实现这个&lt;strong>隐式数据传递&lt;/strong>呢？ 可以通过 &lt;a href="https://reactjs.org/docs/react-api.html#reactchildren">&lt;code>React.Children.map&lt;/code>&lt;/a> 和 &lt;a href="https://reactjs.org/docs/react-api.html#cloneelement">&lt;code>React.cloneElement&lt;/code>&lt;/a> 这两个 API 来实现。&lt;/p>
&lt;h3 id="reactchildrenmap-与-reactcloneelement">React.Children.map 与 React.cloneElement&lt;/h3>
&lt;p>在 &lt;code>render&lt;/code> 中我们可以使用 &lt;code>React.Children.map&lt;/code> 来获取到 &lt;code>Switcher&lt;/code> 中的子组件，然后通过 &lt;code>React.cloneElement&lt;/code> 对组件进行克隆及数据传递：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-jsx" data-lang="jsx">&lt;span style="color:#a6e22e">render&lt;/span>() {
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">React&lt;/span>.&lt;span style="color:#a6e22e">Children&lt;/span>.&lt;span style="color:#a6e22e">map&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">props&lt;/span>.&lt;span style="color:#a6e22e">children&lt;/span>, &lt;span style="color:#a6e22e">child&lt;/span> =&amp;gt;
&lt;span style="color:#a6e22e">React&lt;/span>.&lt;span style="color:#a6e22e">cloneElement&lt;/span>(&lt;span style="color:#a6e22e">child&lt;/span>, {
&lt;span style="color:#a6e22e">on&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">state&lt;/span>.&lt;span style="color:#a6e22e">on&lt;/span>,
&lt;span style="color:#a6e22e">toggle&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">toggle&lt;/span>,
}),
)
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样，即使我们在使用 &lt;code>Switcher.React&lt;/code> 和 &lt;code>Switcher.Vue&lt;/code> 时，没有显式地传递参数，子组件也能获取数据。&lt;/p>
&lt;blockquote>
&lt;p>这里 &lt;code>React.Children.map&lt;/code> 与 &lt;code>this.props.children.map&lt;/code> 并不等价，后者在只有一个子组件的时候，返回的不是数组，而是唯一的那个组件。&lt;/p>
&lt;/blockquote>
&lt;h3 id="reactchildrenmap-的局限性">React.Children.map 的局限性&lt;/h3>
&lt;p>上面代码有个问题是，如果出现了更多层级的子组件，那么参数传递只会到第一层。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-jsx" data-lang="jsx">&amp;lt;&lt;span style="color:#f92672">Switcher&lt;/span> &lt;span style="color:#a6e22e">selecting&lt;/span>&lt;span style="color:#f92672">=&lt;/span>{&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">props&lt;/span>.&lt;span style="color:#a6e22e">selecting&lt;/span>}&amp;gt;
&amp;lt;&lt;span style="color:#f92672">Switcher.React&lt;/span>/&amp;gt;
&amp;lt;&lt;span style="color:#f92672">div&lt;/span>&amp;gt;
&amp;lt;&lt;span style="color:#f92672">Switcher.Vue&lt;/span>/&amp;gt;
&amp;lt;/&lt;span style="color:#f92672">div&lt;/span>&amp;gt;
&amp;lt;/&lt;span style="color:#f92672">Switcher&lt;/span>&amp;gt;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样写会提示传递了错误的参数给 &lt;code>div&lt;/code>，因为我们 &lt;code>React.Children.map&lt;/code> 只能获取到第一层子组件（&lt;code>[Switcher.React, div]&lt;/code>）。&lt;/p>
&lt;p>那怎么办，难道要用递归？React 16.x 提供了新的 &lt;a href="https://reactjs.org/docs/context.html#when-to-use-context">Context&lt;/a> 可以很好地解决这个问题。&lt;/p>
&lt;p>Context 的使用方法很简单，首先创建一个 Context：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-jsx" data-lang="jsx">&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">selecting&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">SwitcherContext&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">React&lt;/span>.&lt;span style="color:#a6e22e">createContext&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>接着是 &lt;code>render&lt;/code>，既然我们不确定会有多少层的子组件，那么就直接将 &lt;code>this.props.children&lt;/code> 包裹在 &lt;code>Context.Provider&lt;/code> 中：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-jsx" data-lang="jsx">&amp;lt;&lt;span style="color:#f92672">SwitcherContext.Provider&lt;/span> &lt;span style="color:#a6e22e">value&lt;/span>&lt;span style="color:#f92672">=&lt;/span>{&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">props&lt;/span>.&lt;span style="color:#a6e22e">selecting&lt;/span>}&amp;gt;
{&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">props&lt;/span>.&lt;span style="color:#a6e22e">children&lt;/span>}
&amp;lt;/&lt;span style="color:#f92672">SwitcherContext.Provider&lt;/span>&amp;gt;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后改写我们的子组件数据获取方式，之前是通过 &lt;code>React.cloneElement&lt;/code> 来将数据通过 &lt;code>props&lt;/code> 传递到组件中，现在可以直接从 &lt;code>Context.Consumer&lt;/code> 中获取：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-jsx" data-lang="jsx">&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#a6e22e">Switcher&lt;/span>.&lt;span style="color:#a6e22e">React&lt;/span> &lt;span style="color:#f92672">=&lt;/span>() =&amp;gt; (
&amp;lt;&lt;span style="color:#f92672">SwitcherContext.Consumer&lt;/span>&amp;gt;
{ &lt;span style="color:#a6e22e">selecting&lt;/span> =&amp;gt; (
&amp;lt;&lt;span style="color:#f92672">Switch&lt;/span> &lt;span style="color:#a6e22e">on&lt;/span>&lt;span style="color:#f92672">=&lt;/span>{&lt;span style="color:#a6e22e">selecting&lt;/span> &lt;span style="color:#f92672">===&lt;/span> &lt;span style="color:#e6db74">&amp;#39;React&amp;#39;&lt;/span>}&amp;gt;&lt;span style="color:#a6e22e">React&lt;/span>&amp;lt;/&lt;span style="color:#f92672">Switch&lt;/span>&amp;gt;)
}
&amp;lt;/&lt;span style="color:#f92672">SwitcherContext.Consumer&lt;/span>&amp;gt;
)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>如此一来就完成了我们的改造。外部使用到 &lt;code>Switcher&lt;/code> 的地方没有任何变动，依然是：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-jsx" data-lang="jsx">&amp;lt;&lt;span style="color:#f92672">Switcher&lt;/span> &lt;span style="color:#a6e22e">selecting&lt;/span>&lt;span style="color:#f92672">=&lt;/span>{&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">props&lt;/span>.&lt;span style="color:#a6e22e">selecting&lt;/span>}&amp;gt;
&amp;lt;&lt;span style="color:#f92672">Switcher.React&lt;/span>/&amp;gt;
&amp;lt;&lt;span style="color:#f92672">div&lt;/span>&amp;gt;
&amp;lt;&lt;span style="color:#f92672">Switcher.Vue&lt;/span>/&amp;gt;
&amp;lt;/&lt;span style="color:#f92672">div&lt;/span>&amp;gt;
&amp;lt;/&lt;span style="color:#f92672">Switcher&lt;/span>&amp;gt;
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="相关资料">相关资料&lt;/h4>
&lt;ul>
&lt;li>&lt;a href="https://frontendmasters.com/courses/advanced-react-patterns/">Frontend Masters - Advanced React Patterns&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://reactjs.org/docs/context.html#when-to-use-context">React Context&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>翻译 - 图像优化</title><link>https://joeytat.github.io/posts/190619_optimizing_images/</link><pubDate>Wed, 19 Jun 2019 00:00:00 +0000</pubDate><guid>https://joeytat.github.io/posts/190619_optimizing_images/</guid><description>
&lt;p>翻译自 &lt;a href="https://www.swiftjectivec.com/optimizing-images/">Optimizing Images&lt;/a> by &lt;a href="https://twitter.com/jordanmorgan10">Jordan Morgan&lt;/a>&lt;/p>
&lt;p>有句话说：最好的照相机就是在你身边的那台。 如果这句俗语是对的，那么毫无疑问地— iPhone 是这个星球上最重要的相机， 并且我们的业界也证明了这一点。&lt;/p>
&lt;p>在度假中? 如果没有在你的 Instagram Story 中留下几张照片，那就不算发生过。&lt;/p>
&lt;p>爆炸新闻? 立刻打开 Twitter 来查看哪些媒体在通过照片实时报道事件。&lt;/p>
&lt;p>等等。&lt;/p>
&lt;p>由于图像在各个平台无处不在的出现，在低性能且内存紧张的情况下展示它们，会很容易地造成失控。 如果我们知道 UIKit 底层到底发生了什么，为什么以及如何处理图像，那么我们可以节省大量的资源开销，并且逃脱无情的系统清除制裁。&lt;/p>
&lt;h2 id="理论上来说">理论上来说&lt;/h2>
&lt;p>突击测验 - 这张我女儿的 266 KB 字节大小（并且还蛮时尚的）的照片，在一个 iOS App 中会展示需要用到多少内存?&lt;/p>
&lt;p>&lt;img src="https://www.swiftjectivec.com/assets/images/baylor.jpg" alt="Baylor">&lt;/p>
&lt;p>剧透一下 - 不是 266 KB，也不是 2.66 MB，而是大概 14 MB。&lt;/p>
&lt;p>为什么?&lt;/p>
&lt;p>本质上来说 iOS 申请内存是根据图像的尺寸 - 而图像的文件大小反而影响不大。 这张图片的尺寸是 1718 x 2048 像素。 假设每个像素会占用 4 个字节:&lt;/p>
&lt;blockquote>
&lt;p>1718 * 2048 * 4 / 1024 / 1024 = 13.42 MB 大约&lt;/p>
&lt;/blockquote>
&lt;p>想象一下，如果你需要展示一个列表的用户信息，其中每一行都显示一个常见的圆形头像在左侧。 如果你觉得每一张图片都通过 ImageOptim 或者其他方式处理过就没问题，那就错了。 保守估计每一张头像是 256 x 256 大小，那依然会耗费大量内存。&lt;/p>
&lt;h2 id="渲染路径">渲染路径&lt;/h2>
&lt;p>这就是说 - 明白底层是怎么回事是很划算的。 当你加载一张图片的时候，会经由这三步处理:&lt;/p>
&lt;p>1） 加载 - iOS 会获取到尚未解压的图片，然后开辟（我们的图片举例） 266 kb 的内存，目前为止没什么好担心的。&lt;/p>
&lt;p>2） 解码 - 现在 iOS 会将图片转化为 GPU 可以读取并且处理的数据。 现在是解压，在这一步就会产生我们上面提到的 14 MB 的内存开销。&lt;/p>
&lt;p>3） 渲染 - 按照字面意思理解，现在图片数据准备好了以任何方式进行渲染。 即使是放在 60 x 60 point 的 image view 中。&lt;/p>
&lt;p>解码阶段是大头。 在这里 iOS 会创建一个缓冲区 - 准确的说是图片缓冲区。 这里会将图像放在内存中。 这也是为什么，其内存占用会和图片尺寸挂钩而不是图片文件大小。 这就清晰地解释了，当处理图片时，为什么尺寸对于内存消耗如此重要。&lt;/p>
&lt;p>针对 &lt;code>UIImage&lt;/code>， 当我们把从网络请求或者其他途径获取的图片数据传递给它时，它会将缓冲区的数据解码成数据声称的格式（比如 PNG 或者 JPEG）。 然而它就会在这停顿了。 由于渲染并非只是一次性操作，&lt;code>UIImage&lt;/code> 会保留这个数据缓冲，这样它只需要解码一次。&lt;/p>
&lt;p>我们来扩展一下这个概念 - 对于任何 iOS App 来说一个完整的缓冲区就是其帧缓冲区。 这就是当 app 展示在屏幕上时，负责持有输出渲染内容的东西。 任何 iOS 设备上的显示硬件，都会使用其中的像素信息来点亮对应的物理屏幕像素。&lt;/p>
&lt;p>此处时间很重要。 为了达到每秒 60 帧如黄油般顺滑的滚动效果，在 app 的 window 及其 subviews 改变的时候（比如分配了一个 image 给 image view），帧缓冲区需要 UIKit 来渲染。 如果渲染慢了，就会掉帧。&lt;/p>
&lt;blockquote>
&lt;p>觉得只有 1/60 秒处理时间太短了? 具备 Pro Motion 的设备只会给 1/120 秒的时间。&lt;/p>
&lt;/blockquote>
&lt;h2 id="大小真的很重要">大小真的很重要&lt;/h2>
&lt;p>我们其实可以很轻松地观察到这步处理以及内存时如何被消耗掉的。 我创建了一个实验 app，用 image view 来展示了我女儿的照片。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-swift" data-lang="swift">&lt;span style="color:#66d9ef">let&lt;/span> filePath = Bundle.main.path(forResource:&lt;span style="color:#e6db74">&amp;#34;baylor&amp;#34;&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">，&lt;/span>ofType: &lt;span style="color:#e6db74">&amp;#34;jpg&amp;#34;&lt;/span>)&lt;span style="color:#f92672">!&lt;/span>
&lt;span style="color:#66d9ef">let&lt;/span> url = NSURL(fileURLWithPath: filePath)
&lt;span style="color:#66d9ef">let&lt;/span> fileImage = UIImage(contentsOfFile: filePath)
&lt;span style="color:#75715e">// Image view&lt;/span>
&lt;span style="color:#66d9ef">let&lt;/span> imageView = UIImageView(image: fileImage)
imageView.translatesAutoresizingMaskIntoConstraints = &lt;span style="color:#66d9ef">false&lt;/span>
imageView.contentMode = .scaleAspectFit
imageView.widthAnchor.constraint(equalToConstant: &lt;span style="color:#ae81ff">300&lt;/span>).isActive = &lt;span style="color:#66d9ef">true&lt;/span>
imageView.heightAnchor.constraint(equalToConstant: &lt;span style="color:#ae81ff">400&lt;/span>).isActive = &lt;span style="color:#66d9ef">true&lt;/span>
view.addSubview(imageView)
imageView.centerXAnchor.constraint(equalTo: view.centerXAnchor).isActive = &lt;span style="color:#66d9ef">true&lt;/span>
imageView.centerYAnchor.constraint(equalTo: view.centerYAnchor).isActive = &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>这里我们只是为了演示场景，在生产环境中请谨慎使用强制解包。&lt;/p>
&lt;/blockquote>
&lt;p>上面的代码运行起来时这样:&lt;/p>
&lt;p>&lt;img src="https://www.swiftjectivec.com/assets/images/baylorPhone.jpg" alt="Baylor">&lt;/p>
&lt;p>虽然我们使用了一个小得多的 Image View 来展示图片，但通过 LLDB 我们可以查看到图片实际的尺寸。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-swift" data-lang="swift">&amp;lt;UIImage: &lt;span style="color:#ae81ff">0x600003d41a40&lt;/span>&amp;gt;&lt;span style="color:#960050;background-color:#1e0010">，&lt;/span>{&lt;span style="color:#ae81ff">1718&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">，&lt;/span>&lt;span style="color:#ae81ff">2048&lt;/span>}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>记住，这是点表示。 所以如果我使用的是 3x 或者 2x 设备，这个数字需要更大一些。 我们可以使用 vmmap 来确定这张图片是否真的占用了 14 MB。&lt;/p>
&lt;pre tabindex="0">&lt;code>vmmap --summary baylor.memgraph
&lt;/code>&lt;/pre>&lt;p>有几个东西引起了注意（为了简洁只截出了部分输出）:&lt;/p>
&lt;pre tabindex="0">&lt;code>Physical footprint: 69.5M
Physical footprint (peak): 69.7M
&lt;/code>&lt;/pre>&lt;p>接近 70 MB 给了我们一个很好的参考来确定我们的重构是否有效。 如果我们通过 grep 命令来筛选 Image IO，我们也能够看到图片的开销。&lt;/p>
&lt;pre tabindex="0">&lt;code>vmmap --summary baylor.memgraph | grep &amp;quot;Image IO&amp;quot;
Image IO 13.4M 13.4M 13.4M 0K 0K 0K 0K 2
&lt;/code>&lt;/pre>&lt;p>啊哈 - 这里就有接近 14 MB 的脏内存。 如同我们在餐巾纸背面写下的公式计算的那样。 背景补充一下，这是一个终端的屏幕截图，清楚地显示了每一列的含义。 （由于他们被 grep 命令给省略掉了）&lt;/p>
&lt;p>&lt;img src="https://www.swiftjectivec.com/assets/images/vmmap.jpg" alt="">&lt;/p>
&lt;p>所以很明确了，此刻我们在 300 x 400 的 image view 中也依然付出了图像的完整开销。 图像的大小是很关键，但这并不是唯一重要的点。&lt;/p>
&lt;h2 id="色域">色域&lt;/h2>
&lt;p>你所请求的内存消耗有一部分源于另一个重要因素 - 色域。 在上面的例子中我们做了一个假设，而这个假设并不适用于大多数 iPhone - 也就是图像采用的是 sRGB 格式。 每个像素 4 个字节对应的是红，蓝，绿以及透明。&lt;/p>
&lt;p>如果你使用的是支持广色域格式的设备（iPhone 8+ 或 iPhone X）进行拍摄，那就可以肯定数字会加倍了。 当然了，反过来也一样，Metal 支持使用 Alpha 8 格式，就像其名字描述的那样只有单一通道。&lt;/p>
&lt;p>这里有非常多需要考虑的东西。 这也是为什么你应该使用 &lt;a href="https://swiftjectivec.com/UIGraphicsImageRenderer">UIGraphicsImageRenderer&lt;/a> 而不是 &lt;code>UIGraphicsBeginImageContextWithOptions&lt;/code>。 后者会&lt;strong>一直&lt;/strong>使用 sRGB，这也意味着你会丢失广色域格式，如果你 &lt;a href="https://instagram-engineering.com/bringing-wide-color-to-instagram-5a5481802d7d">想要的话&lt;/a>，或是错失节省开销的机会。 在 iOS 12 之后，&lt;code>UIGraphicsImageRenderer&lt;/code> 会自动帮你选择正确的方案。&lt;/p>
&lt;p>最后别忘记了，很多图片并不是拍摄出来的，而是通过绘图绘制的。 这里并不是刻意重复我写过的东西，只是怕你之前错过了:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-swift" data-lang="swift">&lt;span style="color:#66d9ef">let&lt;/span> circleSize = CGSize(width: &lt;span style="color:#ae81ff">60&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">，&lt;/span>height: &lt;span style="color:#ae81ff">60&lt;/span>)
UIGraphicsBeginImageContextWithOptions(circleSize&lt;span style="color:#960050;background-color:#1e0010">，&lt;/span>&lt;span style="color:#66d9ef">true&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">，&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>)
&lt;span style="color:#75715e">// Draw a circle&lt;/span>
&lt;span style="color:#66d9ef">let&lt;/span> ctx = UIGraphicsGetCurrentContext()&lt;span style="color:#f92672">!&lt;/span>
UIColor.red.setFill()
ctx.setFillColor(UIColor.red.cgColor)
ctx.addEllipse(&lt;span style="color:#66d9ef">in&lt;/span>: CGRect(x: &lt;span style="color:#ae81ff">0&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">，&lt;/span>y: &lt;span style="color:#ae81ff">0&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">，&lt;/span>width: circleSize.width&lt;span style="color:#960050;background-color:#1e0010">，&lt;/span>height: circleSize.height))
ctx.drawPath(using: .fill)
&lt;span style="color:#66d9ef">let&lt;/span> circleImage = UIGraphicsGetImageFromCurrentImageContext()
UIGraphicsEndImageContext()
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个圆形图片使用的是每个像素 4 字节格式。 如果你使用 &lt;code>UIGraphicsImageRenderer&lt;/code> 那么渲染器会自动选择合适的格式，为每个像素节省 75% 的内存消耗。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-swift" data-lang="swift">&lt;span style="color:#66d9ef">let&lt;/span> circleSize = CGSize(width: &lt;span style="color:#ae81ff">60&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">，&lt;/span>height: &lt;span style="color:#ae81ff">60&lt;/span>)
&lt;span style="color:#66d9ef">let&lt;/span> renderer = UIGraphicsImageRenderer(bounds: CGRect(x: &lt;span style="color:#ae81ff">0&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">，&lt;/span>y: &lt;span style="color:#ae81ff">0&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">，&lt;/span>width: circleSize.width&lt;span style="color:#960050;background-color:#1e0010">，&lt;/span>height: circleSize.height))
&lt;span style="color:#66d9ef">let&lt;/span> circleImage = renderer.image{ ctx &lt;span style="color:#66d9ef">in&lt;/span>
UIColor.red.setFill()
ctx.cgContext.setFillColor(UIColor.red.cgColor)
ctx.cgContext.addEllipse(&lt;span style="color:#66d9ef">in&lt;/span>: CGRect(x: &lt;span style="color:#ae81ff">0&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">，&lt;/span>y: &lt;span style="color:#ae81ff">0&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">，&lt;/span>width: circleSize.width&lt;span style="color:#960050;background-color:#1e0010">，&lt;/span>height: circleSize.height))
ctx.cgContext.drawPath(using: .fill)
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="缩小分辨率-vs-缩小采样">缩小分辨率 vs 缩小采样&lt;/h2>
&lt;p>让我们跳过简单绘图的场景 - 还有非常多与图像相关的内存问题，源自真实的摄影图片。 比如人像，风景照。&lt;/p>
&lt;p>对于一些工程师来说，他们有理由（逻辑上也说得过去）相信，通过 &lt;code>UIImage&lt;/code> 简单地缩小图像尺寸就足够了。 但由于上面提及的原因，这通常来说不够，而且据 Apple 员工 Kyle Howarth 描述这也没有那么高效。&lt;/p>
&lt;p>如我们之前讨论渲染路径时提到的，&lt;code>UIImage&lt;/code> 会产生内存问题的主要原因是它会将原始图像加载到内存中进行解压。 理想状态下，我们应该减少图像缓存区的大小。&lt;/p>
&lt;p>幸运的是，我们其实可以只以调整图像文件的大小为代价，来影响图像内存大小。 通常人们会假设这就是系统如何实现的，但其实不是。&lt;/p>
&lt;p>让我们用点底层 API 来缩小采样试试:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-swift" data-lang="swift">&lt;span style="color:#66d9ef">let&lt;/span> imageSource = CGImageSourceCreateWithURL(url&lt;span style="color:#960050;background-color:#1e0010">，&lt;/span>&lt;span style="color:#66d9ef">nil&lt;/span>)&lt;span style="color:#f92672">!&lt;/span>
&lt;span style="color:#66d9ef">let&lt;/span> options: [NSString:Any] = [kCGImageSourceThumbnailMaxPixelSize:&lt;span style="color:#ae81ff">400&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">，&lt;/span>
kCGImageSourceCreateThumbnailFromImageAlways:&lt;span style="color:#66d9ef">true&lt;/span>]
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#66d9ef">let&lt;/span> scaledImage = CGImageSourceCreateThumbnailAtIndex(imageSource&lt;span style="color:#960050;background-color:#1e0010">，&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">，&lt;/span>options &lt;span style="color:#66d9ef">as&lt;/span> CFDictionary) {
&lt;span style="color:#66d9ef">let&lt;/span> imageView = UIImageView(image: UIImage(cgImage: scaledImage))
imageView.translatesAutoresizingMaskIntoConstraints = &lt;span style="color:#66d9ef">false&lt;/span>
imageView.contentMode = .scaleAspectFit
imageView.widthAnchor.constraint(equalToConstant: &lt;span style="color:#ae81ff">300&lt;/span>).isActive = &lt;span style="color:#66d9ef">true&lt;/span>
imageView.heightAnchor.constraint(equalToConstant: &lt;span style="color:#ae81ff">400&lt;/span>).isActive = &lt;span style="color:#66d9ef">true&lt;/span>
view.addSubview(imageView)
imageView.centerXAnchor.constraint(equalTo: view.centerXAnchor).isActive = &lt;span style="color:#66d9ef">true&lt;/span>
imageView.centerYAnchor.constraint(equalTo: view.centerYAnchor).isActive = &lt;span style="color:#66d9ef">true&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>再次运行，我们得到的显示效果和之前一样。 但在这里，我们使用了 &lt;code>CGImageSourceCreateThumbnailAtIndex()&lt;/code> 而不是直接将原始图像放在 image view 中。 真相大白的时刻到了，让我们通过 &lt;code>vmmap&lt;/code> 来看看我们的优化是否奏效（再一次，为了简洁只截取了部分）:&lt;/p>
&lt;pre tabindex="0">&lt;code>vmmap -summary baylorOptimized.memgraph
Physical footprint: 56.3M
Physical footprint (peak): 56.7M
&lt;/code>&lt;/pre>&lt;p>节省的开销都统计在了一起。 如果我们将之前的 69.5M 和现在的 56.3M 进行对比，我们节约了 13.2M。 这是个很大的节省，几乎是整个图片的大小。&lt;/p>
&lt;p>再进一步，你可以根据你的需要通过各种选项来打磨。 在 WWDC 2018 Session 219 &amp;ldquo;Images and Graphics Best Practices&amp;rdquo; 中，Apple 工程师 Kyle Sluder 通过使用 &lt;code>kCGImageSourceShouldCacheImmediately&lt;/code> 标记来展示了一个很有趣的技巧控制解码:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-swift" data-lang="swift">&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">downsampleImage&lt;/span>(at URL:NSURL&lt;span style="color:#960050;background-color:#1e0010">，&lt;/span>maxSize:Float) -&amp;gt; UIImage
{
&lt;span style="color:#66d9ef">let&lt;/span> sourceOptions = [kCGImageSourceShouldCache:&lt;span style="color:#66d9ef">false&lt;/span>] &lt;span style="color:#66d9ef">as&lt;/span> CFDictionary
&lt;span style="color:#66d9ef">let&lt;/span> source = CGImageSourceCreateWithURL(URL &lt;span style="color:#66d9ef">as&lt;/span> CFURL&lt;span style="color:#960050;background-color:#1e0010">，&lt;/span>sourceOptions)&lt;span style="color:#f92672">!&lt;/span>
&lt;span style="color:#66d9ef">let&lt;/span> downsampleOptions = [kCGImageSourceCreateThumbnailFromImageAlways:&lt;span style="color:#66d9ef">true&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">，&lt;/span>
kCGImageSourceThumbnailMaxPixelSize:maxSize
kCGImageSourceShouldCacheImmediately:&lt;span style="color:#66d9ef">true&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">，&lt;/span>
kCGImageSourceCreateThumbnailWithTransform:&lt;span style="color:#66d9ef">true&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">，&lt;/span>
] &lt;span style="color:#66d9ef">as&lt;/span> CFDictionary
&lt;span style="color:#66d9ef">let&lt;/span> downsampledImage = CGImageSourceCreateThumbnailAtIndex(source, &lt;span style="color:#ae81ff">0&lt;/span>, downsampleOptions)&lt;span style="color:#f92672">!&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> UIImage(cgImage: downsampledImage)
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Core Graphics 并不会参与解码图片，直到你明确需要使用缩略图的时候。 并且需要注意传入 &lt;code>kCGImageSourceCreateThumbnailMaxPixelSize&lt;/code>，就像我们做的上面两个例子那样。 如果你不传，那么你会得到一个和原始图像一样大小的缩略图。 据文档描述:&lt;/p>
&lt;blockquote>
&lt;p>“…如果没有指定最大像素大小，那么缩略图就会是完整的图片大小，这可能不是你想要的。”
“…if a maximum pixel size isn’t specified, then the thumbnail will be the size of the full image, which probably isn’t what you want.”&lt;/p>
&lt;/blockquote>
&lt;p>那么这里发生了什么? 简单来说，我们通过在缩略图上使用了缩小部分图片的等式，创建了一个小得多的解码图像缓冲区。 回忆一下之前提到的渲染路径，第一步（加载）现在我们没有创建一个原始图像大小的缓冲区，而是一个 image view 显示大小的缓冲区。&lt;/p>
&lt;p>想要一个这篇文章的太长不读版本? 找机会降低图像采样，而不是使用 &lt;code>UIImage&lt;/code> 缩小图片。&lt;/p>
&lt;h2 id="附加部分">附加部分&lt;/h2>
&lt;p>我个人在 Tandem 中配合着 &lt;a href="https://developer.apple.com/documentation/uikit/uitableviewdatasourceprefetching?language=swift">prefetch API&lt;/a> （iOS 11） 使用了这种技术。 但要记住即使我们在真正使用 table view 或者 collection view 之前这样做，我们在解码图片的时候，内部依然会带来的一个 CPU 使用量的高峰。&lt;/p>
&lt;p>尽管 iOS 在面对持续性能消耗时有很高效的处理方案，但在我们的例子中，可能是时不时才会产生这样的高峰。 所以在处理这种问题的时候，最好把希望寄予你自己创建的队列。 另一个优势是，这样还能将解码移动到后台处理。&lt;/p>
&lt;p>快遮住眼睛，我业余项目中的 Objective-C 代码要出来了:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-objc" data-lang="objc">&lt;span style="color:#75715e">// 用你自己的队列而不是 global 队列可以避免潜在的线程爆炸
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
- (&lt;span style="color:#66d9ef">void&lt;/span>)&lt;span style="color:#a6e22e">tableView:&lt;/span>(UITableView &lt;span style="color:#f92672">*&lt;/span>)tableView &lt;span style="color:#a6e22e">prefetchRowsAtIndexPaths:&lt;/span>(NSArray&lt;span style="color:#f92672">&amp;lt;&lt;/span>NSIndexPath &lt;span style="color:#f92672">*&amp;gt;&lt;/span> &lt;span style="color:#f92672">*&lt;/span>)indexPaths
{
&lt;span style="color:#66d9ef">if&lt;/span> (self.downsampledImage &lt;span style="color:#f92672">!=&lt;/span> nil &lt;span style="color:#f92672">||&lt;/span>
self.listItem.mediaAssetData &lt;span style="color:#f92672">==&lt;/span> nil) &lt;span style="color:#66d9ef">return&lt;/span>;
NSIndexPath &lt;span style="color:#f92672">*&lt;/span>mediaIndexPath &lt;span style="color:#f92672">=&lt;/span> [NSIndexPath indexPathForRow:&lt;span style="color:#ae81ff">0&lt;/span>
inSection:SECTION_MEDIA];
&lt;span style="color:#66d9ef">if&lt;/span> ([indexPaths containsObject:mediaIndexPath])
{
CGFloat scale &lt;span style="color:#f92672">=&lt;/span> tableView.traitCollection.displayScale;
CGFloat maxPixelSize &lt;span style="color:#f92672">=&lt;/span> (tableView.width &lt;span style="color:#f92672">-&lt;/span> SSSpacingJumboMargin) &lt;span style="color:#f92672">*&lt;/span> scale;
dispatch_async(self.downsampleQueue&lt;span style="color:#960050;background-color:#1e0010">，&lt;/span>&lt;span style="color:#f92672">^&lt;/span>{
&lt;span style="color:#75715e">// 缩减采样
&lt;/span>&lt;span style="color:#75715e">&lt;/span> self.downsampledImage &lt;span style="color:#f92672">=&lt;/span> [UIImage downsampledImageFromData:self.listItem.mediaAssetData
scale:scale
maxPixelSize:maxPixelSize];
dispatch_async(dispatch_get_main_queue()&lt;span style="color:#960050;background-color:#1e0010">，&lt;/span>&lt;span style="color:#f92672">^&lt;/span> {
self.listItem.downsampledMediaImage &lt;span style="color:#f92672">=&lt;/span> self.downsampledImage;
});
});
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>注意在你有大量的原始图像（raw image）资源时使用资源管理（asset catalogs）。
因为它会帮你管理缓存大小（还有其他很多的优势）&lt;/p>
&lt;/blockquote>
&lt;p>想要了解更多关于图像和内存管理的信息，可以关注这些信息量巨大的 WWDC 18 session:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://developer.apple.com/videos/play/wwdc2018/416/?time=1074">iOS Memory Deep Dive&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developer.apple.com/videos/play/wwdc2018/219/">Images and Graphics Best Practices&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="总结一下">总结一下&lt;/h2>
&lt;p>你无法察觉你不知道的东西。 就编程来说，你基本上相当于报名参加了一个需要持续跑每小时 10，000 米以跟上创新和变革的职业生涯。 这意味着&amp;hellip;有大量的 API，框架，设计模式或者优化方案你并不知晓。&lt;/p>
&lt;p>在图像领域尤其是这样。 大多数时间，你可能只是初始化了一个 &lt;code>UIImageView&lt;/code> 然后放进了一些好看的像素，就过了。 我知道啦，摩尔定理什么的。 现在这些电话运行速度很快，而且有数 G 的内存，并且我们把人类运送到了月球上，都只用了一台不到 100K 内存的电脑。&lt;/p>
&lt;p>但是和魔鬼共舞不会长久，他必然需要滋养他的角。 别让系统杀掉你的应用，只是因为你用了 1G 内存来展示一张自拍照。 但愿这些知识和技巧可以将你拯救于崩溃日志。&lt;/p>
&lt;p>下次见 ✌️。&lt;/p></description></item><item><title>Platforms State of the Union(WWDC 2019)</title><link>https://joeytat.github.io/posts/190605_wwdc2019_platforms_state_of_the_union/</link><pubDate>Wed, 05 Jun 2019 00:00:00 +0000</pubDate><guid>https://joeytat.github.io/posts/190605_wwdc2019_platforms_state_of_the_union/</guid><description>
&lt;h2 id="swiftui">SwiftUI&lt;/h2>
&lt;p>在 View 层级提供了四种特性:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Declarative
通过声明式的语句来描述 UI 布局, 样式, 动画等.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Automatic
可交互形动画, 动态字号, 夜间模式都可以通过配置来轻松实现.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Compositional
组合性. 各种控件都能极其方便地组合在一起, 远比 &lt;code>UIStackView&lt;/code> 方便.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-swift" data-lang="swift">VStack(alignment: .leading) {
Text(item.title)
Text(item.subtitle)
}
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>Consistent
自带 Reactive 特性. 将 Model 对象继承自 &lt;code>BindableObject&lt;/code>, 并且声明属性为 &lt;code>@State&lt;/code> 即可获得当属性改变时, UI 控件自动更新的效果.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>真的如果如此美好, 超级吃性能的 xib 和 storyboard 是不是可以退出舞台了.&lt;/p>
&lt;h2 id="xcode-11">Xcode 11&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>Live Development
直接在 Xcode Preview 中拖动控件即可生成对应的 SwiftUI 代码. 对应的修改 SwiftUI 代码也能实时在 Preview 中响应.&lt;/p>
&lt;p>Preview 还能通过提供一个 &lt;code>PreviewProvider&lt;/code> 来为其提供数据填充展示, 样式更改甚至循环语句来生成多个 Preview 同时查看控件在夜间模式和白日模式下不同的效果.&lt;/p>
&lt;p>Preview 部署在设备上也能热加载.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Package Management
Swift 终于有自己的 Package manage 了. 并且和 Xcode 进行了深度整合.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Minimap
代码在右侧会呈现类似 ctrl+6 的缩略图.
如果代码中写了 &lt;code>// MARK: -&lt;/code> &lt;code>// TODO: -&lt;/code> 等标记, 会更清晰地显示出来. 按住 cmd 会显示所有的标记.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>版本管理
可以直接在修改代码的位置查看到原来的版本.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Test Plan
同时测试各种平台各种设备.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="跨平台方案">跨平台方案&lt;/h2>
&lt;p>SwiftUI 支持跨平台, 同时支持 iOS, macOS, iPadOS. 那如何在 iOS App 的基础上创建一个 macOS App 呢? 只需要三个步骤:&lt;/p>
&lt;ol>
&lt;li>勾选上 deployment 中的 ✅ mac&lt;/li>
&lt;li>同时勾选上 ✅ iPad, 一个好的 iPad app, 就是一个好的 macOS app&lt;/li>
&lt;li>针对 macOS 的菜单, 快捷键等具有平台特殊性质的操作进行一些单独适配.&lt;/li>
&lt;/ol>
&lt;p>还对 catalina 的一些系统修改进行了介绍, 比如各种资源权限的收紧, 并且文件资源权限分成了两部分, 系统文件对于三方 app 变成了只读.&lt;/p>
&lt;blockquote>
&lt;p>后面都是各平台系统或新功能的介绍, 还是不继续施工了.&lt;/p>
&lt;/blockquote></description></item><item><title>如何实现 JavaScript 函数参数必填的支持?</title><link>https://joeytat.github.io/posts/190603_js_required_property/</link><pubDate>Mon, 03 Jun 2019 00:00:00 +0000</pubDate><guid>https://joeytat.github.io/posts/190603_js_required_property/</guid><description>
&lt;p>JS 在 ES6 的中新增了函数参数指定默认值的支持:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js">&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">Greeting&lt;/span> &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#a6e22e">name&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Joeytat&amp;#34;&lt;/span>) =&amp;gt; {
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">`Hello &lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#a6e22e">name&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">`&lt;/span>)
}
&lt;span style="color:#a6e22e">Greeting&lt;/span>() &lt;span style="color:#75715e">// Hello Joeytat
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>那我们就可以利用这一特性, 将一个会抛出异常的方法作为默认参数传递.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js">&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">Greeting&lt;/span> &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#a6e22e">name&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#a6e22e">EmptyPropertyException&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;name&amp;#34;&lt;/span>)) =&amp;gt; {
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">`Hello &lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#a6e22e">name&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">`&lt;/span>)
}
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">EmptyPropertyException&lt;/span> &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#a6e22e">propertyName&lt;/span>) =&amp;gt; {
&lt;span style="color:#66d9ef">throw&lt;/span> Error(&lt;span style="color:#e6db74">`&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#a6e22e">propertyName&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74"> 为必填参数`&lt;/span>)
}
&lt;span style="color:#a6e22e">Greeting&lt;/span>() &lt;span style="color:#75715e">// 抛出异常: &amp;#34;Error: name 为必填参数&amp;#34;
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样如果没有传递参数就会抛出异常, 并且带有友好的提示了.&lt;/p></description></item><item><title>2018</title><link>https://joeytat.github.io/posts/181218_overview/</link><pubDate>Fri, 28 Dec 2018 00:00:00 +0000</pubDate><guid>https://joeytat.github.io/posts/181218_overview/</guid><description>
&lt;p>刚毕业那阵儿还每年都写好长的总结, 然后这两年变懒了. 今年又想再记录一下了嘿 | ᐕ)⁾⁾&lt;/p>
&lt;ul>
&lt;li>
&lt;p>年度 App: &lt;a href="https://www.duolingo.com">多邻国&lt;/a>&lt;/p>
&lt;p>零基础学语言的感觉很不错.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>年度电影: &lt;a href="https://movie.douban.com/subject/26611804/">《三块广告牌》&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>年度漫画: &lt;a href="https://zh.wikipedia.org/wiki/%E5%8F%AA%E6%9C%89%E6%88%91%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84%E5%9F%8E%E5%B8%82">《只有我不存在的城市》&lt;/a>&lt;/p>
&lt;p>忘了在哪被人推荐的了, 被安利到的话大概是这么说的「非常庆幸在没有被剧透的情况下一口气看完了」. 看完了之后感觉果然如此. 而且漫画真是存在着动画无法表现出的节奏感啊.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>年度游戏: &lt;a href="https://zh.wikipedia.org/wiki/%E7%A5%9E%E7%95%8C%EF%BC%9A%E5%8E%9F%E7%BD%AA2">《神界原罪 2》&lt;/a>&lt;/p>
&lt;p>接触的第一款 CRPG, 有趣到什么程度呢? 从游戏体验时发出「wow, 居然还能这样?」的频率来看, 和《塞尔达: 旷野之息》差不多吧.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>年度虚构类图书: 《剑来》&lt;/p>
&lt;p>不知道为啥现在提起网络文学, 多数时候对方都还是觉得「格」不够. 可现在的网络小说与《明报》连载的武侠小说, 有多大的区别?&lt;/p>
&lt;/li>
&lt;li>
&lt;p>年度非虚构类图书: &lt;a href="https://book.douban.com/subject/27091742/">《邻人之妻》&lt;/a>&lt;/p>
&lt;p>我姓王和我看这本书没有任何联系(认真脸), 真的是好奇性美国解放运动到底是怎么产生的而看的.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>年度电器: Sony 9000E 电视&lt;/p>
&lt;p>大屏幕 4k HDR 的全新体验让我想把之前在显示器上玩的好游戏看的好电影都重新来一次.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>年度音乐: &lt;a href="http://music.163.com/song/443875380/?userid=564654" title="@网易云音乐">《生きていたんだよな(她曾活过啊)》&lt;/a>&lt;/p>
&lt;p>歌词很棒? 看到年度音乐四个字, 脑子里第一首出现的歌.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>年度视频: 井越的 vlog——&lt;a href="https://www.bilibili.com/video/av17898771/">《别再问我什么是 2017》&lt;/a>&lt;/p>
&lt;p>看了几十个 Casey Neistat 的 vlog 也没能让自己行动起来用视频记录生活. 但看完这个视频的第二天, 就开始尝试着在大街上对着手机镜头说话啦.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>年度电子产品: iPhoneX&lt;/p>
&lt;p>用来拍了不少视频, 照片. 人像模式拍出的照片, 会让我这个摄影门外汉产生一种「自己拍的还不错嘛」的错觉, 从而达到了要经常掏出手机记录生活的目标.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>希望明年也能多创造一些东西, 能够在 19 年的年终总结中, 选出自己满意的年度 XXX 吧&lt;/p></description></item><item><title>为什么 Cocoapods 1.5 支持编译静态库之后大家这么高兴?</title><link>https://joeytat.github.io/posts/181227_cocoapods-1.5-static-library/</link><pubDate>Thu, 27 Dec 2018 00:00:00 +0000</pubDate><guid>https://joeytat.github.io/posts/181227_cocoapods-1.5-static-library/</guid><description>
&lt;p>昨天在 Twitter 上看到 TualatriX 说&lt;a href="https://twitter.com/tualatrix/status/1077166131956264960">把私有库都通过 Cocoapods 编译成静态库之后很爽&lt;/a>, 就有点好奇到底是爽在哪里.&lt;/p>
&lt;p>于是去搜了一下, 原来是前段时间(大半年前吧&amp;hellip;), Cocoapods 发布了 1.5 的 &lt;a href="http://blog.cocoapods.org/CocoaPods-1.5.0/">release note&lt;/a>, 宣布支持 Swift 静态库编译. 并且文中提到了对于担心动态二进制文件影响应用启动速度的人来说, 这是个了不起的更新.
jh
那又是为什么 App 使用静态库会比动态库有更快的启动速度呢? 又跑去搜了一下官方文档. 打开 &lt;a href="https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/DynamicLibraries/100-Articles/OverviewOfDynamicLibraries.html">Dynamic Library Programming Topics&lt;/a> 开头就看到:&lt;/p>
&lt;blockquote>
&lt;p>This article introduces dynamic libraries and shows how using dynamic libraries instead of static libraries reduces both the file size and initial memory footprint of the apps that use them.&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>这篇文章主要介绍了动态库, 并且展示了通过&lt;strong>使用动态库&lt;/strong>而不是静态库, 是如何&lt;strong>缩减&lt;/strong>了应用的大小和初始内存空间的.&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="http://ww1.rs.fanjian.net/c/ab/c8/25/53abf0c06ec808c1fe250d3565ff0d32.jpg" alt="黑人问号">&lt;/p>
&lt;p>┻━┻ (ヽ(`Д ́)ノ( ┻━┻ 这和说好的不一样啊?&lt;/p>
&lt;p>带着疑问我又跑去看了一下苹果的 &lt;a href="https://developer.apple.com/videos/play/wwdc2016/406">WWDC 2016 - Optimizing App Startup Time&lt;/a> 的视频, 这次问题终于得到了解决.&lt;/p>
&lt;p>这里的库是什么? 是可执行文件的集合. 静态库与动态库调用时机的区别在于, 静态库在应用启动的时候, 会和程序的可执行代码一起, 被加载到应用的内存空间中. 这就会导致应用启动慢, 并且内存占用大. 而动态库则是在代码真正被需要调用的时候, 才加载到内存中.&lt;/p>
&lt;p>所以才会有苹果文档中提到的「通过&lt;strong>使用动态库&lt;/strong>而不是静态库, 是如何&lt;strong>缩减&lt;/strong>了应用的大小和初始内存空间的」这句话.&lt;/p>
&lt;p>可这是站在系统角度来说的. 在 iOS 中, 平均每个 App 包含了 &lt;a href="https://developer.apple.com/videos/play/wwdc2016-406/?time=1684">1 到 400&lt;/a> 个动态库. 其中有很大一部分是系统级动态库. 苹果为其做了许多的优化, 比如提前计算, 提前缓存等. 这对于系统提供的动态库来说, 当然比静态库更快.&lt;/p>
&lt;p>但 App 中还包含了很多自有的动态库, 这部分动态库苹果没有办法为期提供优化. 而对于 dylib 的加载又是非常耗费资源的. 所以苹果对其的建议是最好在 &lt;a href="https://developer.apple.com/videos/play/wwdc2016-406/?time=1794">6&lt;/a> 个左右.&lt;/p>
&lt;p>然后我也把项目中的 Swift pods 编译为静态库了, 效果如下.&lt;/p>
&lt;pre tabindex="0">&lt;code>// 优化前
[DYMTLInitPlatform] platform initialization successful
Total pre-main time: 1.5 seconds (100.0%)
dylib loading time: 968.07 milliseconds (61.1%)
......
......
&lt;/code>&lt;/pre>&lt;pre tabindex="0">&lt;code>// Pods 使用静态库后
[DYMTLInitPlatform] platform initialization successful
Total pre-main time: 1.1 seconds (100.0%)
dylib loading time: 520.52 milliseconds (47.2%)
......
......
&lt;/code>&lt;/pre>&lt;p>最后再总结一下.&lt;/p>
&lt;ul>
&lt;li>对于系统提供了优化的动态库来说, 一定是比静态库启动加载快且占用内存更小的. 14er&lt;/li>
&lt;li>而对于 App 自有的动态库来说, 系统在加载动态库所消耗的资源要比加载静态库来得多, 所以最好限制在 6 个左右.&lt;/li>
&lt;/ul>
&lt;h2 id="参考链接">参考链接&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.jianshu.com/p/3d0ae289dee0">Cocoapods 的静态库和动态库&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developer.apple.com/videos/play/wwdc2016/406/?time=203">WWDC 2016 - Optimizing App Startup Time&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/DynamicLibraries/100-Articles/OverviewOfDynamicLibraries.html">Dynamic Library Programming Topics&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://tech.meituan.com/waimai_ios_optimizing_startup.html">美团外卖 iOS App冷启动治理&lt;/a>&lt;/li>
&lt;/ul></description></item></channel></rss>