<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>移动开发中实现 Deep Linking 的 URL Scheme 和 Universal Links 的区别是什么？ | Dev Log</title>
<meta name=keywords content="KnownEnoughToBeDangerous"><meta name=description content="经历过的 Mobile 项目基本上都有支持 Deep Linking 的需求，每次新项目都会经历向其他端同事和 BA 解释实现 Deep Linking 两种方案的区别，于是就有了这一篇短文。主要是介绍两种方案的优缺点和实现成本差异，并不涉及如何实现的代码步骤。"><meta name=author content><link rel=canonical href=https://joeytat.github.io/posts/differences_between_scheme_and_universal_links/><meta name=google-site-verification content="G-83QEEKFELL"><link crossorigin=anonymous href=/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as=style><link rel=icon href=https://joeytat.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://joeytat.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://joeytat.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://joeytat.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://joeytat.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://joeytat.github.io/posts/differences_between_scheme_and_universal_links/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://joeytat.github.io/posts/differences_between_scheme_and_universal_links/"><meta property="og:site_name" content="Dev Log"><meta property="og:title" content="移动开发中实现 Deep Linking 的 URL Scheme 和 Universal Links 的区别是什么？"><meta property="og:description" content="经历过的 Mobile 项目基本上都有支持 Deep Linking 的需求，每次新项目都会经历向其他端同事和 BA 解释实现 Deep Linking 两种方案的区别，于是就有了这一篇短文。主要是介绍两种方案的优缺点和实现成本差异，并不涉及如何实现的代码步骤。"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-07-27T00:00:00+00:00"><meta property="article:modified_time" content="2022-07-27T00:00:00+00:00"><meta property="article:tag" content="KnownEnoughToBeDangerous"><meta name=twitter:card content="summary"><meta name=twitter:title content="移动开发中实现 Deep Linking 的 URL Scheme 和 Universal Links 的区别是什么？"><meta name=twitter:description content="经历过的 Mobile 项目基本上都有支持 Deep Linking 的需求，每次新项目都会经历向其他端同事和 BA 解释实现 Deep Linking 两种方案的区别，于是就有了这一篇短文。主要是介绍两种方案的优缺点和实现成本差异，并不涉及如何实现的代码步骤。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://joeytat.github.io/posts/"},{"@type":"ListItem","position":2,"name":"移动开发中实现 Deep Linking 的 URL Scheme 和 Universal Links 的区别是什么？","item":"https://joeytat.github.io/posts/differences_between_scheme_and_universal_links/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"移动开发中实现 Deep Linking 的 URL Scheme 和 Universal Links 的区别是什么？","name":"移动开发中实现 Deep Linking 的 URL Scheme 和 Universal Links 的区别是什么？","description":"经历过的 Mobile 项目基本上都有支持 Deep Linking 的需求，每次新项目都会经历向其他端同事和 BA 解释实现 Deep Linking 两种方案的区别，于是就有了这一篇短文。主要是介绍两种方案的优缺点和实现成本差异，并不涉及如何实现的代码步骤。","keywords":["KnownEnoughToBeDangerous"],"articleBody":"经历过的 Mobile 项目基本上都有支持 Deep Linking 的需求，每次新项目都会经历向其他端同事和 BA 解释实现 Deep Linking 两种方案的区别，于是就有了这一篇短文。主要是介绍两种方案的优缺点和实现成本差异，并不涉及如何实现的代码步骤。\n首先什么是 Deep Linking，简单来说就是让一个 App 可以通过 URL 打开其他的 App，以提供更便捷高效的用户体验。\n如果想跳到别人那去 BA 老刘：「如果想在 App 里打开人家的 App 应该怎么做呢？」\n开发小曾：「目前有两种选项，URL Scheme 和 Universal Links。」\nBA 老刘：「区别是啥？」\n开发小曾：「主要看你想不想处理用户没有安装对方 App 的情况。」\nps: Android 中这两种选项是 Deep Links 和 App Links，运作原理大体相同，实现方式 iOS 和 Android 有些许差异。为少打字，下文将统一使用 URL Scheme 和 Universal Links。\nURL Scheme 通常长这样： example://destination?param1=hello。\n想通过 URL Scheme 跳转到某个 App，我们需要知道对方 App 定义的 Scheme 是什么（这不算是废话）。\n以 Twitter 为例，如果当前设备安装了 Twitter：\n通过 twitter://user?screen_name=elonmusk 这样一个 URL Scheme，就可以打开 Twitter 并且跳转到 Elon Musk 的主页（scheme 可以输入 Safari 地址栏进行测试）。\n如果当前设备没有安装 Twitter：\n可以通过代码得到无法解析 URL 的错误，接下来要如何处理，就需要工程师自己去实现了。 比如可以加上判断，如果打不开 Twitter 的 Scheme，就去打开 App Store 的 Scheme 引导用户下载 Twitter，或者去打开微博。\nUniversal Links Universal Links 则是使用了 HTTP 或 HTTPS（iOS 只支持 HTTPS）Scheme 的 URL。\n依然用 Twitter 举例：\n如果当前设备安装了 Twitter：\n通过打开 URL https://twitter.com/elonmusk 可以跳转到 Twitter App 中 Elon Musk 的主页。\n如果用户没有安装 Twitter：\n会打开网页版 Elon Musk 的主页。\n方案对比 有安装对应 App 没有安装对应 App URL Scheme 直接打开对应 App 需要自行处理设备没有安装对应 App 的情况，但处理方案可以非常灵活多变 Universal Links 直接打开对应 App 无需额外处理，通常 Universal Link 就对应了一个网页，在当前设备没有安装 App 的情况下，会跳转到对应网页 如果想让别人跳过来 BA 老刘：「那如果想让我们的 App 支持跳转呢？」。\n开发小曾：「还是那两种选项，URL Scheme 和 Universal Links。」\nBA 老刘：「区别是啥？」\n开发小曾：「主要是实现成本和想支持跳转的范围。」\nURL Scheme 在 App 中设置一个自定义 Scheme 即可。当三方 App 通过代码调用尝试跳转某个 Scheme，系统会检测当前设备是否安装了有定义该 Scheme 的 App。\n如果想要支持对方跳转到某个特定界面，只需要在 App 中增加解析 URL 的方法即可。 具体实现细节可以参考：\niOS - Defining a custom URL scheme for your app Android - Hanling Android App Link - Deep Links Universal Links 相比起 URL Scheme 只需要前端实现，Universal Links 的支持要复杂一些，原因是在于其使用场景扩大了。\nURL Scheme 的跳转，需要让三方 App 知道我们的 Scheme 定义即可，由第三方 App 来发起跳转。如果当前设备并没有安装 App，如何提供备选方案，就完全依赖于三方实现了。\nUniversal Links 的跳转，是三方 App 打开一个链接时，由系统决定应该跳转到 App（将其当作 Universal Link） 还是跳转到网页（将其当作普通的 HTTP Link）。同时系统来控制跳转，则意味着用户从系统中几乎任何地方（比如邮件、短信、备忘录、日历）点击 Universal Link 都能跳转到 App 中。这样即使在当前设备没有安装 App 的情况下，依然保证用户可以通过网页访问到需要的资源。\n所以实现的区别在于，需要让系统知道，哪些域名的 URL 是应该跳转到我们的 App。\n依然用 Twitter 举例，当我们需要让系统支持在点击任何带有 twitter.com 为 Host 的链接时，都尝试着唤起 Twitter 就需要：\n开发人员需要在 Twitter App 的配置中，添加 associated domain 的记录，比如 twitter.com。 当 Twitter App 被安装到用户的手机或者应用更新时，系统会去 Twitter App 包中查找 associated domain 记录。 如果存在这样一份记录，系统会去访问该 domain 下的一个 JSON 文件，该文件中需要包含 Twitter App 的 App ID，以建立该站点与 App 的联系。比如 Twitter 就将这份 JSON 文件放在了 https://twitter.com/.well-known/apple-app-site-association。 由此当系统在处理链接的点击时，会去判断 https://twitter.com 是否和当前设备中安装的某个 App 之间存在联系，如果已安装的某个 App 的 app id 存在于该 domain 下的 site association JSON 文件中，则将 URL 作为参数代入，跳转到 App 中。 用图片来表示的话，大概是这样，首先让 OS 建立域名和 App 的联系：\n当存在联系之后，点击链接时，OS 会去唤起 App：\n具体实现细节可以参考：\niOS - Allowing Apps and Websites to Link to Your Content Android - Hanling Android App Link 对比 实现成本 支持跳转的范围 没有安装 App URL Scheme 需要在 App 中维护一个支持被跳转的 Scheme 列表 只能由知道 Scheme 的 App 来主动进行跳转 需要让三方 App 来处理没有安装 App 的情况 Universal Links App 中要维护一个支持被跳转的 domain 列表，同时需要在 domain 对应服务器中放一个 JSON 文件，让系统知道该 domain 同 App 之间的联系 系统中几乎所有可点击链接区域都可以被系统触发跳转，比如点击邮件、短信、网页、三方 App 中的 Universal Link 时 用户会跳转到 Universal Link 对应的网页，在网页中我们可以实现一套 Web 版本，或者直接在网页中打开应用商店，引导用户下载 App 简单总结 跳到别人那去，一般来说在需要灵活处理当前设备没有安装对方 App 的情况下，通常会选择 URL Scheme，否则选择 Universal Links。\n支持别人跳过来，两个方案可以共存。\nURL Scheme 相对来说实现成本非常低廉，仅需要前端维护 Scheme 列表并且负责解析即可。但需要让对方来处理，如果当前设备没有安装 App 应该怎么办。 Universal Links 的实现则相对复杂，必须要把 domain 和 app 之间建立联系的 json 文件放在服务器，让系统在安装 App 的时候去访问。但好处是，如果本来就有 Web 版的业务，那么自动就可以在用户未安装 App 时得到相应的服务。 ","wordCount":"414","inLanguage":"en","datePublished":"2022-07-27T00:00:00Z","dateModified":"2022-07-27T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://joeytat.github.io/posts/differences_between_scheme_and_universal_links/"},"publisher":{"@type":"Organization","name":"Dev Log","logo":{"@type":"ImageObject","url":"https://joeytat.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://joeytat.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://joeytat.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://joeytat.github.io/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://joeytat.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://joeytat.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">移动开发中实现 Deep Linking 的 URL Scheme 和 Universal Links 的区别是什么？</h1><div class=post-description>经历过的 Mobile 项目基本上都有支持 Deep Linking 的需求，每次新项目都会经历向其他端同事和 BA 解释实现 Deep Linking 两种方案的区别，于是就有了这一篇短文。主要是介绍两种方案的优缺点和实现成本差异，并不涉及如何实现的代码步骤。</div><div class=post-meta><span title='2022-07-27 00:00:00 +0000 UTC'>July 27, 2022</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;414 words</div></header><div class=post-content><p>经历过的 Mobile 项目基本上都有支持 Deep Linking 的需求，每次新项目都会经历向其他端同事和 BA 解释实现 Deep Linking 两种方案的区别，于是就有了这一篇短文。主要是介绍两种方案的优缺点和实现成本差异，并不涉及如何实现的代码步骤。</p><p>首先什么是 Deep Linking，简单来说就是让一个 App 可以通过 URL 打开其他的 App，以提供更便捷高效的用户体验。</p><h2 id=如果想跳到别人那去>如果想跳到别人那去<a hidden class=anchor aria-hidden=true href=#如果想跳到别人那去>#</a></h2><p>BA 老刘：「如果想在 App 里打开人家的 App 应该怎么做呢？」<br>开发小曾：「目前有两种选项，URL Scheme 和 Universal Links。」<br>BA 老刘：「区别是啥？」<br>开发小曾：「主要看你想不想处理用户没有安装对方 App 的情况。」</p><p><em>ps: Android 中这两种选项是 Deep Links 和 App Links，运作原理大体相同，实现方式 iOS 和 Android 有些许差异。为少打字，下文将统一使用 URL Scheme 和 Universal Links。</em></p><h3 id=url-scheme>URL Scheme<a hidden class=anchor aria-hidden=true href=#url-scheme>#</a></h3><p>通常长这样： <code>example://destination?param1=hello</code>。</p><p>想通过 URL Scheme 跳转到某个 App，我们需要知道对方 App 定义的 Scheme 是什么（这不算是废话）。</p><p>以 Twitter 为例，如果当前设备<strong>安装了 Twitter</strong>：<br>通过 <code>twitter://user?screen_name=elonmusk</code> 这样一个 URL Scheme，就可以打开 Twitter 并且跳转到 Elon Musk 的主页（scheme 可以输入 Safari 地址栏进行测试）。</p><p>如果当前设备<strong>没有安装 Twitter</strong>：<br>可以通过代码得到无法解析 URL 的错误，接下来要如何处理，就需要工程师自己去实现了。
比如可以加上判断，如果打不开 Twitter 的 Scheme，就去打开 App Store 的 Scheme 引导用户下载 Twitter，或者去打开微博。</p><h3 id=universal-links>Universal Links<a hidden class=anchor aria-hidden=true href=#universal-links>#</a></h3><p>Universal Links 则是使用了 HTTP 或 HTTPS（iOS 只支持 HTTPS）Scheme 的 URL。</p><p>依然用 Twitter 举例：</p><p>如果当前设备<strong>安装了 Twitter</strong>：<br>通过打开 URL <code>https://twitter.com/elonmusk</code> 可以跳转到 Twitter App 中 Elon Musk 的主页。</p><p>如果用户<strong>没有安装 Twitter</strong>：<br>会打开网页版 Elon Musk 的主页。</p><h3 id=方案对比>方案对比<a hidden class=anchor aria-hidden=true href=#方案对比>#</a></h3><table><thead><tr><th></th><th>有安装对应 App</th><th>没有安装对应 App</th></tr></thead><tbody><tr><td>URL Scheme</td><td>直接打开对应 App</td><td>需要自行处理设备没有安装对应 App 的情况，但处理方案可以非常灵活多变</td></tr><tr><td>Universal Links</td><td>直接打开对应 App</td><td>无需额外处理，通常 Universal Link 就对应了一个网页，在当前设备没有安装 App 的情况下，会跳转到对应网页</td></tr></tbody></table><h2 id=如果想让别人跳过来>如果想让别人跳过来<a hidden class=anchor aria-hidden=true href=#如果想让别人跳过来>#</a></h2><p>BA 老刘：「那如果想让我们的 App 支持跳转呢？」。<br>开发小曾：「还是那两种选项，URL Scheme 和 Universal Links。」<br>BA 老刘：「区别是啥？」<br>开发小曾：「主要是实现成本和想支持跳转的范围。」</p><h3 id=url-scheme-1>URL Scheme<a hidden class=anchor aria-hidden=true href=#url-scheme-1>#</a></h3><p>在 App 中设置一个自定义 Scheme 即可。当三方 App 通过代码调用尝试跳转某个 Scheme，系统会检测当前设备是否安装了有定义该 Scheme 的 App。</p><p>如果想要支持对方跳转到某个特定界面，只需要在 App 中增加解析 URL 的方法即可。
具体实现细节可以参考：</p><ul><li><a href=https://developer.apple.com/documentation/xcode/defining-a-custom-url-scheme-for-your-app>iOS - Defining a custom URL scheme for your app</a></li><li><a href=https://developer.android.com/training/app-links#deep-links>Android - Hanling Android App Link - Deep Links</a></li></ul><h3 id=universal-links-1>Universal Links<a hidden class=anchor aria-hidden=true href=#universal-links-1>#</a></h3><p>相比起 URL Scheme 只需要前端实现，Universal Links 的支持要复杂一些，原因是在于其使用场景扩大了。<br>URL Scheme 的跳转，需要让三方 App 知道我们的 Scheme 定义即可，由<strong>第三方 App 来发起跳转</strong>。如果当前设备并没有安装 App，如何提供备选方案，就完全依赖于三方实现了。</p><p>Universal Links 的跳转，是三方 App 打开一个链接时，由系统决定应该跳转到 App（将其当作 Universal Link） 还是跳转到网页（将其当作普通的 HTTP Link）。同时系统来控制跳转，则意味着用户从系统中几乎任何地方（比如邮件、短信、备忘录、日历）点击 Universal Link 都能跳转到 App 中。这样即使在当前设备没有安装 App 的情况下，依然保证用户可以通过网页访问到需要的资源。</p><p>所以实现的区别在于，需要让系统知道，哪些域名的 URL 是应该跳转到我们的 App。</p><p>依然用 Twitter 举例，当我们需要让系统支持在点击任何带有 <code>twitter.com</code> 为 Host 的链接时，都尝试着唤起 Twitter 就需要：</p><ol><li>开发人员需要在 Twitter App 的配置中，添加 associated domain 的记录，比如 <code>twitter.com</code>。</li><li>当 Twitter App 被安装到用户的手机或者应用更新时，系统会去 Twitter App 包中查找 associated domain 记录。</li><li>如果存在这样一份记录，系统会去访问该 domain 下的一个 JSON 文件，该文件中需要包含 Twitter App 的 App ID，以建立该站点与 App 的联系。比如 Twitter 就将这份 JSON 文件放在了 <code>https://twitter.com/.well-known/apple-app-site-association</code>。</li><li>由此当系统在处理链接的点击时，会去判断 <code>https://twitter.com</code> 是否和当前设备中安装的某个 App 之间存在联系，如果已安装的某个 App 的 app id 存在于该 domain 下的 site association JSON 文件中，则将 URL 作为参数代入，跳转到 App 中。</li></ol><p>用图片来表示的话，大概是这样，首先让 OS 建立域名和 App 的联系：</p><p><img alt="make connection between domain and the app" loading=lazy src=/deeplinking_connection.png></p><p>当存在联系之后，点击链接时，OS 会去唤起 App：</p><p><img alt="tapping on the link will navigate to the app" loading=lazy src=/deeplinking_connection1.png></p><p>具体实现细节可以参考：</p><ul><li><a href=https://developer.apple.com/documentation/xcode/allowing-apps-and-websites-to-link-to-your-content>iOS - Allowing Apps and Websites to Link to Your Content</a></li><li><a href=https://developer.android.com/training/app-links#android-app-links>Android - Hanling Android App Link</a></li></ul><h3 id=对比>对比<a hidden class=anchor aria-hidden=true href=#对比>#</a></h3><table><thead><tr><th></th><th>实现成本</th><th>支持跳转的范围</th><th>没有安装 App</th></tr></thead><tbody><tr><td>URL Scheme</td><td>需要在 App 中维护一个支持被跳转的 Scheme 列表</td><td>只能由知道 Scheme 的 App 来主动进行跳转</td><td>需要让三方 App 来处理没有安装 App 的情况</td></tr><tr><td>Universal Links</td><td>App 中要维护一个支持被跳转的 domain 列表，同时需要在 domain 对应服务器中放一个 JSON 文件，让系统知道该 domain 同 App 之间的联系</td><td>系统中几乎所有可点击链接区域都可以被系统触发跳转，比如点击邮件、短信、网页、三方 App 中的 Universal Link 时</td><td>用户会跳转到 Universal Link 对应的网页，在网页中我们可以实现一套 Web 版本，或者直接在网页中打开应用商店，引导用户下载 App</td></tr></tbody></table><h2 id=简单总结>简单总结<a hidden class=anchor aria-hidden=true href=#简单总结>#</a></h2><p>跳到别人那去，一般来说在需要灵活处理当前设备<strong>没有安装</strong>对方 App 的情况下，通常会选择 URL Scheme，否则选择 Universal Links。</p><p>支持别人跳过来，两个方案可以共存。</p><ul><li>URL Scheme 相对来说实现成本非常低廉，仅需要前端维护 Scheme 列表并且负责解析即可。但需要让对方来处理，如果当前设备没有安装 App 应该怎么办。</li><li>Universal Links 的实现则相对复杂，必须要把 domain 和 app 之间建立联系的 json 文件放在服务器，让系统在安装 App 的时候去访问。但好处是，如果本来就有 Web 版的业务，那么自动就可以在用户未安装 App 时得到相应的服务。</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://joeytat.github.io/tags/knownenoughtobedangerous/>KnownEnoughToBeDangerous</a></li></ul><nav class=paginav><a class=prev href=https://joeytat.github.io/posts/why-swiftui-is-better-at-building-a-design-system/><span class=title>« Prev</span><br><span>构建易维护的 Design System: 为什么 SwiftUI 会是更好的选择</span>
</a><a class=next href=https://joeytat.github.io/posts/apple_swiftui_workshop/><span class=title>Next »</span><br><span>参加 Apple 开发者线上活动是什么样的体验？</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://joeytat.github.io/>Dev Log</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>